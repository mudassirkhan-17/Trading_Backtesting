import pandas as pd
import numpy as np
import math

class AberrationStrategies:
    def __init__(self, period=20, baseline=0, upper_threshold=2, lower_threshold=-2):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.aberration = None

    def compute_values(self, df):
        sma = pd.Series(df['Close']).rolling(window=self.period, min_periods=1).mean()
        aberration = (df['Close'] - sma) / sma * 100
        return pd.Series(aberration, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if self.aberration is None:
            self.aberration = self.compute_values(df)
        aberration_prev = self.aberration.shift(1)
        cond_bull = (aberration_prev <= self.baseline) & (self.aberration > self.baseline)
        cond_bear = (aberration_prev >= self.baseline) & (self.aberration < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Aberration_Above_Baseline', -1: 'Aberration_Below_Baseline', 0: 'Aberration_Neutral'}
        mapping_explanation = {
            1: f'Aberration crossed above the baseline of {self.baseline}, indicating bullish momentum.',
            -1: f'Aberration crossed below the baseline of {self.baseline}, indicating bearish momentum.',
            0: f'Aberration remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'Aberration_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'Aberration_Period:{self.period}_TA_Indicator_Value'] = self.aberration
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Aberration_Period:{self.period}_TA_Indicator_Value'] = self.aberration
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.aberration is None:
            self.aberration = self.compute_values(df)
        cond_bull = self.aberration < self.lower_threshold
        cond_bear = self.aberration > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Aberration_Oversold', -1: 'Aberration_Overbought', 0: 'Aberration_Neutral'}
        mapping_explanation = {
            1: f'Aberration is below the lower threshold of {self.lower_threshold}, indicating oversold conditions and a potential bullish reversal.',
            -1: f'Aberration is above the upper threshold of {self.upper_threshold}, indicating overbought conditions and a potential bearish reversal.',
            0: 'Aberration is within normal limits, suggesting balanced market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'Aberration_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'Aberration_Period:{self.period}_TA_Indicator_Value'] = self.aberration
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Aberration_Period:{self.period}_TA_Indicator_Value'] = self.aberration
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.aberration is None:
            self.aberration = self.compute_values(df)
        diff = self.aberration.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Aberration_Rising', -1: 'Aberration_Falling', 0: 'Aberration_Unchanged'}
        mapping_explanation = {
            1: 'Aberration is rising, suggesting strengthening bullish momentum.',
            -1: 'Aberration is falling, suggesting strengthening bearish momentum.',
            0: 'Aberration remains unchanged, indicating neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'Aberration_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'Aberration_Period:{self.period}_TA_Indicator_Value'] = self.aberration
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Aberration_Period:{self.period}_TA_Indicator_Value'] = self.aberration
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  

  
class AbsolutePriceOscillatorStrategies:
    def __init__(self, short_period=12, long_period=26, baseline=0, upper_threshold=1.0, lower_threshold=-1.0):
        self.short_period = short_period
        self.long_period = long_period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.apo = None

    def compute_values(self, df):
        ema_short = df['Close'].ewm(span=self.short_period, adjust=False).mean()
        ema_long = df['Close'].ewm(span=self.long_period, adjust=False).mean()
        apo = ema_short - ema_long
        return pd.Series(apo, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if self.apo is None:
            self.apo = self.compute_values(df)
        apo_prev = self.apo.shift(1)
        cond_bull = (apo_prev <= self.baseline) & (self.apo > self.baseline)
        cond_bear = (apo_prev >= self.baseline) & (self.apo < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'APO_Above_Baseline', -1: 'APO_Below_Baseline', 0: 'APO_Neutral'}
        mapping_explanation = {
            1: f'APO crossed above the baseline of {self.baseline}, indicating bullish momentum.',
            -1: f'APO crossed below the baseline of {self.baseline}, indicating bearish momentum.',
            0: f'APO remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'APO_SP:{self.short_period}_LP:{self.long_period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'APO_SP:{self.short_period}_TA_Indicator_Value'] = self.apo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'APO_SP:{self.short_period}_TA_Indicator_Value'] = self.apo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.apo is None:
            self.apo = self.compute_values(df)
        cond_bull = self.apo < self.lower_threshold
        cond_bear = self.apo > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'APO_Oversold', -1: 'APO_Overbought', 0: 'APO_Neutral'}
        mapping_explanation = {
            1: f'APO is below the lower threshold of {self.lower_threshold}, suggesting potential undervaluation and bullish reversal.',
            -1: f'APO is above the upper threshold of {self.upper_threshold}, suggesting potential overvaluation and bearish reversal.',
            0: 'APO is within normal range, indicating balanced market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'APO_SP:{self.short_period}_LP:{self.long_period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'APO_SP:{self.short_period}_TA_Indicator_Value'] = self.apo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'APO_SP:{self.short_period}_TA_Indicator_Value'] = self.apo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.apo is None:
            self.apo = self.compute_values(df)
        diff = self.apo.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'APO_Rising', -1: 'APO_Falling', 0: 'APO_Unchanged'}
        mapping_explanation = {
            1: 'APO is rising, indicating increasing bullish momentum.',
            -1: 'APO is falling, indicating increasing bearish momentum.',
            0: 'APO remains unchanged, suggesting neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'APO_SP:{self.short_period}_LP:{self.long_period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'APO_SP:{self.short_period}_TA_Indicator_Value'] = self.apo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'APO_SP:{self.short_period}_TA_Indicator_Value'] = self.apo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  

  
class AccelerationBandsStrategies:
    def __init__(self, period=20, multiplier=0.5):
        self.period = period
        self.multiplier = multiplier
        self.midline = None
        self.upper_band = None
        self.lower_band = None

    def compute_values(self, df):
        self.midline = df['Close'].rolling(window=self.period, min_periods=1).mean()
        avg_range = (df['High'] - df['Low']).rolling(window=self.period, min_periods=1).mean()
        self.upper_band = self.midline + self.multiplier * avg_range
        self.lower_band = self.midline - self.multiplier * avg_range
        return self.midline, self.upper_band, self.lower_band

    def calculate_scores_zero_cross_strategy(self, df):
        if self.midline is None:
            self.compute_values(df)
        close = df['Close']
        midline_prev = self.midline.shift(1)
        close_prev = close.shift(1)
        cond_bull = (close_prev <= midline_prev) & (close > self.midline)
        cond_bear = (close_prev >= midline_prev) & (close < self.midline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Price_Above_Midline', -1: 'Price_Below_Midline', 0: 'Price_Neutral'}
        mapping_explanation = {
            1: 'The closing price crossed above the midline, indicating bullish momentum.',
            -1: 'The closing price crossed below the midline, indicating bearish momentum.',
            0: 'The closing price remains around the midline, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'ABANDS_Period:{self.period}_Multiplier:{self.multiplier}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'ABANDS_Period:{self.period}_TA_Indicator_Midline'] = self.midline
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ABANDS_Period:{self.period}_TA_Indicator_Midline'] = self.midline
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.upper_band is None or self.lower_band is None:
            self.compute_values(df)
        close = df['Close']
        cond_bull = close > self.upper_band
        cond_bear = close < self.lower_band
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Breakout_Above_UpperBand', -1: 'Breakdown_Below_LowerBand', 0: 'Within_Bands'}
        mapping_explanation = {
            1: 'The closing price broke above the upper band, indicating a bullish breakout.',
            -1: 'The closing price fell below the lower band, indicating a bearish breakdown.',
            0: 'The closing price remains within the bands, indicating balanced market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'ABANDS_Period:{self.period}_Multiplier:{self.multiplier}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'ABANDS_Period:{self.period}_TA_Indicator_UpperBand'] = self.upper_band
                df[f'ABANDS_Period:{self.period}_TA_Indicator_LowerBand'] = self.lower_band
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ABANDS_Period:{self.period}_TA_Indicator_UpperBand'] = self.upper_band
            df_copy[f'ABANDS_Period:{self.period}_TA_Indicator_LowerBand'] = self.lower_band
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.midline is None:
            self.compute_values(df)
        diff = self.midline.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Midline_Rising', -1: 'Midline_Falling', 0: 'Midline_Unchanged'}
        mapping_explanation = {
            1: 'The midline is rising, indicating upward momentum.',
            -1: 'The midline is falling, indicating downward momentum.',
            0: 'The midline remains unchanged, indicating a neutral trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'ABANDS_Period:{self.period}_Multiplier:{self.multiplier}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'ABANDS_Period:{self.period}_TA_Indicator_Midline'] = self.midline
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ABANDS_Period:{self.period}_TA_Indicator_Midline'] = self.midline
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  

  
class AccumulationDistributionLineStrategies:
    def __init__(self, baseline=0, upper_threshold=0, lower_threshold=0):
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.adl = None

    def compute_values(self, df):
        mfm = np.where((df['High'] - df['Low']) == 0, 0, ((df['Close'] - df['Low']) - (df['High'] - df['Close'])) / (df['High'] - df['Low']))
        mfv = mfm * df['Volume']
        adl = pd.Series(mfv, index=df.index).cumsum()
        return adl

    def calculate_scores_zero_cross_strategy(self, df):
        if self.adl is None:
            self.adl = self.compute_values(df)
        adl_prev = self.adl.shift(1)
        cond_bull = (adl_prev <= self.baseline) & (self.adl > self.baseline)
        cond_bear = (adl_prev >= self.baseline) & (self.adl < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'ADL_Above_Baseline', -1: 'ADL_Below_Baseline', 0: 'ADL_Neutral'}
        mapping_explanation = {
            1: f'ADL crossed above the baseline of {self.baseline}, indicating bullish accumulation.',
            -1: f'ADL crossed below the baseline of {self.baseline}, indicating bearish distribution.',
            0: f'ADL remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'ADL_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'ADL_TA_Indicator_Value'] = self.adl
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ADL_TA_Indicator_Value'] = self.adl
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.adl is None:
            self.adl = self.compute_values(df)
        cond_bull = self.adl > self.upper_threshold
        cond_bear = self.adl < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'ADL_OverAccumulated', -1: 'ADL_OverDistributed', 0: 'ADL_Neutral'}
        mapping_explanation = {
            1: f'ADL is above the upper threshold of {self.upper_threshold}, indicating strong accumulation.',
            -1: f'ADL is below the lower threshold of {self.lower_threshold}, indicating strong distribution.',
            0: f'ADL is within the thresholds, indicating balanced accumulation/distribution.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'ADL_Upper:{self.upper_threshold}_Lower:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'ADL_TA_Indicator_Value'] = self.adl
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ADL_TA_Indicator_Value'] = self.adl
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.adl is None:
            self.adl = self.compute_values(df)
        diff = self.adl.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'ADL_Rising', -1: 'ADL_Falling', 0: 'ADL_Unchanged'}
        mapping_explanation = {
            1: 'ADL is rising, indicating increasing buying pressure.',
            -1: 'ADL is falling, indicating increasing selling pressure.',
            0: 'ADL remains unchanged, indicating neutral accumulation/distribution.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'ADL_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'ADL_TA_Indicator_Value'] = self.adl
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ADL_TA_Indicator_Value'] = self.adl
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  

  
class AccumulationDistributionIndexStrategies:
    def __init__(self, baseline=0, upper_threshold=0, lower_threshold=0):
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.adi = None

    def compute_values(self, df):
        mfm = np.where((df['High'] - df['Low']) == 0, 0, ((df['Close'] - df['Low']) - (df['High'] - df['Close'])) / (df['High'] - df['Low']))
        mfv = mfm * df['Volume']
        adi = pd.Series(mfv, index=df.index).cumsum()
        return adi

    def calculate_scores_zero_cross_strategy(self, df):
        if self.adi is None:
            self.adi = self.compute_values(df)
        adi_prev = self.adi.shift(1)
        cond_bull = (adi_prev <= self.baseline) & (self.adi > self.baseline)
        cond_bear = (adi_prev >= self.baseline) & (self.adi < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'ADI_Above_Baseline', -1: 'ADI_Below_Baseline', 0: 'ADI_Neutral'}
        mapping_explanation = {
            1: f'ADI crossed above the baseline of {self.baseline}, indicating bullish accumulation.',
            -1: f'ADI crossed below the baseline of {self.baseline}, indicating bearish distribution.',
            0: f'ADI remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'ADI_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'ADI_TA_Indicator_Value'] = self.adi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ADI_TA_Indicator_Value'] = self.adi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.adi is None:
            self.adi = self.compute_values(df)
        cond_bull = self.adi > self.upper_threshold
        cond_bear = self.adi < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'ADI_OverAccumulated', -1: 'ADI_OverDistributed', 0: 'ADI_Neutral'}
        mapping_explanation = {
            1: f'ADI is above the upper threshold of {self.upper_threshold}, indicating strong accumulation.',
            -1: f'ADI is below the lower threshold of {self.lower_threshold}, indicating strong distribution.',
            0: f'ADI is within the set thresholds, indicating balanced accumulation/distribution.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'ADI_Upper:{self.upper_threshold}_Lower:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'ADI_TA_Indicator_Value'] = self.adi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ADI_TA_Indicator_Value'] = self.adi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.adi is None:
            self.adi = self.compute_values(df)
        diff = self.adi.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'ADI_Rising', -1: 'ADI_Falling', 0: 'ADI_Unchanged'}
        mapping_explanation = {
            1: 'ADI is rising, suggesting increasing buying pressure.',
            -1: 'ADI is falling, suggesting increasing selling pressure.',
            0: 'ADI remains unchanged, indicating neutral accumulation/distribution.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'ADI_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'ADI_TA_Indicator_Value'] = self.adi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ADI_TA_Indicator_Value'] = self.adi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


  

  
class AccumulationDistributionOscillatorStrategies:
    def __init__(self, fast_period=3, slow_period=10, baseline=0, upper_threshold=0, lower_threshold=0):
        self.fast_period = fast_period
        self.slow_period = slow_period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.adosc = None

    def compute_values(self, df):
        mfm = np.where((df['High'] - df['Low']) == 0, 0, ((df['Close'] - df['Low']) - (df['High'] - df['Close'])) / (df['High'] - df['Low']))
        mfv = mfm * df['Volume']
        adl = pd.Series(mfv, index=df.index).cumsum()
        fast_ma = adl.ewm(span=self.fast_period, adjust=False).mean()
        slow_ma = adl.ewm(span=self.slow_period, adjust=False).mean()
        adosc = fast_ma - slow_ma
        return pd.Series(adosc, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if self.adosc is None:
            self.adosc = self.compute_values(df)
        adosc_prev = self.adosc.shift(1)
        cond_bull = (adosc_prev <= self.baseline) & (self.adosc > self.baseline)
        cond_bear = (adosc_prev >= self.baseline) & (self.adosc < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'ADOSC_Above_Baseline', -1: 'ADOSC_Below_Baseline', 0: 'ADOSC_Neutral'}
        mapping_explanation = {
            1: f'ADOSC crossed above the baseline of {self.baseline}, indicating bullish accumulation.',
            -1: f'ADOSC crossed below the baseline of {self.baseline}, indicating bearish distribution.',
            0: f'ADOSC remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'ADOSC_FP:{self.fast_period}_SP:{self.slow_period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'ADOSC_FP:{self.fast_period}_TA_Indicator_Value'] = self.adosc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ADOSC_FP:{self.fast_period}_TA_Indicator_Value'] = self.adosc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.adosc is None:
            self.adosc = self.compute_values(df)
        cond_bull = self.adosc > self.upper_threshold
        cond_bear = self.adosc < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'ADOSC_OverAccumulated', -1: 'ADOSC_OverDistributed', 0: 'ADOSC_Neutral'}
        mapping_explanation = {
            1: f'ADOSC is above the upper threshold of {self.upper_threshold}, suggesting strong accumulation.',
            -1: f'ADOSC is below the lower threshold of {self.lower_threshold}, suggesting strong distribution.',
            0: f'ADOSC is within thresholds, indicating balanced accumulation/distribution.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'ADOSC_FP:{self.fast_period}_SP:{self.slow_period}_Upper:{self.upper_threshold}_Lower:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'ADOSC_FP:{self.fast_period}_TA_Indicator_Value'] = self.adosc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ADOSC_FP:{self.fast_period}_TA_Indicator_Value'] = self.adosc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.adosc is None:
            self.adosc = self.compute_values(df)
        diff = self.adosc.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'ADOSC_Rising', -1: 'ADOSC_Falling', 0: 'ADOSC_Unchanged'}
        mapping_explanation = {
            1: 'ADOSC is rising, indicating increasing buying pressure and accumulation momentum.',
            -1: 'ADOSC is falling, indicating increasing selling pressure and distribution momentum.',
            0: 'ADOSC remains unchanged, suggesting neutral accumulation/distribution.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'ADOSC_FP:{self.fast_period}_SP:{self.slow_period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'ADOSC_FP:{self.fast_period}_TA_Indicator_Value'] = self.adosc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ADOSC_FP:{self.fast_period}_TA_Indicator_Value'] = self.adosc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  

  
class AdaptivePriceZoneStrategies:
    def __init__(self, period=20, multiplier=0.5, baseline=0):
        self.period = period
        self.multiplier = multiplier
        self.baseline = baseline
        self.center = None
        self.upper_zone = None
        self.lower_zone = None

    def compute_values(self, df):
        self.center = df['Close'].rolling(window=self.period, min_periods=1).mean()
        prev_close = df['Close'].shift(1)
        tr = pd.DataFrame()
        tr['hl'] = df['High'] - df['Low']
        tr['hc'] = (df['High'] - prev_close).abs()
        tr['lc'] = (df['Low'] - prev_close).abs()
        true_range = tr.max(axis=1)
        atr = true_range.rolling(window=self.period, min_periods=1).mean()
        self.upper_zone = self.center + self.multiplier * atr
        self.lower_zone = self.center - self.multiplier * atr
        return self.center, self.upper_zone, self.lower_zone

    def calculate_scores_zero_cross_strategy(self, df):
        if self.center is None:
            self.compute_values(df)
        diff = df['Close'] - self.center
        diff_prev = diff.shift(1)
        cond_bull = (diff_prev <= self.baseline) & (diff > self.baseline)
        cond_bear = (diff_prev >= self.baseline) & (diff < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Price_Above_Center', -1: 'Price_Below_Center', 0: 'Price_Neutral'}
        mapping_explanation = {
            1: 'The closing price crossed above the adaptive center, indicating bullish momentum.',
            -1: 'The closing price crossed below the adaptive center, indicating bearish momentum.',
            0: 'The closing price remains around the adaptive center, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'APZ_Period:{self.period}_Multiplier:{self.multiplier}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'APZ_Period:{self.period}_TA_Center'] = self.center
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'APZ_Period:{self.period}_TA_Center'] = self.center
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.upper_zone is None or self.lower_zone is None:
            self.compute_values(df)
        cond_bull = df['Close'] < self.lower_zone
        cond_bear = df['Close'] > self.upper_zone
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Price_Below_LowerZone', -1: 'Price_Above_UpperZone', 0: 'Within_AdaptiveZone'}
        mapping_explanation = {
            1: f'The closing price is below the lower adaptive zone, suggesting oversold conditions and potential bullish reversal.',
            -1: f'The closing price is above the upper adaptive zone, suggesting overbought conditions and potential bearish reversal.',
            0: 'The closing price is within the adaptive price zone, indicating balanced market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'APZ_Period:{self.period}_Multiplier:{self.multiplier}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'APZ_Period:{self.period}_TA_UpperZone'] = self.upper_zone
                df[f'APZ_Period:{self.period}_TA_LowerZone'] = self.lower_zone
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'APZ_Period:{self.period}_TA_UpperZone'] = self.upper_zone
            df_copy[f'APZ_Period:{self.period}_TA_LowerZone'] = self.lower_zone
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.center is None:
            self.compute_values(df)
        diff = self.center.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Center_Rising', -1: 'Center_Falling', 0: 'Center_Unchanged'}
        mapping_explanation = {
            1: 'The adaptive center is rising, indicating upward momentum.',
            -1: 'The adaptive center is falling, indicating downward momentum.',
            0: 'The adaptive center is unchanged, indicating a neutral trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'APZ_Period:{self.period}_Multiplier:{self.multiplier}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'APZ_Period:{self.period}_TA_Center'] = self.center
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'APZ_Period:{self.period}_TA_Center'] = self.center
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  

  
class AllMovingAverageStrategies:
    def __init__(self, short_period=5, medium_period=20, long_period=50, threshold_percent=0.02):
        self.short_period = short_period
        self.medium_period = medium_period
        self.long_period = long_period
        self.threshold_percent = threshold_percent
        self.allma = None

    def compute_values(self, df):
        sma_short = df['Close'].rolling(window=self.short_period, min_periods=1).mean()
        sma_medium = df['Close'].rolling(window=self.medium_period, min_periods=1).mean()
        sma_long = df['Close'].rolling(window=self.long_period, min_periods=1).mean()
        self.allma = (sma_short + sma_medium + sma_long) / 3
        return self.allma

    def calculate_scores_zero_cross_strategy(self, df):
        if self.allma is None:
            self.compute_values(df)
        price = df['Close']
        allma_prev = self.allma.shift(1)
        price_prev = price.shift(1)
        cond_bull = (price_prev <= allma_prev) & (price > self.allma)
        cond_bear = (price_prev >= allma_prev) & (price < self.allma)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Price_Crossed_Above_AllMA', -1: 'Price_Crossed_Below_AllMA', 0: 'Price_No_Cross'}
        mapping_explanation = {
            1: 'The closing price crossed above the aggregated moving average, indicating bullish momentum.',
            -1: 'The closing price crossed below the aggregated moving average, indicating bearish momentum.',
            0: 'No significant crossing occurred between the price and the aggregated moving average.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'AllMA_SP:{self.short_period}_MP:{self.medium_period}_LP:{self.long_period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'AllMA_SP:{self.short_period}_TA_Value'] = self.allma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'AllMA_SP:{self.short_period}_TA_Value'] = self.allma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.allma is None:
            self.compute_values(df)
        diff_percent = (df['Close'] - self.allma) / self.allma
        cond_bull = diff_percent < -self.threshold_percent
        cond_bear = diff_percent > self.threshold_percent
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Price_Significantly_Below_AllMA', -1: 'Price_Significantly_Above_AllMA', 0: 'Price_Near_AllMA'}
        mapping_explanation = {
            1: f'The closing price is more than {self.threshold_percent*100:.1f}% below the aggregated moving average, indicating potential bullish reversal.',
            -1: f'The closing price is more than {self.threshold_percent*100:.1f}% above the aggregated moving average, indicating potential bearish reversal.',
            0: 'The price is within a normal range relative to the aggregated moving average.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'AllMA_SP:{self.short_period}_MP:{self.medium_period}_LP:{self.long_period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'AllMA_SP:{self.short_period}_TA_Value'] = self.allma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'AllMA_SP:{self.short_period}_TA_Value'] = self.allma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.allma is None:
            self.compute_values(df)
        diff = self.allma.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'AllMA_Rising', -1: 'AllMA_Falling', 0: 'AllMA_Unchanged'}
        mapping_explanation = {
            1: 'The aggregated moving average is rising, indicating upward trend momentum.',
            -1: 'The aggregated moving average is falling, indicating downward trend momentum.',
            0: 'The aggregated moving average is unchanged, indicating a neutral trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'AllMA_SP:{self.short_period}_MP:{self.medium_period}_LP:{self.long_period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'AllMA_SP:{self.short_period}_TA_Value'] = self.allma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'AllMA_SP:{self.short_period}_TA_Value'] = self.allma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  

  
class ArcherMovingAveragesTrendsStrategies:
    def __init__(self, short_period=10, medium_period=20, long_period=50, baseline=0, upper_threshold=0.05, lower_threshold=-0.05):
        self.short_period = short_period
        self.medium_period = medium_period
        self.long_period = long_period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.amt = None

    def compute_values(self, df):
        sma_short = df['Close'].rolling(window=self.short_period, min_periods=1).mean()
        sma_medium = df['Close'].rolling(window=self.medium_period, min_periods=1).mean()
        sma_long = df['Close'].rolling(window=self.long_period, min_periods=1).mean()
        amt = ((sma_short - sma_medium) / sma_medium) + ((sma_medium - sma_long) / sma_long)
        return pd.Series(amt, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if self.amt is None:
            self.amt = self.compute_values(df)
        amt_prev = self.amt.shift(1)
        cond_bull = (amt_prev <= self.baseline) & (self.amt > self.baseline)
        cond_bear = (amt_prev >= self.baseline) & (self.amt < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'AMT_Crossed_Above_Baseline', -1: 'AMT_Crossed_Below_Baseline', 0: 'AMT_Neutral'}
        mapping_explanation = {
            1: f'The ArcherMovingAveragesTrends indicator crossed above the baseline of {self.baseline}, suggesting bullish trend conditions.',
            -1: f'The ArcherMovingAveragesTrends indicator crossed below the baseline of {self.baseline}, suggesting bearish trend conditions.',
            0: f'The ArcherMovingAveragesTrends indicator remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'AMT_SP:{self.short_period}_MP:{self.medium_period}_LP:{self.long_period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'AMT_SP:{self.short_period}_TA_Value'] = self.amt
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'AMT_SP:{self.short_period}_TA_Value'] = self.amt
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.amt is None:
            self.amt = self.compute_values(df)
        cond_bull = self.amt > self.upper_threshold
        cond_bear = self.amt < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'AMT_Over_Bullish', -1: 'AMT_Over_Bearish', 0: 'AMT_Neutral'}
        mapping_explanation = {
            1: f'The ArcherMovingAveragesTrends indicator exceeds the upper threshold of {self.upper_threshold}, indicating strong bullish trends.',
            -1: f'The ArcherMovingAveragesTrends indicator falls below the lower threshold of {self.lower_threshold}, indicating strong bearish trends.',
            0: f'The indicator is within the defined thresholds, indicating balanced trend conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'AMT_SP:{self.short_period}_MP:{self.medium_period}_LP:{self.long_period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'AMT_SP:{self.short_period}_TA_Value'] = self.amt
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'AMT_SP:{self.short_period}_TA_Value'] = self.amt
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.amt is None:
            self.amt = self.compute_values(df)
        diff = self.amt.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'AMT_Rising', -1: 'AMT_Falling', 0: 'AMT_Unchanged'}
        mapping_explanation = {
            1: 'The ArcherMovingAveragesTrends indicator is rising, indicating strengthening bullish momentum.',
            -1: 'The ArcherMovingAveragesTrends indicator is falling, indicating strengthening bearish momentum.',
            0: 'The ArcherMovingAveragesTrends indicator remains unchanged, indicating neutral trend conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'AMT_SP:{self.short_period}_MP:{self.medium_period}_LP:{self.long_period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'AMT_SP:{self.short_period}_TA_Value'] = self.amt
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'AMT_SP:{self.short_period}_TA_Value'] = self.amt
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  

  
class ArcherOnBalanceVolumeStrategies:
    def __init__(self, baseline=0, upper_threshold=0, lower_threshold=0):
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.obv = None

    def compute_values(self, df):
        diff = df['Close'].diff()
        direction = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        obv = direction * df['Volume']
        return pd.Series(obv, index=df.index).cumsum()

    def calculate_scores_zero_cross_strategy(self, df):
        if self.obv is None:
            self.obv = self.compute_values(df)
        obv_prev = self.obv.shift(1)
        cond_bull = (obv_prev <= self.baseline) & (self.obv > self.baseline)
        cond_bear = (obv_prev >= self.baseline) & (self.obv < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'OBV_Above_Baseline', -1: 'OBV_Below_Baseline', 0: 'OBV_Neutral'}
        mapping_explanation = {
            1: f'OBV crossed above the baseline of {self.baseline}, indicating bullish accumulation.',
            -1: f'OBV crossed below the baseline of {self.baseline}, indicating bearish distribution.',
            0: f'OBV remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'OBV_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'OBV_TA_Value'] = self.obv
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'OBV_TA_Value'] = self.obv
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.obv is None:
            self.obv = self.compute_values(df)
        cond_bull = self.obv > self.upper_threshold
        cond_bear = self.obv < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'OBV_OverAccumulated', -1: 'OBV_OverDistributed', 0: 'OBV_Neutral'}
        mapping_explanation = {
            1: f'OBV is above the upper threshold of {self.upper_threshold}, suggesting strong accumulation.',
            -1: f'OBV is below the lower threshold of {self.lower_threshold}, suggesting strong distribution.',
            0: 'OBV is within the set thresholds, indicating balanced volume pressure.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'OBV_Upper:{self.upper_threshold}_Lower:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'OBV_TA_Value'] = self.obv
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'OBV_TA_Value'] = self.obv
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.obv is None:
            self.obv = self.compute_values(df)
        diff = self.obv.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'OBV_Rising', -1: 'OBV_Falling', 0: 'OBV_Unchanged'}
        mapping_explanation = {
            1: 'OBV is rising, indicating increasing buying pressure.',
            -1: 'OBV is falling, indicating increasing selling pressure.',
            0: 'OBV remains unchanged, indicating neutral volume activity.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'OBV_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'OBV_TA_Value'] = self.obv
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'OBV_TA_Value'] = self.obv
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  

  
class ArnaudLegouxMovingAverageStrategies:
    def __init__(self, period=14, offset=0.85, sigma=6, baseline=0, lower_threshold=-0.5, upper_threshold=0.5):
        self.period = period
        self.offset = offset
        self.sigma = sigma
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold

    def compute_values(self, df):
        def alma_calc(x):
            window = len(x)
            m = self.offset * (window - 1)
            weights = np.array([np.exp(-((i - m) ** 2 / (2 * self.sigma * self.sigma))) for i in range(window)])
            return np.dot(x, weights) / np.sum(weights)
        self.alma = df['Close'].rolling(window=self.period, min_periods=self.period).apply(alma_calc, raw=True)
        return pd.Series(self.alma, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'alma') or self.alma is None:
            self.alma = self.compute_values(df)
        diff = df['Close'] - self.alma
        diff_prev = diff.shift(1)
        cond_bull = (diff_prev <= self.baseline) & (diff > self.baseline)
        cond_bear = (diff_prev >= self.baseline) & (diff < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Price_Above_ALMA', -1: 'Price_Below_ALMA', 0: 'Price_Near_ALMA'}
        mapping_explanation = {
            1: f'Price crossed above ALMA, suggesting bullish conditions.',
            -1: f'Price crossed below ALMA, suggesting bearish conditions.',
            0: f'Price remains near ALMA, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'ALMA_Period:{self.period}_Offset:{self.offset}_Sigma:{self.sigma}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'ALMA_Period:{self.period}_TA_Indicator_Value'] = self.alma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ALMA_Period:{self.period}_TA_Indicator_Value'] = self.alma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'alma') or self.alma is None:
            self.alma = self.compute_values(df)
        diff = df['Close'] - self.alma
        cond_bull = diff > self.upper_threshold
        cond_bear = diff < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Price_Much_Above_ALMA', -1: 'Price_Much_Below_ALMA', 0: 'Price_Close_to_ALMA'}
        mapping_explanation = {
            1: f'Price is significantly above ALMA, indicating strong bullish momentum.',
            -1: f'Price is significantly below ALMA, indicating strong bearish momentum.',
            0: f'Price is close to ALMA, suggesting balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'ALMA_Period:{self.period}_Offset:{self.offset}_Sigma:{self.sigma}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'ALMA_Period:{self.period}_TA_Indicator_Value'] = self.alma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ALMA_Period:{self.period}_TA_Indicator_Value'] = self.alma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'alma') or self.alma is None:
            self.alma = self.compute_values(df)
        slope = self.alma.diff()
        signals = np.where(slope > 0, 1, np.where(slope < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'ALMA_Rising', -1: 'ALMA_Falling', 0: 'ALMA_Unchanged'}
        mapping_explanation = {
            1: 'ALMA is rising, indicating an uptrend.',
            -1: 'ALMA is falling, indicating a downtrend.',
            0: 'ALMA remains unchanged, indicating neutral trend conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'ALMA_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'ALMA_Period:{self.period}_TA_Indicator_Value'] = self.alma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ALMA_Period:{self.period}_TA_Indicator_Value'] = self.alma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)




  

  
class AroonStrategies:
    def __init__(self, period=25, baseline=0, upper_threshold=50, lower_threshold=-50):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.aroon_up = None
        self.aroon_down = None
        self.aroon_osc = None

    def compute_values(self, df):
        period = self.period
        self.aroon_up = df['High'].rolling(window=period, min_periods=1).apply(lambda x: ((x.argmax() + 1) / period) * 100, raw=True)
        self.aroon_down = df['Low'].rolling(window=period, min_periods=1).apply(lambda x: ((x.argmin() + 1) / period) * 100, raw=True)
        self.aroon_osc = self.aroon_up - self.aroon_down
        return self.aroon_up, self.aroon_down, self.aroon_osc

    def calculate_scores_zero_cross_strategy(self, df):
        if self.aroon_osc is None:
            self.compute_values(df)
        osc_prev = self.aroon_osc.shift(1)
        cond_bull = (osc_prev <= self.baseline) & (self.aroon_osc > self.baseline)
        cond_bear = (osc_prev >= self.baseline) & (self.aroon_osc < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'AroonOsc_Above_Baseline', -1: 'AroonOsc_Below_Baseline', 0: 'AroonOsc_Neutral'}
        mapping_explanation = {
            1: f'Aroon Oscillator crossed above the baseline of {self.baseline}, indicating bullish momentum.',
            -1: f'Aroon Oscillator crossed below the baseline of {self.baseline}, indicating bearish momentum.',
            0: f'Aroon Oscillator remains neutral around the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'Aroon_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'Aroon_Period:{self.period}_TA_AroonOsc'] = self.aroon_osc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Aroon_Period:{self.period}_TA_AroonOsc'] = self.aroon_osc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.aroon_osc is None:
            self.compute_values(df)
        cond_bull = self.aroon_osc > self.upper_threshold
        cond_bear = self.aroon_osc < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'AroonOsc_Overbullish', -1: 'AroonOsc_Overbearish', 0: 'AroonOsc_Neutral'}
        mapping_explanation = {
            1: f'Aroon Oscillator is above the upper threshold of {self.upper_threshold}, indicating strong bullish momentum.',
            -1: f'Aroon Oscillator is below the lower threshold of {self.lower_threshold}, indicating strong bearish momentum.',
            0: 'Aroon Oscillator is within normal range, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'Aroon_Period:{self.period}_Upper:{self.upper_threshold}_Lower:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'Aroon_Period:{self.period}_TA_AroonOsc'] = self.aroon_osc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Aroon_Period:{self.period}_TA_AroonOsc'] = self.aroon_osc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.aroon_osc is None:
            self.compute_values(df)
        diff = self.aroon_osc.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'AroonOsc_Rising', -1: 'AroonOsc_Falling', 0: 'AroonOsc_Unchanged'}
        mapping_explanation = {
            1: 'Aroon Oscillator is rising, indicating increasing bullish momentum.',
            -1: 'Aroon Oscillator is falling, indicating increasing bearish momentum.',
            0: 'Aroon Oscillator remains unchanged, indicating a neutral trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'Aroon_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'Aroon_Period:{self.period}_TA_AroonOsc'] = self.aroon_osc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Aroon_Period:{self.period}_TA_AroonOsc'] = self.aroon_osc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  

  
class AroonOscillatorStrategies:
    def __init__(self, period=25, baseline=0, upper_threshold=50, lower_threshold=-50):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.aroon_up = None
        self.aroon_down = None
        self.aroon_osc = None

    def compute_values(self, df):
        period = self.period
        self.aroon_up = df['High'].rolling(window=period, min_periods=1).apply(
            lambda x: ((x.argmax() + 1) / period) * 100, raw=True)
        self.aroon_down = df['Low'].rolling(window=period, min_periods=1).apply(
            lambda x: ((x.argmin() + 1) / period) * 100, raw=True)
        self.aroon_osc = self.aroon_up - self.aroon_down
        return self.aroon_up, self.aroon_down, self.aroon_osc

    def calculate_scores_zero_cross_strategy(self, df):
        if self.aroon_osc is None:
            self.compute_values(df)
        osc_prev = self.aroon_osc.shift(1)
        cond_bull = (osc_prev <= self.baseline) & (self.aroon_osc > self.baseline)
        cond_bear = (osc_prev >= self.baseline) & (self.aroon_osc < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'AroonOsc_Above_Baseline', -1: 'AroonOsc_Below_Baseline', 0: 'AroonOsc_Neutral'}
        mapping_explanation = {
            1: f'Aroon Oscillator crossed above the baseline of {self.baseline}, suggesting bullish momentum.',
            -1: f'Aroon Oscillator crossed below the baseline of {self.baseline}, suggesting bearish momentum.',
            0: f'Aroon Oscillator remains neutral around the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'AroonOsc_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'AroonOsc_Period:{self.period}_TA_Value'] = self.aroon_osc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'AroonOsc_Period:{self.period}_TA_Value'] = self.aroon_osc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.aroon_osc is None:
            self.compute_values(df)
        cond_bull = self.aroon_osc > self.upper_threshold
        cond_bear = self.aroon_osc < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'AroonOsc_Overbullish', -1: 'AroonOsc_Overbearish', 0: 'AroonOsc_Neutral'}
        mapping_explanation = {
            1: f'Aroon Oscillator is above the upper threshold of {self.upper_threshold}, indicating strong bullish momentum.',
            -1: f'Aroon Oscillator is below the lower threshold of {self.lower_threshold}, indicating strong bearish momentum.',
            0: 'Aroon Oscillator is within normal limits, indicating balanced market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'AroonOsc_Period:{self.period}_Upper:{self.upper_threshold}_Lower:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'AroonOsc_Period:{self.period}_TA_Value'] = self.aroon_osc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'AroonOsc_Period:{self.period}_TA_Value'] = self.aroon_osc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.aroon_osc is None:
            self.compute_values(df)
        diff = self.aroon_osc.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'AroonOsc_Rising', -1: 'AroonOsc_Falling', 0: 'AroonOsc_Unchanged'}
        mapping_explanation = {
            1: 'Aroon Oscillator is rising, indicating increasing bullish momentum.',
            -1: 'Aroon Oscillator is falling, indicating increasing bearish momentum.',
            0: 'Aroon Oscillator remains unchanged, indicating a neutral trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'AroonOsc_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'AroonOsc_Period:{self.period}_TA_Value'] = self.aroon_osc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'AroonOsc_Period:{self.period}_TA_Value'] = self.aroon_osc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  

  
class AverageDirectionalIndexStrategies:
    def __init__(self, period=14, adx_threshold=25):
        self.period = period
        self.adx_threshold = adx_threshold
        self.adx = None
        self.di_plus = None
        self.di_minus = None

    def compute_values(self, df):
        high = df['High']
        low = df['Low']
        close = df['Close']
        prev_close = close.shift(1)
        prev_high = high.shift(1)
        prev_low = low.shift(1)
        tr = pd.concat([high - low, (high - prev_close).abs(), (low - prev_close).abs()], axis=1).max(axis=1)
        dm_plus = high - prev_high
        dm_minus = prev_low - low
        dm_plus = dm_plus.where((dm_plus > dm_minus) & (dm_plus > 0), 0)
        dm_minus = dm_minus.where((dm_minus > dm_plus) & (dm_minus > 0), 0)
        tr_sum = tr.rolling(window=self.period, min_periods=1).sum()
        dm_plus_sum = dm_plus.rolling(window=self.period, min_periods=1).sum()
        dm_minus_sum = dm_minus.rolling(window=self.period, min_periods=1).sum()
        di_plus = 100 * dm_plus_sum / tr_sum
        di_minus = 100 * dm_minus_sum / tr_sum
        dx = 100 * ((di_plus - di_minus).abs() / (di_plus + di_minus).replace(0, np.nan))
        dx = dx.fillna(0)
        adx = dx.rolling(window=self.period, min_periods=1).mean()
        self.adx = adx
        self.di_plus = di_plus
        self.di_minus = di_minus
        return adx

    def calculate_scores_threshold_strategy(self, df):
        if self.adx is None:
            self.compute_values(df)
        condition_strong = self.adx > self.adx_threshold
        score = pd.Series(0, index=df.index)
        score = score.where(~condition_strong, np.where(self.di_plus > self.di_minus, 1, np.where(self.di_minus > self.di_plus, -1, 0)))
        return score

    def threshold_map(self, series):
        mapping_value = {1: 'Strong_Trend_Bullish', -1: 'Strong_Trend_Bearish', 0: 'Weak_or_Indeterminate_Trend'}
        mapping_explanation = {
            1: f'ADX is above {self.adx_threshold} and DI+ is greater than DI-, indicating a strong bullish trend.',
            -1: f'ADX is above {self.adx_threshold} and DI- is greater than DI+, indicating a strong bearish trend.',
            0: f'ADX is below {self.adx_threshold} or DI values are equal, indicating a weak or indeterminate trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'ADX_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'ADX_Period:{self.period}_TA_Indicator_Value'] = self.adx
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ADX_Period:{self.period}_TA_Indicator_Value'] = self.adx
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_crossover_strategy(self, df):
        if self.di_plus is None or self.di_minus is None:
            self.compute_values(df)
        di_plus_prev = self.di_plus.shift(1)
        di_minus_prev = self.di_minus.shift(1)
        cond_bull = (di_plus_prev <= di_minus_prev) & (self.di_plus > self.di_minus)
        cond_bear = (di_plus_prev >= di_minus_prev) & (self.di_plus < self.di_minus)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def crossover_map(self, series):
        mapping_value = {1: 'DI+_Cross_Above_DI-', -1: 'DI+_Cross_Below_DI-', 0: 'No_Crossover'}
        mapping_explanation = {
            1: 'DI+ has crossed above DI-, suggesting a bullish shift in trend direction.',
            -1: 'DI+ has crossed below DI-, suggesting a bearish shift in trend direction.',
            0: 'No significant DI crossover detected, indicating neutral trend direction.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_crossover_strategy(df)
        value, explanation = self.crossover_map(score)
        column_prefix = f'ADX_Period:{self.period}_DI_Crossover_Signal'
        if append:
            if ta_indicator_value:
                df[f'ADX_Period:{self.period}_TA_Indicator_Value'] = self.adx
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ADX_Period:{self.period}_TA_Indicator_Value'] = self.adx
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.adx is None:
            self.compute_values(df)
        adx_diff = self.adx.diff()
        score = pd.Series(0, index=df.index)
        condition = self.adx > self.adx_threshold
        score = score.where(~condition, np.where(adx_diff > 0, 1, np.where(adx_diff < 0, -1, 0)))
        return score

    def slope_map(self, series):
        mapping_value = {1: 'ADX_Rising', -1: 'ADX_Falling', 0: 'ADX_Stable_or_Weak'}
        mapping_explanation = {
            1: f'ADX is above {self.adx_threshold} and rising, indicating strengthening trend conditions.',
            -1: f'ADX is above {self.adx_threshold} and falling, indicating weakening trend conditions.',
            0: f'ADX is either below {self.adx_threshold} or stable, indicating neutral trend strength.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'ADX_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'ADX_Period:{self.period}_TA_Indicator_Value'] = self.adx
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ADX_Period:{self.period}_TA_Indicator_Value'] = self.adx
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_threshold_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_crossover_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  



  




class AveragePriceStrategies:
    def __init__(self, threshold=1):
        self.threshold = threshold
        self.average_price = None

    def compute_values(self, df):
        self.average_price = (df['Open'] + df['High'] + df['Low'] + df['Close']) / 4
        return pd.Series(self.average_price, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if self.average_price is None:
            self.compute_values(df)
        diff = df['Close'] - self.average_price
        diff_prev = diff.shift(1)
        cond_bull = (diff_prev <= 0) & (diff > 0)
        cond_bear = (diff_prev >= 0) & (diff < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Price_Above_AvgPrice', -1: 'Price_Below_AvgPrice', 0: 'Price_Neutral'}
        mapping_explanation = {
            1: 'The closing price has crossed above the average price, suggesting bullish momentum.',
            -1: 'The closing price has crossed below the average price, suggesting bearish momentum.',
            0: 'No significant crossover between the closing price and the average price detected.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = 'AvgPrice_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df['AvgPrice_TA_Indicator_Value'] = self.average_price
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['AvgPrice_TA_Indicator_Value'] = self.average_price
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.average_price is None:
            self.compute_values(df)
        diff_pct = (df['Close'] - self.average_price) / self.average_price * 100
        cond_bull = diff_pct > self.threshold
        cond_bear = diff_pct < -self.threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Price_Above_Threshold', -1: 'Price_Below_Threshold', 0: 'Within_Threshold'}
        mapping_explanation = {
            1: f'The closing price is more than {self.threshold}% above the average price, indicating bullish conditions.',
            -1: f'The closing price is more than {self.threshold}% below the average price, indicating bearish conditions.',
            0: f'The closing price is within {self.threshold}% of the average price, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'AvgPrice_Threshold_{self.threshold}_Signal'
        if append:
            if ta_indicator_value:
                df['AvgPrice_TA_Indicator_Value'] = self.average_price
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['AvgPrice_TA_Indicator_Value'] = self.average_price
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.average_price is None:
            self.compute_values(df)
        slope = self.average_price.diff()
        signals = np.where(slope > 0, 1, np.where(slope < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'AvgPrice_Rising', -1: 'AvgPrice_Falling', 0: 'AvgPrice_Unchanged'}
        mapping_explanation = {
            1: 'The average price is rising, indicating bullish momentum.',
            -1: 'The average price is falling, indicating bearish momentum.',
            0: 'The average price is unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'AvgPrice_Slope_Signal'
        if append:
            if ta_indicator_value:
                df['AvgPrice_TA_Indicator_Value'] = self.average_price
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['AvgPrice_TA_Indicator_Value'] = self.average_price
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class AverageTrueRangeStrategies:
    def __init__(self, period=14, threshold=0.1):
        self.period = period
        self.threshold = threshold
        self.atr = None

    def compute_values(self, df):
        prev_close = df['Close'].shift(1)
        tr1 = df['High'] - df['Low']
        tr2 = abs(df['High'] - prev_close)
        tr3 = abs(df['Low'] - prev_close)
        true_range = np.maximum(np.maximum(tr1, tr2), tr3)
        atr = pd.Series(true_range).rolling(window=self.period, min_periods=self.period).mean()
        self.atr = pd.Series(atr, index=df.index)
        return self.atr

    def calculate_scores_zero_cross_strategy(self, df):
        if self.atr is None:
            self.compute_values(df)
        diff = df['Close'] - df['Close'].shift(1)
        cond_bull = diff > self.atr
        cond_bear = diff < -self.atr
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Price_Up_Breakout', -1: 'Price_Down_Breakout', 0: 'No_Breakout'}
        mapping_explanation = {
            1: 'The price increase exceeds the ATR, suggesting a bullish breakout.',
            -1: 'The price decrease exceeds the ATR, suggesting a bearish breakdown.',
            0: 'Price movement does not exceed the ATR, indicating no breakout.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'ATR_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'ATR_Period:{self.period}_TA_Indicator_Value'] = self.atr
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ATR_Period:{self.period}_TA_Indicator_Value'] = self.atr
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.atr is None:
            self.compute_values(df)
        atr_ma = self.atr.rolling(window=self.period, min_periods=self.period).mean()
        cond_bull = self.atr > atr_ma * (1 + self.threshold)
        cond_bear = self.atr < atr_ma * (1 - self.threshold)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'High_Volatility', -1: 'Low_Volatility', 0: 'Normal_Volatility'}
        mapping_explanation = {
            1: f'The ATR is more than {100 * self.threshold}% above its moving average, indicating high volatility and potential for breakouts.',
            -1: f'The ATR is more than {100 * self.threshold}% below its moving average, indicating low volatility and a consolidating market.',
            0: 'The ATR is near its moving average, indicating normal volatility conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'ATR_Period:{self.period}_Threshold:{self.threshold}_Signal'
        if append:
            if ta_indicator_value:
                df[f'ATR_Period:{self.period}_TA_Indicator_Value'] = self.atr
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ATR_Period:{self.period}_TA_Indicator_Value'] = self.atr
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.atr is None:
            self.compute_values(df)
        diff = self.atr.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'ATR_Rising', -1: 'ATR_Falling', 0: 'ATR_Unchanged'}
        mapping_explanation = {
            1: 'The ATR is rising, indicating increasing volatility.',
            -1: 'The ATR is falling, indicating decreasing volatility.',
            0: 'The ATR remains unchanged, indicating stable volatility.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'ATR_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'ATR_Period:{self.period}_TA_Indicator_Value'] = self.atr
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ATR_Period:{self.period}_TA_Indicator_Value'] = self.atr
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  

class AwesomeOscillatorStrategies:
    def __init__(self, short_period=5, long_period=34, threshold=0):
        self.short_period = short_period
        self.long_period = long_period
        self.threshold = threshold
        self.ao = None

    def compute_values(self, df):
        median_price = (df['High'] + df['Low']) / 2
        sma_short = pd.Series(median_price).rolling(window=self.short_period, min_periods=self.short_period).mean()
        sma_long = pd.Series(median_price).rolling(window=self.long_period, min_periods=self.long_period).mean()
        self.ao = pd.Series(sma_short - sma_long, index=df.index)
        return self.ao

    def calculate_scores_zero_cross_strategy(self, df):
        if self.ao is None:
            self.compute_values(df)
        ao_prev = self.ao.shift(1)
        cond_bull = (ao_prev <= 0) & (self.ao > 0)
        cond_bear = (ao_prev >= 0) & (self.ao < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'AO_Above_Zero', -1: 'AO_Below_Zero', 0: 'AO_Neutral'}
        mapping_explanation = {
            1: 'Awesome Oscillator crossed above zero, indicating bullish momentum.',
            -1: 'Awesome Oscillator crossed below zero, indicating bearish momentum.',
            0: 'No zero cross detected in Awesome Oscillator, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'AO_Short:{self.short_period}_Long:{self.long_period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'AO_Short:{self.short_period}_Long:{self.long_period}_TA_Indicator_Value'] = self.ao
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'AO_Short:{self.short_period}_Long:{self.long_period}_TA_Indicator_Value'] = self.ao
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.ao is None:
            self.compute_values(df)
        cond_bull = self.ao > self.threshold
        cond_bear = self.ao < -self.threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'AO_Above_Threshold', -1: 'AO_Below_Threshold', 0: 'AO_Within_Threshold'}
        mapping_explanation = {
            1: f'Awesome Oscillator is above the threshold of {self.threshold}, indicating strong bullish momentum.',
            -1: f'Awesome Oscillator is below the negative threshold of {-self.threshold}, indicating strong bearish momentum.',
            0: f'Awesome Oscillator is within the threshold range, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'AO_Short:{self.short_period}_Long:{self.long_period}_Threshold:{self.threshold}_Signal'
        if append:
            if ta_indicator_value:
                df[f'AO_Short:{self.short_period}_Long:{self.long_period}_TA_Indicator_Value'] = self.ao
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'AO_Short:{self.short_period}_Long:{self.long_period}_TA_Indicator_Value'] = self.ao
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.ao is None:
            self.compute_values(df)
        diff = self.ao.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'AO_Rising', -1: 'AO_Falling', 0: 'AO_Unchanged'}
        mapping_explanation = {
            1: 'Awesome Oscillator is rising, indicating increasing bullish momentum.',
            -1: 'Awesome Oscillator is falling, indicating increasing bearish momentum.',
            0: 'Awesome Oscillator is unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'AO_Short:{self.short_period}_Long:{self.long_period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'AO_Short:{self.short_period}_Long:{self.long_period}_TA_Indicator_Value'] = self.ao
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'AO_Short:{self.short_period}_Long:{self.long_period}_TA_Indicator_Value'] = self.ao
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class BalanceOfPowerStrategies:
    def __init__(self, threshold=0.5):
        self.threshold = threshold
        self.bop = None

    def compute_values(self, df):
        bop = (df['Close'] - df['Open']) / (df['High'] - df['Low'])
        bop = bop.replace([np.inf, -np.inf], 0).fillna(0)
        self.bop = pd.Series(bop, index=df.index)
        return self.bop

    def calculate_scores_zero_cross_strategy(self, df):
        if self.bop is None:
            self.compute_values(df)
        bop_prev = self.bop.shift(1)
        cond_bull = (bop_prev <= 0) & (self.bop > 0)
        cond_bear = (bop_prev >= 0) & (self.bop < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'BOP_Cross_Up', -1: 'BOP_Cross_Down', 0: 'BOP_Neutral'}
        mapping_explanation = {
            1: 'Balance of Power crossed above zero, indicating a shift towards bullish control.',
            -1: 'Balance of Power crossed below zero, indicating a shift towards bearish control.',
            0: 'Balance of Power remains neutral with no clear crossover signal.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = 'BOP_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df['BOP_TA_Indicator_Value'] = self.bop
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['BOP_TA_Indicator_Value'] = self.bop
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.bop is None:
            self.compute_values(df)
        cond_bull = self.bop > self.threshold
        cond_bear = self.bop < -self.threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'BOP_Above_Threshold', -1: 'BOP_Below_Threshold', 0: 'BOP_Within_Threshold'}
        mapping_explanation = {
            1: f'Balance of Power is above {self.threshold}, indicating strong bullish control.',
            -1: f'Balance of Power is below -{self.threshold}, indicating strong bearish control.',
            0: f'Balance of Power is within {self.threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'BOP_Threshold_{self.threshold}_Signal'
        if append:
            if ta_indicator_value:
                df['BOP_TA_Indicator_Value'] = self.bop
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['BOP_TA_Indicator_Value'] = self.bop
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.bop is None:
            self.compute_values(df)
        diff = self.bop.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'BOP_Rising', -1: 'BOP_Falling', 0: 'BOP_Unchanged'}
        mapping_explanation = {
            1: 'Balance of Power is rising, indicating increasing bullish pressure.',
            -1: 'Balance of Power is falling, indicating increasing bearish pressure.',
            0: 'Balance of Power remains unchanged, indicating no significant shift in power.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'BOP_Slope_Signal'
        if append:
            if ta_indicator_value:
                df['BOP_TA_Indicator_Value'] = self.bop
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['BOP_TA_Indicator_Value'] = self.bop
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class BetaStrategies:
    def __init__(self, period=30, baseline=1, lower_threshold=0.8, upper_threshold=1.2):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.beta = None

    def compute_values(self, df):
        asset_ret = df['Close'].pct_change()
        bench_ret = df['Benchmark'].pct_change()
        cov = asset_ret.rolling(window=self.period, min_periods=self.period).cov(bench_ret)
        var = bench_ret.rolling(window=self.period, min_periods=self.period).var()
        beta = cov / var
        beta = beta.replace([np.inf, -np.inf], 0).fillna(0)
        self.beta = pd.Series(beta, index=df.index)
        return self.beta

    def calculate_scores_zero_cross_strategy(self, df):
        if self.beta is None:
            self.compute_values(df)
        beta_prev = self.beta.shift(1)
        cond_bull = (beta_prev <= self.baseline) & (self.beta > self.baseline)
        cond_bear = (beta_prev >= self.baseline) & (self.beta < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Beta_Above_Baseline', -1: 'Beta_Below_Baseline', 0: 'Beta_Neutral'}
        mapping_explanation = {
            1: f'Beta crossed above the baseline of {self.baseline}, indicating increasing market sensitivity.',
            -1: f'Beta crossed below the baseline of {self.baseline}, indicating decreasing market sensitivity.',
            0: f'Beta remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'Beta_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'Beta_Period:{self.period}_TA_Indicator_Value'] = self.beta
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Beta_Period:{self.period}_TA_Indicator_Value'] = self.beta
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.beta is None:
            self.compute_values(df)
        cond_bull = self.beta < self.lower_threshold
        cond_bear = self.beta > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Beta_Low', -1: 'Beta_High', 0: 'Beta_Normal'}
        mapping_explanation = {
            1: f'Beta is below the lower threshold of {self.lower_threshold}, indicating lower volatility and market sensitivity.',
            -1: f'Beta is above the upper threshold of {self.upper_threshold}, indicating higher volatility and market sensitivity.',
            0: f'Beta is within the normal range between {self.lower_threshold} and {self.upper_threshold}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'Beta_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'Beta_Period:{self.period}_TA_Indicator_Value'] = self.beta
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Beta_Period:{self.period}_TA_Indicator_Value'] = self.beta
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.beta is None:
            self.compute_values(df)
        diff = self.beta.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Beta_Rising', -1: 'Beta_Falling', 0: 'Beta_Unchanged'}
        mapping_explanation = {
            1: 'Beta is rising, indicating increasing market sensitivity and potentially higher risk/reward.',
            -1: 'Beta is falling, indicating decreasing market sensitivity and potentially lower risk/reward.',
            0: 'Beta remains unchanged, indicating stable market sensitivity.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'Beta_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'Beta_Period:{self.period}_TA_Indicator_Value'] = self.beta
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Beta_Period:{self.period}_TA_Indicator_Value'] = self.beta
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class BiasStrategies:
    def __init__(self, period=14, threshold=5):
        self.period = period
        self.threshold = threshold
        self.bias = None

    def compute_values(self, df):
        ma = pd.Series(df['Close']).rolling(window=self.period, min_periods=self.period).mean()
        bias = (df['Close'] - ma) / ma * 100
        self.bias = pd.Series(bias, index=df.index)
        return self.bias

    def calculate_scores_zero_cross_strategy(self, df):
        if self.bias is None:
            self.compute_values(df)
        bias_prev = self.bias.shift(1)
        cond_bull = (bias_prev <= 0) & (self.bias > 0)
        cond_bear = (bias_prev >= 0) & (self.bias < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Bias_Above_Zero', -1: 'Bias_Below_Zero', 0: 'Bias_Neutral'}
        mapping_explanation = {
            1: 'Bias crossed above zero, indicating price above its moving average and bullish momentum.',
            -1: 'Bias crossed below zero, indicating price below its moving average and bearish momentum.',
            0: 'No significant zero cross detected in Bias indicator.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'Bias_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'Bias_Period:{self.period}_TA_Indicator_Value'] = self.bias
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Bias_Period:{self.period}_TA_Indicator_Value'] = self.bias
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.bias is None:
            self.compute_values(df)
        cond_bull = self.bias > self.threshold
        cond_bear = self.bias < -self.threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Bias_Above_Threshold', -1: 'Bias_Below_Threshold', 0: 'Bias_Within_Threshold'}
        mapping_explanation = {
            1: f'Bias is above {self.threshold}%, indicating strong bullish momentum.',
            -1: f'Bias is below -{self.threshold}%, indicating strong bearish momentum.',
            0: f'Bias is within {self.threshold}%, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'Bias_Period:{self.period}_Threshold:{self.threshold}_Signal'
        if append:
            if ta_indicator_value:
                df[f'Bias_Period:{self.period}_TA_Indicator_Value'] = self.bias
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Bias_Period:{self.period}_TA_Indicator_Value'] = self.bias
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.bias is None:
            self.compute_values(df)
        diff = self.bias.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Bias_Rising', -1: 'Bias_Falling', 0: 'Bias_Unchanged'}
        mapping_explanation = {
            1: 'Bias is rising, indicating increasing bullish momentum.',
            -1: 'Bias is falling, indicating increasing bearish momentum.',
            0: 'Bias remains unchanged, indicating stable market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'Bias_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'Bias_Period:{self.period}_TA_Indicator_Value'] = self.bias
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Bias_Period:{self.period}_TA_Indicator_Value'] = self.bias
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class BRARStrategies:
    def __init__(self, period=14, threshold=10, baseline=0):
        self.period = period
        self.threshold = threshold
        self.baseline = baseline
        self.ar = None
        self.br = None
        self.brar = None

    def compute_values(self, df):
        sum_high_open = pd.Series(df['High'] - df['Open']).rolling(window=self.period, min_periods=self.period).sum()
        sum_open_low = pd.Series(df['Open'] - df['Low']).rolling(window=self.period, min_periods=self.period).sum()
        self.ar = (sum_high_open / sum_open_low * 100).replace([np.inf, -np.inf], 0).fillna(0)
        sum_high_close = pd.Series(df['High'] - df['Close']).rolling(window=self.period, min_periods=self.period).sum()
        sum_close_low = pd.Series(df['Close'] - df['Low']).rolling(window=self.period, min_periods=self.period).sum()
        self.br = (sum_high_close / sum_close_low * 100).replace([np.inf, -np.inf], 0).fillna(0)
        self.brar = self.ar - self.br
        return self.brar

    def calculate_scores_zero_cross_strategy(self, df):
        if self.brar is None:
            self.compute_values(df)
        brar_prev = self.brar.shift(1)
        cond_bull = (brar_prev <= self.baseline) & (self.brar > self.baseline)
        cond_bear = (brar_prev >= self.baseline) & (self.brar < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'BRAR_Cross_Up', -1: 'BRAR_Cross_Down', 0: 'BRAR_Neutral'}
        mapping_explanation = {
            1: f'BRAR crossed above the baseline of {self.baseline}, indicating bullish momentum.',
            -1: f'BRAR crossed below the baseline of {self.baseline}, indicating bearish momentum.',
            0: f'BRAR remains around the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'BRAR_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'BRAR_Period:{self.period}_TA_Indicator_Value'] = self.brar
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'BRAR_Period:{self.period}_TA_Indicator_Value'] = self.brar
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.brar is None:
            self.compute_values(df)
        cond_bull = self.brar > self.threshold
        cond_bear = self.brar < -self.threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'BRAR_Above_Threshold', -1: 'BRAR_Below_Threshold', 0: 'BRAR_Within_Threshold'}
        mapping_explanation = {
            1: f'BRAR is above {self.threshold}, indicating strong bullish momentum.',
            -1: f'BRAR is below -{self.threshold}, indicating strong bearish momentum.',
            0: f'BRAR is within {self.threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'BRAR_Period:{self.period}_Threshold:{self.threshold}_Signal'
        if append:
            if ta_indicator_value:
                df[f'BRAR_Period:{self.period}_TA_Indicator_Value'] = self.brar
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'BRAR_Period:{self.period}_TA_Indicator_Value'] = self.brar
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.brar is None:
            self.compute_values(df)
        diff = self.brar.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'BRAR_Rising', -1: 'BRAR_Falling', 0: 'BRAR_Unchanged'}
        mapping_explanation = {
            1: 'BRAR is rising, indicating increasing bullish momentum.',
            -1: 'BRAR is falling, indicating increasing bearish momentum.',
            0: 'BRAR remains unchanged, indicating stable market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'BRAR_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'BRAR_Period:{self.period}_TA_Indicator_Value'] = self.brar
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'BRAR_Period:{self.period}_TA_Indicator_Value'] = self.brar
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class BollingerBandsStrategies:
    def __init__(self, period=20, multiplier=2, baseline=0.5, lower_threshold=0.2, upper_threshold=0.8):
        self.period = period
        self.multiplier = multiplier
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.percent_b = None

    def compute_values(self, df):
        ma = pd.Series(df['Close']).rolling(window=self.period, min_periods=self.period).mean()
        std = pd.Series(df['Close']).rolling(window=self.period, min_periods=self.period).std()
        upper_band = ma + self.multiplier * std
        lower_band = ma - self.multiplier * std
        percent_b = (df['Close'] - lower_band) / (upper_band - lower_band)
        self.percent_b = pd.Series(percent_b, index=df.index)
        return self.percent_b

    def calculate_scores_zero_cross_strategy(self, df):
        if self.percent_b is None:
            self.compute_values(df)
        percent_b_prev = self.percent_b.shift(1)
        cond_bull = (percent_b_prev <= self.baseline) & (self.percent_b > self.baseline)
        cond_bear = (percent_b_prev >= self.baseline) & (self.percent_b < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Price_Above_Middle_Band', -1: 'Price_Below_Middle_Band', 0: 'Price_Neutral'}
        mapping_explanation = {
            1: f'%B crossed above the baseline of {self.baseline}, indicating price moving into the upper half of the bands, potentially bullish.',
           -1: f'%B crossed below the baseline of {self.baseline}, indicating price moving into the lower half of the bands, potentially bearish.',
            0: f'%B remains around the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'BB_Period:{self.period}_Multiplier:{self.multiplier}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'BB_Period:{self.period}_TA_Indicator_Value'] = self.percent_b
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'BB_Period:{self.period}_TA_Indicator_Value'] = self.percent_b
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.percent_b is None:
            self.compute_values(df)
        cond_bull = self.percent_b < self.lower_threshold
        cond_bear = self.percent_b > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Oversold', -1: 'Overbought', 0: 'Within_Range'}
        mapping_explanation = {
            1: f'%B is below {self.lower_threshold}, indicating price is near or below the lower band (potential oversold condition, bullish reversal).',
           -1: f'%B is above {self.upper_threshold}, indicating price is near or above the upper band (potential overbought condition, bearish reversal).',
            0: f'%B is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'BB_Period:{self.period}_Multiplier:{self.multiplier}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'BB_Period:{self.period}_TA_Indicator_Value'] = self.percent_b
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'BB_Period:{self.period}_TA_Indicator_Value'] = self.percent_b
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.percent_b is None:
            self.compute_values(df)
        diff = self.percent_b.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'PercentB_Rising', -1: 'PercentB_Falling', 0: 'PercentB_Unchanged'}
        mapping_explanation = {
            1: 'The %B indicator is rising, indicating increasing momentum towards the upper band (bullish).',
           -1: 'The %B indicator is falling, indicating increasing momentum towards the lower band (bearish).',
            0: 'The %B indicator is unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'BB_Period:{self.period}_Multiplier:{self.multiplier}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'BB_Period:{self.period}_TA_Indicator_Value'] = self.percent_b
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'BB_Period:{self.period}_TA_Indicator_Value'] = self.percent_b
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class BollingerBandsWidthStrategies:
    def __init__(self, period=20, multiplier=2, baseline=0.05, lower_threshold=0.02, upper_threshold=0.1):
        self.period = period
        self.multiplier = multiplier
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.bb_width = None

    def compute_values(self, df):
        ma = pd.Series(df['Close']).rolling(window=self.period, min_periods=self.period).mean()
        std = pd.Series(df['Close']).rolling(window=self.period, min_periods=self.period).std()
        upper_band = ma + self.multiplier * std
        lower_band = ma - self.multiplier * std
        bb_width = (upper_band - lower_band) / ma
        self.bb_width = pd.Series(bb_width, index=df.index)
        return self.bb_width

    def calculate_scores_zero_cross_strategy(self, df):
        if self.bb_width is None:
            self.compute_values(df)
        bb_width_prev = self.bb_width.shift(1)
        cond_bull = (bb_width_prev <= self.baseline) & (self.bb_width > self.baseline)
        cond_bear = (bb_width_prev >= self.baseline) & (self.bb_width < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'BBWidth_Expanding', -1: 'BBWidth_Contracting', 0: 'BBWidth_Neutral'}
        mapping_explanation = {
            1: f'Bollinger Bands Width has crossed above the baseline of {self.baseline}, indicating an expansion in volatility and potential breakout conditions (bullish signal).',
           -1: f'Bollinger Bands Width has crossed below the baseline of {self.baseline}, indicating a contraction in volatility and a period of consolidation (bearish signal).',
            0: f'Bollinger Bands Width remains around the baseline of {self.baseline}, indicating stable volatility conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'BBWidth_Period:{self.period}_Multiplier:{self.multiplier}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'BBWidth_Period:{self.period}_TA_Indicator_Value'] = self.bb_width
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'BBWidth_Period:{self.period}_TA_Indicator_Value'] = self.bb_width
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.bb_width is None:
            self.compute_values(df)
        cond_bull = self.bb_width < self.lower_threshold
        cond_bear = self.bb_width > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'BBWidth_Squeeze', -1: 'BBWidth_Expansion', 0: 'BBWidth_Normal'}
        mapping_explanation = {
            1: f'Bollinger Bands Width is below {self.lower_threshold}, indicating a squeeze or low volatility environment, which may precede a breakout (bullish signal).',
           -1: f'Bollinger Bands Width is above {self.upper_threshold}, indicating high volatility and overextended market conditions, which can signal a potential reversal (bearish signal).',
            0: f'Bollinger Bands Width is between {self.lower_threshold} and {self.upper_threshold}, indicating normal volatility conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'BBWidth_Period:{self.period}_Multiplier:{self.multiplier}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'BBWidth_Period:{self.period}_TA_Indicator_Value'] = self.bb_width
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'BBWidth_Period:{self.period}_TA_Indicator_Value'] = self.bb_width
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.bb_width is None:
            self.compute_values(df)
        diff = self.bb_width.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'BBWidth_Rising', -1: 'BBWidth_Falling', 0: 'BBWidth_Unchanged'}
        mapping_explanation = {
            1: 'Bollinger Bands Width is rising, indicating increasing volatility and potential for a breakout (bullish signal).',
           -1: 'Bollinger Bands Width is falling, indicating decreasing volatility and a potential return to consolidation (bearish signal).',
            0: 'Bollinger Bands Width remains unchanged, indicating stable volatility conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'BBWidth_Period:{self.period}_Multiplier:{self.multiplier}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'BBWidth_Period:{self.period}_TA_Indicator_Value'] = self.bb_width
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'BBWidth_Period:{self.period}_TA_Indicator_Value'] = self.bb_width
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class BullBearPowerStrategies:
    def __init__(self, period=13, lower_threshold=-0.5, upper_threshold=0.5):
        self.period = period
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.bbp = None

    def compute_values(self, df):
        ema = pd.Series(df['Close']).ewm(span=self.period, adjust=False).mean()
        bull_power = df['High'] - ema
        bear_power = df['Low'] - ema
        self.bbp = pd.Series(bull_power + bear_power, index=df.index)
        return self.bbp

    def calculate_scores_zero_cross_strategy(self, df):
        if self.bbp is None:
            self.compute_values(df)
        bbp_prev = self.bbp.shift(1)
        cond_bull = (bbp_prev <= 0) & (self.bbp > 0)
        cond_bear = (bbp_prev >= 0) & (self.bbp < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'BBP_Above_Zero', -1: 'BBP_Below_Zero', 0: 'BBP_Neutral'}
        mapping_explanation = {
            1: 'BullBearPower crossed above zero, indicating that the combined bullish strength outweighs bearish pressure.',
           -1: 'BullBearPower crossed below zero, indicating that bearish pressure dominates bullish strength.',
            0: 'BullBearPower remains neutral around zero, indicating balanced market forces.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'BBP_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'BBP_Period:{self.period}_TA_Indicator_Value'] = self.bbp
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'BBP_Period:{self.period}_TA_Indicator_Value'] = self.bbp
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.bbp is None:
            self.compute_values(df)
        cond_bull = self.bbp > self.upper_threshold
        cond_bear = self.bbp < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'BBP_High', -1: 'BBP_Low', 0: 'BBP_Normal'}
        mapping_explanation = {
            1: f'BullBearPower is above {self.upper_threshold}, indicating strong bullish dominance.',
           -1: f'BullBearPower is below {self.lower_threshold}, indicating strong bearish dominance.',
            0: f'BullBearPower is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'BBP_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'BBP_Period:{self.period}_TA_Indicator_Value'] = self.bbp
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'BBP_Period:{self.period}_TA_Indicator_Value'] = self.bbp
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.bbp is None:
            self.compute_values(df)
        diff = self.bbp.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'BBP_Rising', -1: 'BBP_Falling', 0: 'BBP_Unchanged'}
        mapping_explanation = {
            1: 'BullBearPower is rising, indicating increasing bullish momentum.',
           -1: 'BullBearPower is falling, indicating increasing bearish momentum.',
            0: 'BullBearPower remains unchanged, indicating stable market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'BBP_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'BBP_Period:{self.period}_TA_Indicator_Value'] = self.bbp
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'BBP_Period:{self.period}_TA_Indicator_Value'] = self.bbp
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class BuyAndSellPressureStrategies:
    def __init__(self, period=14, baseline=0, upper_threshold=0.5, lower_threshold=-0.5):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold

    def compute_values(self, df):
        buy_pressure = np.where(df['Close'] > df['Open'], (df['Close'] - df['Open']) * df['Volume'], 0)
        sell_pressure = np.where(df['Close'] < df['Open'], (df['Open'] - df['Close']) * df['Volume'], 0)
        buy_pressure_sum = pd.Series(buy_pressure).rolling(window=self.period, min_periods=1).sum()
        sell_pressure_sum = pd.Series(sell_pressure).rolling(window=self.period, min_periods=1).sum()
        bsp = np.where((buy_pressure_sum + sell_pressure_sum) == 0, 0, (buy_pressure_sum - sell_pressure_sum) / (buy_pressure_sum + sell_pressure_sum))
        return pd.Series(bsp, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'bsp') or self.bsp is None:
            self.bsp = self.compute_values(df)
        bsp_prev = self.bsp.shift(1)
        cond_bull = (bsp_prev <= self.baseline) & (self.bsp > self.baseline)
        cond_bear = (bsp_prev >= self.baseline) & (self.bsp < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'BSP_Above_Baseline', -1: 'BSP_Below_Baseline', 0: 'BSP_Neutral'}
        mapping_explanation = {
            1: f'BSP crossed above the baseline of {self.baseline}, indicating bullish pressure.',
            -1: f'BSP crossed below the baseline of {self.baseline}, indicating bearish pressure.',
            0: f'BSP remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'BSP_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'BSP_Period:{self.period}_TA_Indicator_Value'] = self.bsp
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'BSP_Period:{self.period}_TA_Indicator_Value'] = self.bsp
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'bsp') or self.bsp is None:
            self.bsp = self.compute_values(df)
        cond_bull = self.bsp < self.lower_threshold
        cond_bear = self.bsp > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'BSP_Oversold', -1: 'BSP_Overbought', 0: 'BSP_Neutral'}
        mapping_explanation = {
            1: f'BSP is below the lower threshold of {self.lower_threshold}, indicating oversold conditions and potential bullish reversal.',
            -1: f'BSP is above the upper threshold of {self.upper_threshold}, indicating overbought conditions and potential bearish reversal.',
            0: 'BSP is within normal range, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'BSP_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'BSP_Period:{self.period}_TA_Indicator_Value'] = self.bsp
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'BSP_Period:{self.period}_TA_Indicator_Value'] = self.bsp
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'bsp') or self.bsp is None:
            self.bsp = self.compute_values(df)
        diff = self.bsp.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'BSP_Rising', -1: 'BSP_Falling', 0: 'BSP_Unchanged'}
        mapping_explanation = {
            1: 'BSP is rising, indicating increasing bullish pressure.',
            -1: 'BSP is falling, indicating increasing bearish pressure.',
            0: 'BSP remains unchanged, indicating neutral pressure.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'BSP_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'BSP_Period:{self.period}_TA_Indicator_Value'] = self.bsp
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'BSP_Period:{self.period}_TA_Indicator_Value'] = self.bsp
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  

class CenterOfGravityStrategies:
    def __init__(self, period=14, baseline=0, lower_threshold=-0.5, upper_threshold=0.5):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold

    def compute_values(self, df):
        def cog_calc(x):
            weights = np.arange(1, len(x) + 1)
            return -np.dot(weights, x) / np.sum(x)
        self.cog = df['Close'].rolling(window=self.period, min_periods=self.period).apply(cog_calc, raw=True)
        return pd.Series(self.cog, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'cog') or self.cog is None:
            self.cog = self.compute_values(df)
        diff = df['Close'] - self.cog
        diff_prev = diff.shift(1)
        cond_bull = (diff_prev <= self.baseline) & (diff > self.baseline)
        cond_bear = (diff_prev >= self.baseline) & (diff < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Price_Above_COG', -1: 'Price_Below_COG', 0: 'Price_Near_COG'}
        mapping_explanation = {
            1: f'Price crossed above the Center of Gravity, suggesting bullish conditions.',
            -1: f'Price crossed below the Center of Gravity, suggesting bearish conditions.',
            0: f'Price remains near the Center of Gravity, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'COG_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'COG_Period:{self.period}_TA_Indicator_Value'] = self.cog
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'COG_Period:{self.period}_TA_Indicator_Value'] = self.cog
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'cog') or self.cog is None:
            self.cog = self.compute_values(df)
        diff = df['Close'] - self.cog
        cond_bull = diff > self.upper_threshold
        cond_bear = diff < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Significantly_Above_COG', -1: 'Significantly_Below_COG', 0: 'Near_COG'}
        mapping_explanation = {
            1: f'Price is significantly above the Center of Gravity, indicating strong bullish momentum.',
            -1: f'Price is significantly below the Center of Gravity, indicating strong bearish momentum.',
            0: f'Price is close to the Center of Gravity, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'COG_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'COG_Period:{self.period}_TA_Indicator_Value'] = self.cog
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'COG_Period:{self.period}_TA_Indicator_Value'] = self.cog
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'cog') or self.cog is None:
            self.cog = self.compute_values(df)
        slope = self.cog.diff()
        signals = np.where(slope > 0, 1, np.where(slope < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'COG_Rising', -1: 'COG_Falling', 0: 'COG_Unchanged'}
        mapping_explanation = {
            1: 'The Center of Gravity is rising, indicating potential bullish momentum.',
            -1: 'The Center of Gravity is falling, indicating potential bearish momentum.',
            0: 'The Center of Gravity is unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'COG_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'COG_Period:{self.period}_TA_Indicator_Value'] = self.cog
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'COG_Period:{self.period}_TA_Indicator_Value'] = self.cog
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        # df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        # df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        # return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
        return pd.concat([df_copy_3], axis=1)







  
class ChandeForecastOscillatorStrategies:
    def __init__(self, period=14, upper_threshold=5, lower_threshold=-5):
        self.period = period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.cfo = None

    def compute_values(self, df):
        def calc_cfo(x):
            n = len(x)
            indices = np.arange(1, n + 1)
            sum_x = indices.sum()
            sum_x2 = (indices ** 2).sum()
            sum_y = x.sum()
            sum_xy = (indices * x).sum()
            denom = (n * sum_x2 - sum_x ** 2)
            slope = (n * sum_xy - sum_x * sum_y) / denom if denom != 0 else 0
            intercept = (sum_y - slope * sum_x) / n
            forecast = slope * (n + 1) + intercept
            price = x[-1]
            return 100 * (price - forecast) / price if price != 0 else 0
        cfo = df['Close'].rolling(window=self.period, min_periods=1).apply(calc_cfo, raw=True)
        return pd.Series(cfo, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'cfo') or self.cfo is None:
            self.cfo = self.compute_values(df)
        cfo_prev = self.cfo.shift(1)
        cond_bull = (cfo_prev <= 0) & (self.cfo > 0)
        cond_bear = (cfo_prev >= 0) & (self.cfo < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'CFO_Above_Baseline', -1: 'CFO_Below_Baseline', 0: 'CFO_Neutral'}
        mapping_explanation = {
            1: 'CFO crossed above zero, indicating bullish conditions.',
            -1: 'CFO crossed below zero, indicating bearish conditions.',
            0: 'CFO remains neutral around zero.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'CFO_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'CFO_Period:{self.period}_TA_Indicator_Value'] = self.cfo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CFO_Period:{self.period}_TA_Indicator_Value'] = self.cfo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'cfo') or self.cfo is None:
            self.cfo = self.compute_values(df)
        cond_bull = self.cfo < self.lower_threshold
        cond_bear = self.cfo > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'CFO_Oversold', -1: 'CFO_Overbought', 0: 'CFO_Neutral'}
        mapping_explanation = {
            1: f'CFO is below the lower threshold of {self.lower_threshold}, indicating oversold conditions and potential bullish reversal.',
            -1: f'CFO is above the upper threshold of {self.upper_threshold}, indicating overbought conditions and potential bearish reversal.',
            0: 'CFO is within the normal range, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'CFO_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'CFO_Period:{self.period}_TA_Indicator_Value'] = self.cfo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CFO_Period:{self.period}_TA_Indicator_Value'] = self.cfo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'cfo') or self.cfo is None:
            self.cfo = self.compute_values(df)
        diff = self.cfo.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'CFO_Rising', -1: 'CFO_Falling', 0: 'CFO_Unchanged'}
        mapping_explanation = {
            1: 'CFO is rising, indicating increasing bullish momentum.',
            -1: 'CFO is falling, indicating increasing bearish momentum.',
            0: 'CFO remains unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'CFO_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'CFO_Period:{self.period}_TA_Indicator_Value'] = self.cfo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CFO_Period:{self.period}_TA_Indicator_Value'] = self.cfo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class ChandeKrollStopStrategies:
    def __init__(self, period=14, multiplier=2.0, upper_threshold=0.5, lower_threshold=-0.5):
        self.period = period
        self.multiplier = multiplier
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.cks = None

    def compute_values(self, df):
        prev_close = df['Close'].shift(1)
        tr = pd.concat([df['High'] - df['Low'], (df['High'] - prev_close).abs(), (df['Low'] - prev_close).abs()], axis=1).max(axis=1)
        atr = tr.rolling(window=self.period, min_periods=1).mean()
        long_candidate = df['High'].rolling(window=self.period, min_periods=1).max() - self.multiplier * atr
        short_candidate = df['Low'].rolling(window=self.period, min_periods=1).min() + self.multiplier * atr
        cks_values = np.zeros(len(df))
        for i in range(len(df)):
            if i == 0:
                mid = (long_candidate.iloc[i] + short_candidate.iloc[i]) / 2
                cks_values[i] = long_candidate.iloc[i] if df['Close'].iloc[i] >= mid else short_candidate.iloc[i]
            else:
                if df['Close'].iloc[i-1] > cks_values[i-1]:
                    cks_values[i] = max(long_candidate.iloc[i], cks_values[i-1])
                elif df['Close'].iloc[i-1] < cks_values[i-1]:
                    cks_values[i] = min(short_candidate.iloc[i], cks_values[i-1])
                else:
                    cks_values[i] = cks_values[i-1]
        return pd.Series(cks_values, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'cks') or self.cks is None:
            self.cks = self.compute_values(df)
        prev_close = df['Close'].shift(1)
        prev_cks = self.cks.shift(1)
        cond_bull = (prev_close <= prev_cks) & (df['Close'] > self.cks)
        cond_bear = (prev_close >= prev_cks) & (df['Close'] < self.cks)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'CKS_Bullish_Cross', -1: 'CKS_Bearish_Cross', 0: 'CKS_Neutral'}
        mapping_explanation = {
            1: 'Price crossed above the Chande Kroll Stop, indicating a bullish reversal.',
            -1: 'Price crossed below the Chande Kroll Stop, indicating a bearish reversal.',
            0: 'No significant cross between price and the Chande Kroll Stop.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'CKS_Period:{self.period}_Multiplier:{self.multiplier}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'CKS_Period:{self.period}_TA_Indicator_Value'] = self.cks
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CKS_Period:{self.period}_TA_Indicator_Value'] = self.cks
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'cks') or self.cks is None:
            self.cks = self.compute_values(df)
        diff = df['Close'] - self.cks
        signals = np.where(diff > self.upper_threshold, 1, np.where(diff < self.lower_threshold, -1, 0))
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'CKS_Strong_Bullish', -1: 'CKS_Strong_Bearish', 0: 'CKS_Neutral'}
        mapping_explanation = {
            1: f'Price is significantly above the Chande Kroll Stop by more than {self.upper_threshold}, indicating strong bullish momentum.',
            -1: f'Price is significantly below the Chande Kroll Stop by more than {abs(self.lower_threshold)}, indicating strong bearish momentum.',
            0: 'Price is close to the Chande Kroll Stop, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'CKS_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'CKS_Period:{self.period}_TA_Indicator_Value'] = self.cks
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CKS_Period:{self.period}_TA_Indicator_Value'] = self.cks
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'cks') or self.cks is None:
            self.cks = self.compute_values(df)
        diff = self.cks.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'CKS_Rising', -1: 'CKS_Falling', 0: 'CKS_Unchanged'}
        mapping_explanation = {
            1: 'Chande Kroll Stop is rising, indicating a potential bullish trend.',
            -1: 'Chande Kroll Stop is falling, indicating a potential bearish trend.',
            0: 'Chande Kroll Stop remains unchanged, indicating a neutral trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'CKS_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'CKS_Period:{self.period}_TA_Indicator_Value'] = self.cks
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CKS_Period:{self.period}_TA_Indicator_Value'] = self.cks
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class ChandeMomentumOscillatorStrategies:
    def __init__(self, period=14, upper_threshold=50, lower_threshold=-50):
        self.period = period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.cmo = None

    def compute_values(self, df):
        diff = df['Close'].diff()
        pos = np.where(diff > 0, diff, 0)
        neg = np.where(diff < 0, abs(diff), 0)
        pos_sum = pd.Series(pos).rolling(window=self.period, min_periods=1).sum()
        neg_sum = pd.Series(neg).rolling(window=self.period, min_periods=1).sum()
        denom = pos_sum + neg_sum
        cmo_values = np.where(denom == 0, 0, 100 * (pos_sum - neg_sum) / denom)
        return pd.Series(cmo_values, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'cmo') or self.cmo is None:
            self.cmo = self.compute_values(df)
        cmo_prev = self.cmo.shift(1)
        cond_bull = (cmo_prev <= 0) & (self.cmo > 0)
        cond_bear = (cmo_prev >= 0) & (self.cmo < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'CMO_Above_Zero', -1: 'CMO_Below_Zero', 0: 'CMO_Neutral'}
        mapping_explanation = {
            1: 'CMO crossed above zero, indicating bullish momentum.',
            -1: 'CMO crossed below zero, indicating bearish momentum.',
            0: 'CMO remains neutral around zero.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'CMO_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'CMO_Period:{self.period}_TA_Indicator_Value'] = self.cmo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CMO_Period:{self.period}_TA_Indicator_Value'] = self.cmo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'cmo') or self.cmo is None:
            self.cmo = self.compute_values(df)
        cond_bull = self.cmo < self.lower_threshold
        cond_bear = self.cmo > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'CMO_Oversold', -1: 'CMO_Overbought', 0: 'CMO_Neutral'}
        mapping_explanation = {
            1: f'CMO is below {self.lower_threshold}, indicating oversold conditions and potential bullish reversal.',
            -1: f'CMO is above {self.upper_threshold}, indicating overbought conditions and potential bearish reversal.',
            0: 'CMO is within normal range, indicating balanced momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'CMO_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'CMO_Period:{self.period}_TA_Indicator_Value'] = self.cmo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CMO_Period:{self.period}_TA_Indicator_Value'] = self.cmo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'cmo') or self.cmo is None:
            self.cmo = self.compute_values(df)
        diff = self.cmo.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'CMO_Rising', -1: 'CMO_Falling', 0: 'CMO_Unchanged'}
        mapping_explanation = {
            1: 'CMO is rising, indicating increasing bullish momentum.',
            -1: 'CMO is falling, indicating increasing bearish momentum.',
            0: 'CMO remains unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'CMO_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'CMO_Period:{self.period}_TA_Indicator_Value'] = self.cmo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CMO_Period:{self.period}_TA_Indicator_Value'] = self.cmo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class ChandelierExitStrategies:
    def __init__(self, period=22, multiplier=3.0, upper_threshold=3.0, lower_threshold=1.0):
        self.period = period
        self.multiplier = multiplier
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.ce = None

    def compute_values(self, df):
        prev_close = df['Close'].shift(1)
        tr = pd.concat([df['High'] - df['Low'], (df['High'] - prev_close).abs(), (df['Low'] - prev_close).abs()], axis=1).max(axis=1)
        atr = tr.rolling(window=self.period, min_periods=1).mean()
        highest_high = df['High'].rolling(window=self.period, min_periods=1).max()
        ce = highest_high - self.multiplier * atr
        return pd.Series(ce, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'ce') or self.ce is None:
            self.ce = self.compute_values(df)
        prev_close = df['Close'].shift(1)
        prev_ce = self.ce.shift(1)
        cond_bull = (prev_close <= prev_ce) & (df['Close'] > self.ce)
        cond_bear = (prev_close >= prev_ce) & (df['Close'] < self.ce)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'ChandelierExit_Bullish_Cross', -1: 'ChandelierExit_Bearish_Cross', 0: 'ChandelierExit_Neutral'}
        mapping_explanation = {
            1: 'Price crossed above the Chandelier Exit level, indicating a potential bullish trend continuation.',
            -1: 'Price crossed below the Chandelier Exit level, indicating a potential bearish reversal or exit signal.',
            0: 'No significant cross between price and the Chandelier Exit level.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'ChandelierExit_Period:{self.period}_Multiplier:{self.multiplier}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'ChandelierExit_Period:{self.period}_TA_Indicator_Value'] = self.ce
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ChandelierExit_Period:{self.period}_TA_Indicator_Value'] = self.ce
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'ce') or self.ce is None:
            self.ce = self.compute_values(df)
        diff = df['Close'] - self.ce
        cond_bull = diff > self.upper_threshold
        cond_bear = diff < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'ChandelierExit_Strong_Bullish', -1: 'ChandelierExit_Strong_Bearish', 0: 'ChandelierExit_Neutral'}
        mapping_explanation = {
            1: f'Price is comfortably above the Chandelier Exit by more than {self.upper_threshold}, indicating strong bullish momentum.',
            -1: f'Price is close to or below the Chandelier Exit by more than {self.lower_threshold}, indicating a potential bearish reversal or exit signal.',
            0: 'Price is within a moderate range of the Chandelier Exit, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'ChandelierExit_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'ChandelierExit_Period:{self.period}_TA_Indicator_Value'] = self.ce
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ChandelierExit_Period:{self.period}_TA_Indicator_Value'] = self.ce
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'ce') or self.ce is None:
            self.ce = self.compute_values(df)
        diff = self.ce.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'ChandelierExit_Rising', -1: 'ChandelierExit_Falling', 0: 'ChandelierExit_Unchanged'}
        mapping_explanation = {
            1: 'The Chandelier Exit is rising, indicating that the trailing stop is moving upward, which is favorable in an uptrend.',
            -1: 'The Chandelier Exit is falling, indicating that the trailing stop is moving downward, which could be a warning sign in an uptrend.',
            0: 'The Chandelier Exit remains unchanged, indicating stable conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'ChandelierExit_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'ChandelierExit_Period:{self.period}_TA_Indicator_Value'] = self.ce
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ChandelierExit_Period:{self.period}_TA_Indicator_Value'] = self.ce
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class ChaikinADLineStrategies:
    def __init__(self, upper_threshold=0, lower_threshold=0):
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.ad = None

    def compute_values(self, df):
        mfm = np.where(df['High'] == df['Low'], 0, ((df['Close'] - df['Low']) - (df['High'] - df['Close'])) / (df['High'] - df['Low']))
        mfv = mfm * df['Volume']
        ad_line = np.cumsum(mfv)
        return pd.Series(ad_line, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'ad') or self.ad is None:
            self.ad = self.compute_values(df)
        ad_prev = self.ad.shift(1)
        cond_bull = (ad_prev <= 0) & (self.ad > 0)
        cond_bear = (ad_prev >= 0) & (self.ad < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'ChaikinAD_Accumulation', -1: 'ChaikinAD_Distribution', 0: 'ChaikinAD_Neutral'}
        mapping_explanation = {
            1: 'Chaikin A/D line crossed above zero, indicating net accumulation and bullish conditions.',
            -1: 'Chaikin A/D line crossed below zero, indicating net distribution and bearish conditions.',
            0: 'Chaikin A/D line remains around zero, indicating neutral money flow.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = 'ChaikinAD_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df['ChaikinAD_TA_Indicator_Value'] = self.ad
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['ChaikinAD_TA_Indicator_Value'] = self.ad
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'ad') or self.ad is None:
            self.ad = self.compute_values(df)
        signals = np.select([self.ad > self.upper_threshold, self.ad < self.lower_threshold], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'ChaikinAD_Strong_Accumulation', -1: 'ChaikinAD_Strong_Distribution', 0: 'ChaikinAD_Neutral'}
        mapping_explanation = {
            1: f'Chaikin A/D line is above {self.upper_threshold}, indicating strong accumulation and bullish sentiment.',
            -1: f'Chaikin A/D line is below {self.lower_threshold}, indicating strong distribution and bearish sentiment.',
            0: f'Chaikin A/D line is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced money flow.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'ChaikinAD_Upper:{self.upper_threshold}_Lower:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df['ChaikinAD_TA_Indicator_Value'] = self.ad
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['ChaikinAD_TA_Indicator_Value'] = self.ad
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'ad') or self.ad is None:
            self.ad = self.compute_values(df)
        diff = self.ad.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'ChaikinAD_Rising', -1: 'ChaikinAD_Falling', 0: 'ChaikinAD_Unchanged'}
        mapping_explanation = {
            1: 'Chaikin A/D line is rising, indicating increasing accumulation and bullish momentum.',
            -1: 'Chaikin A/D line is falling, indicating increasing distribution and bearish momentum.',
            0: 'Chaikin A/D line remains unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'ChaikinAD_Slope_Signal'
        if append:
            if ta_indicator_value:
                df['ChaikinAD_TA_Indicator_Value'] = self.ad
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['ChaikinAD_TA_Indicator_Value'] = self.ad
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class ChaikinADOscillatorStrategies:
    def __init__(self, short_period=3, long_period=10, upper_threshold=0.5, lower_threshold=-0.5):
        self.short_period = short_period
        self.long_period = long_period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.cao = None

    def compute_values(self, df):
        mfm = np.where(df['High'] == df['Low'], 0, ((df['Close'] - df['Low']) - (df['High'] - df['Close'])) / (df['High'] - df['Low']))
        mfv = mfm * df['Volume']
        ad_line = np.cumsum(mfv)
        short_ema = pd.Series(ad_line, index=df.index).ewm(span=self.short_period, adjust=False).mean()
        long_ema = pd.Series(ad_line, index=df.index).ewm(span=self.long_period, adjust=False).mean()
        cao = short_ema - long_ema
        return pd.Series(cao, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'cao') or self.cao is None:
            self.cao = self.compute_values(df)
        cao_prev = self.cao.shift(1)
        cond_bull = (cao_prev <= 0) & (self.cao > 0)
        cond_bear = (cao_prev >= 0) & (self.cao < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'CAO_Above_Zero', -1: 'CAO_Below_Zero', 0: 'CAO_Neutral'}
        mapping_explanation = {
            1: 'Chaikin A/D Oscillator crossed above zero, indicating bullish momentum.',
            -1: 'Chaikin A/D Oscillator crossed below zero, indicating bearish momentum.',
            0: 'Chaikin A/D Oscillator remains neutral around zero.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'CAO_Short:{self.short_period}_Long:{self.long_period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'CAO_TA_Indicator_Value'] = self.cao
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CAO_TA_Indicator_Value'] = self.cao
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'cao') or self.cao is None:
            self.cao = self.compute_values(df)
        cond_bull = self.cao > self.upper_threshold
        cond_bear = self.cao < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'CAO_Strong_Bullish', -1: 'CAO_Strong_Bearish', 0: 'CAO_Neutral'}
        mapping_explanation = {
            1: f'Chaikin A/D Oscillator is above {self.upper_threshold}, indicating strong bullish momentum.',
            -1: f'Chaikin A/D Oscillator is below {self.lower_threshold}, indicating strong bearish momentum.',
            0: 'Chaikin A/D Oscillator is within the neutral range, indicating balanced market pressure.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'CAO_Short:{self.short_period}_Long:{self.long_period}_Upper:{self.upper_threshold}_Lower:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'CAO_TA_Indicator_Value'] = self.cao
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CAO_TA_Indicator_Value'] = self.cao
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'cao') or self.cao is None:
            self.cao = self.compute_values(df)
        diff = self.cao.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'CAO_Rising', -1: 'CAO_Falling', 0: 'CAO_Unchanged'}
        mapping_explanation = {
            1: 'Chaikin A/D Oscillator is rising, indicating increasing bullish momentum.',
            -1: 'Chaikin A/D Oscillator is falling, indicating increasing bearish momentum.',
            0: 'Chaikin A/D Oscillator remains unchanged, indicating neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'CAO_Short:{self.short_period}_Long:{self.long_period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'CAO_TA_Indicator_Value'] = self.cao
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CAO_TA_Indicator_Value'] = self.cao
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class ChaikinMoneyFlowStrategies:
    def __init__(self, period=20, upper_threshold=0.1, lower_threshold=-0.1):
        self.period = period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.cmf = None

    def compute_values(self, df):
        mfm = np.where(df['High'] == df['Low'], 0, ((df['Close'] - df['Low']) - (df['High'] - df['Close'])) / (df['High'] - df['Low']))
        mfv = mfm * df['Volume']
        cmf = pd.Series(mfv, index=df.index).rolling(window=self.period, min_periods=1).sum() / df['Volume'].rolling(window=self.period, min_periods=1).sum()
        return pd.Series(cmf, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'cmf') or self.cmf is None:
            self.cmf = self.compute_values(df)
        cmf_prev = self.cmf.shift(1)
        cond_bull = (cmf_prev <= 0) & (self.cmf > 0)
        cond_bear = (cmf_prev >= 0) & (self.cmf < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'CMF_Above_Zero', -1: 'CMF_Below_Zero', 0: 'CMF_Neutral'}
        mapping_explanation = {
            1: 'CMF crossed above zero, indicating net buying pressure and bullish conditions.',
            -1: 'CMF crossed below zero, indicating net selling pressure and bearish conditions.',
            0: 'CMF remains neutral around zero, indicating balanced money flow.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'CMF_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'CMF_Period:{self.period}_TA_Indicator_Value'] = self.cmf
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CMF_Period:{self.period}_TA_Indicator_Value'] = self.cmf
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'cmf') or self.cmf is None:
            self.cmf = self.compute_values(df)
        cond_bull = self.cmf > self.upper_threshold
        cond_bear = self.cmf < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'CMF_Strong_Bullish', -1: 'CMF_Strong_Bearish', 0: 'CMF_Neutral'}
        mapping_explanation = {
            1: f'CMF is above {self.upper_threshold}, indicating strong buying pressure.',
            -1: f'CMF is below {self.lower_threshold}, indicating strong selling pressure.',
            0: f'CMF is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced money flow.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'CMF_Period:{self.period}_Upper:{self.upper_threshold}_Lower:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'CMF_Period:{self.period}_TA_Indicator_Value'] = self.cmf
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CMF_Period:{self.period}_TA_Indicator_Value'] = self.cmf
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'cmf') or self.cmf is None:
            self.cmf = self.compute_values(df)
        diff = self.cmf.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'CMF_Rising', -1: 'CMF_Falling', 0: 'CMF_Unchanged'}
        mapping_explanation = {
            1: 'CMF is rising, indicating increasing buying pressure.',
            -1: 'CMF is falling, indicating increasing selling pressure.',
            0: 'CMF remains unchanged, indicating neutral money flow.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'CMF_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'CMF_Period:{self.period}_TA_Indicator_Value'] = self.cmf
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CMF_Period:{self.period}_TA_Indicator_Value'] = self.cmf
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class ChaikinOscillatorStrategies:
    def __init__(self, short_period=3, long_period=10, upper_threshold=0.5, lower_threshold=-0.5):
        self.short_period = short_period
        self.long_period = long_period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.co = None

    def compute_values(self, df):
        mfm = np.where(df['High'] == df['Low'], 0, ((df['Close'] - df['Low']) - (df['High'] - df['Close'])) / (df['High'] - df['Low']))
        mfv = mfm * df['Volume']
        ad_line = np.cumsum(mfv)
        short_ema = pd.Series(ad_line, index=df.index).ewm(span=self.short_period, adjust=False).mean()
        long_ema = pd.Series(ad_line, index=df.index).ewm(span=self.long_period, adjust=False).mean()
        co = short_ema - long_ema
        return pd.Series(co, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'co') or self.co is None:
            self.co = self.compute_values(df)
        co_prev = self.co.shift(1)
        cond_bull = (co_prev <= 0) & (self.co > 0)
        cond_bear = (co_prev >= 0) & (self.co < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'CO_Above_Zero', -1: 'CO_Below_Zero', 0: 'CO_Neutral'}
        mapping_explanation = {
            1: 'Chaikin Oscillator crossed above zero, indicating increasing buying pressure.',
            -1: 'Chaikin Oscillator crossed below zero, indicating increasing selling pressure.',
            0: 'Chaikin Oscillator remains neutral around zero.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'CO_Short:{self.short_period}_Long:{self.long_period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'CO_Short:{self.short_period}_Long:{self.long_period}_TA_Indicator_Value'] = self.co
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CO_Short:{self.short_period}_Long:{self.long_period}_TA_Indicator_Value'] = self.co
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'co') or self.co is None:
            self.co = self.compute_values(df)
        cond_bull = self.co > self.upper_threshold
        cond_bear = self.co < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'CO_Strong_Bullish', -1: 'CO_Strong_Bearish', 0: 'CO_Neutral'}
        mapping_explanation = {
            1: f'Chaikin Oscillator is above {self.upper_threshold}, indicating strong bullish momentum.',
            -1: f'Chaikin Oscillator is below {self.lower_threshold}, indicating strong bearish momentum.',
            0: f'Chaikin Oscillator is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'CO_Short:{self.short_period}_Long:{self.long_period}_Upper:{self.upper_threshold}_Lower:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'CO_Short:{self.short_period}_Long:{self.long_period}_TA_Indicator_Value'] = self.co
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CO_Short:{self.short_period}_Long:{self.long_period}_TA_Indicator_Value'] = self.co
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'co') or self.co is None:
            self.co = self.compute_values(df)
        diff = self.co.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'CO_Rising', -1: 'CO_Falling', 0: 'CO_Unchanged'}
        mapping_explanation = {
            1: 'Chaikin Oscillator is rising, indicating increasing bullish momentum.',
            -1: 'Chaikin Oscillator is falling, indicating increasing bearish momentum.',
            0: 'Chaikin Oscillator remains unchanged, indicating neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'CO_Short:{self.short_period}_Long:{self.long_period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'CO_Short:{self.short_period}_Long:{self.long_period}_TA_Indicator_Value'] = self.co
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CO_Short:{self.short_period}_Long:{self.long_period}_TA_Indicator_Value'] = self.co
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class ChoppinessIndexStrategies:
    def __init__(self, period=14, baseline=50, upper_threshold=61, lower_threshold=38):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.chop = None

    def compute_values(self, df):
        prev_close = df['Close'].shift(1)
        tr = pd.concat([df['High'] - df['Low'], (df['High'] - prev_close).abs(), (df['Low'] - prev_close).abs()], axis=1).max(axis=1)
        sum_tr = pd.Series(tr).rolling(window=self.period, min_periods=1).sum()
        highest_high = df['High'].rolling(window=self.period, min_periods=1).max()
        lowest_low = df['Low'].rolling(window=self.period, min_periods=1).min()
        range_val = highest_high - lowest_low
        ratio = np.where(range_val == 0, np.nan, sum_tr / range_val)
        chop = 100 * np.log10(ratio) / np.log10(self.period)
        chop = np.where(np.isnan(chop), 0, chop)
        return pd.Series(chop, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'chop') or self.chop is None:
            self.chop = self.compute_values(df)
        chop_prev = self.chop.shift(1)
        cond_bull = (chop_prev >= self.baseline) & (self.chop < self.baseline)
        cond_bear = (chop_prev <= self.baseline) & (self.chop > self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'CHOP_Trending', -1: 'CHOP_Choppy', 0: 'CHOP_Neutral'}
        mapping_explanation = {
            1: f'Choppiness Index crossed below the baseline of {self.baseline}, indicating a transition to trending conditions.',
            -1: f'Choppiness Index crossed above the baseline of {self.baseline}, indicating a transition to choppy conditions.',
            0: f'Choppiness Index remains near the baseline of {self.baseline}, indicating neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'CHOP_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'CHOP_Period:{self.period}_TA_Indicator_Value'] = self.chop
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CHOP_Period:{self.period}_TA_Indicator_Value'] = self.chop
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'chop') or self.chop is None:
            self.chop = self.compute_values(df)
        cond_bull = self.chop < self.lower_threshold
        cond_bear = self.chop > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'CHOP_Trending_Strong', -1: 'CHOP_Choppy_Strong', 0: 'CHOP_Neutral'}
        mapping_explanation = {
            1: f'Choppiness Index is below {self.lower_threshold}, indicating strong trending conditions.',
            -1: f'Choppiness Index is above {self.upper_threshold}, indicating strong choppiness.',
            0: f'Choppiness Index is between {self.lower_threshold} and {self.upper_threshold}, indicating moderate conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'CHOP_Period:{self.period}_Upper:{self.upper_threshold}_Lower:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'CHOP_Period:{self.period}_TA_Indicator_Value'] = self.chop
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CHOP_Period:{self.period}_TA_Indicator_Value'] = self.chop
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'chop') or self.chop is None:
            self.chop = self.compute_values(df)
        diff = self.chop.diff()
        signals = np.where(diff < 0, 1, np.where(diff > 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'CHOP_Falling', -1: 'CHOP_Rising', 0: 'CHOP_Unchanged'}
        mapping_explanation = {
            1: 'Choppiness Index is falling, indicating increasing trendiness.',
            -1: 'Choppiness Index is rising, indicating increasing choppiness.',
            0: 'Choppiness Index remains unchanged, indicating stable market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'CHOP_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'CHOP_Period:{self.period}_TA_Indicator_Value'] = self.chop
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CHOP_Period:{self.period}_TA_Indicator_Value'] = self.chop
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class CommodityChannelIndexStrategies:
    def __init__(self, period=20, upper_threshold=100, lower_threshold=-100, baseline=0):
        self.period = period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.baseline = baseline
        self.cci = None

    def compute_values(self, df):
        typical_price = (df['High'] + df['Low'] + df['Close']) / 3
        sma = pd.Series(typical_price).rolling(window=self.period, min_periods=1).mean()
        mean_deviation = pd.Series(np.abs(typical_price - sma)).rolling(window=self.period, min_periods=1).mean()
        cci = (typical_price - sma) / (0.015 * mean_deviation)
        cci = np.where(np.isnan(cci), 0, cci)
        return pd.Series(cci, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'cci') or self.cci is None:
            self.cci = self.compute_values(df)
        cci_prev = self.cci.shift(1)
        cond_bull = (cci_prev <= self.baseline) & (self.cci > self.baseline)
        cond_bear = (cci_prev >= self.baseline) & (self.cci < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'CCI_Above_Baseline', -1: 'CCI_Below_Baseline', 0: 'CCI_Neutral'}
        mapping_explanation = {
            1: f'CCI crossed above the baseline of {self.baseline}, suggesting bullish momentum.',
            -1: f'CCI crossed below the baseline of {self.baseline}, suggesting bearish momentum.',
            0: f'CCI remains neutral around the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'CCI_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'CCI_Period:{self.period}_TA_Indicator_Value'] = self.cci
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CCI_Period:{self.period}_TA_Indicator_Value'] = self.cci
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'cci') or self.cci is None:
            self.cci = self.compute_values(df)
        cond_bull = self.cci < self.lower_threshold
        cond_bear = self.cci > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'CCI_Oversold', -1: 'CCI_Overbought', 0: 'CCI_Neutral'}
        mapping_explanation = {
            1: f'CCI is below {self.lower_threshold}, suggesting oversold conditions and a potential bullish reversal.',
            -1: f'CCI is above {self.upper_threshold}, suggesting overbought conditions and a potential bearish reversal.',
            0: f'CCI is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'CCI_Period:{self.period}_Upper:{self.upper_threshold}_Lower:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'CCI_Period:{self.period}_TA_Indicator_Value'] = self.cci
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CCI_Period:{self.period}_TA_Indicator_Value'] = self.cci
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'cci') or self.cci is None:
            self.cci = self.compute_values(df)
        diff = self.cci.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'CCI_Rising', -1: 'CCI_Falling', 0: 'CCI_Unchanged'}
        mapping_explanation = {
            1: 'CCI is rising, indicating increasing bullish momentum.',
            -1: 'CCI is falling, indicating increasing bearish momentum.',
            0: 'CCI remains unchanged, suggesting a neutral market.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'CCI_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'CCI_Period:{self.period}_TA_Indicator_Value'] = self.cci
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CCI_Period:{self.period}_TA_Indicator_Value'] = self.cci
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class CorrelationTrendIndicatorStrategies:
    def __init__(self, period=20, baseline=0, upper_threshold=0.7, lower_threshold=-0.7):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.cti = None

    def compute_values(self, df):
        def rolling_corr(x):
            n = len(x)
            indices = np.arange(n)
            mean_x = np.mean(x)
            mean_indices = np.mean(indices)
            cov = np.sum((indices - mean_indices) * (x - mean_x))
            std_x = np.sqrt(np.sum((x - mean_x) ** 2))
            std_indices = np.sqrt(np.sum((indices - mean_indices) ** 2))
            return cov / (std_x * std_indices) if std_x != 0 and std_indices != 0 else 0
        cti = df['Close'].rolling(window=self.period, min_periods=1).apply(rolling_corr, raw=True)
        return pd.Series(cti, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'cti') or self.cti is None:
            self.cti = self.compute_values(df)
        cti_prev = self.cti.shift(1)
        cond_bull = (cti_prev <= self.baseline) & (self.cti > self.baseline)
        cond_bear = (cti_prev >= self.baseline) & (self.cti < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'CTI_Above_Baseline', -1: 'CTI_Below_Baseline', 0: 'CTI_Neutral'}
        mapping_explanation = {
            1: f'CTI crossed above the baseline of {self.baseline}, indicating emerging bullish trend.',
            -1: f'CTI crossed below the baseline of {self.baseline}, indicating emerging bearish trend.',
            0: f'CTI remains near the baseline of {self.baseline}, suggesting neutral trend conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'CTI_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'CTI_Period:{self.period}_TA_Indicator_Value'] = self.cti
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CTI_Period:{self.period}_TA_Indicator_Value'] = self.cti
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'cti') or self.cti is None:
            self.cti = self.compute_values(df)
        cond_bull = self.cti > self.upper_threshold
        cond_bear = self.cti < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'CTI_Strong_Bullish', -1: 'CTI_Strong_Bearish', 0: 'CTI_Neutral'}
        mapping_explanation = {
            1: f'CTI is above {self.upper_threshold}, indicating a strong bullish trend.',
            -1: f'CTI is below {self.lower_threshold}, indicating a strong bearish trend.',
            0: f'CTI is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral trend strength.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'CTI_Period:{self.period}_Upper:{self.upper_threshold}_Lower:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'CTI_Period:{self.period}_TA_Indicator_Value'] = self.cti
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CTI_Period:{self.period}_TA_Indicator_Value'] = self.cti
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'cti') or self.cti is None:
            self.cti = self.compute_values(df)
        diff = self.cti.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'CTI_Rising', -1: 'CTI_Falling', 0: 'CTI_Unchanged'}
        mapping_explanation = {
            1: 'CTI is rising, suggesting a strengthening bullish trend.',
            -1: 'CTI is falling, suggesting a strengthening bearish trend.',
            0: 'CTI remains unchanged, indicating stable trend conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'CTI_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'CTI_Period:{self.period}_TA_Indicator_Value'] = self.cti
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CTI_Period:{self.period}_TA_Indicator_Value'] = self.cti
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class CoppockCurveStrategies:
    def __init__(self, roc_period1=14, roc_period2=11, wma_period=10, baseline=0, upper_threshold=0, lower_threshold=-20):
        self.roc_period1 = roc_period1
        self.roc_period2 = roc_period2
        self.wma_period = wma_period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.coppock = None

    def compute_values(self, df):
        roc1 = ((df['Close'] / df['Close'].shift(self.roc_period1)) - 1) * 100
        roc2 = ((df['Close'] / df['Close'].shift(self.roc_period2)) - 1) * 100
        roc_sum = roc1 + roc2
        weights = np.arange(1, self.wma_period + 1)
        coppock = pd.Series(roc_sum).rolling(window=self.wma_period, min_periods=1).apply(lambda x: np.dot(x, weights) / weights.sum(), raw=True)
        return pd.Series(coppock, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'coppock') or self.coppock is None:
            self.coppock = self.compute_values(df)
        coppock_prev = self.coppock.shift(1)
        cond_bull = (coppock_prev <= self.baseline) & (self.coppock > self.baseline)
        cond_bear = (coppock_prev >= self.baseline) & (self.coppock < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Coppock_Above_Baseline', -1: 'Coppock_Below_Baseline', 0: 'Coppock_Neutral'}
        mapping_explanation = {
            1: f'Coppock Curve crossed above the baseline of {self.baseline}, suggesting emerging bullish momentum.',
            -1: f'Coppock Curve crossed below the baseline of {self.baseline}, suggesting emerging bearish momentum.',
            0: f'Coppock Curve remains near the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'CoppockCurve_ROC1:{self.roc_period1}_ROC2:{self.roc_period2}_WMA:{self.wma_period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'CoppockCurve_ROC1:{self.roc_period1}_TA_Indicator_Value'] = self.coppock
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CoppockCurve_ROC1:{self.roc_period1}_TA_Indicator_Value'] = self.coppock
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'coppock') or self.coppock is None:
            self.coppock = self.compute_values(df)
        cond_bull = self.coppock < self.lower_threshold
        cond_bear = self.coppock > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Coppock_Oversold', -1: 'Coppock_Overbought', 0: 'Coppock_Neutral'}
        mapping_explanation = {
            1: f'Coppock Curve is below {self.lower_threshold}, indicating oversold conditions and a potential bullish reversal.',
            -1: f'Coppock Curve is above {self.upper_threshold}, indicating overbought conditions and a potential bearish reversal.',
            0: f'Coppock Curve is between {self.lower_threshold} and {self.upper_threshold}, suggesting balanced momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'CoppockCurve_ROC1:{self.roc_period1}_ROC2:{self.roc_period2}_WMA:{self.wma_period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'CoppockCurve_ROC1:{self.roc_period1}_TA_Indicator_Value'] = self.coppock
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CoppockCurve_ROC1:{self.roc_period1}_TA_Indicator_Value'] = self.coppock
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'coppock') or self.coppock is None:
            self.coppock = self.compute_values(df)
        diff = self.coppock.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Coppock_Rising', -1: 'Coppock_Falling', 0: 'Coppock_Unchanged'}
        mapping_explanation = {
            1: 'Coppock Curve is rising, indicating strengthening bullish momentum.',
            -1: 'Coppock Curve is falling, indicating weakening momentum or bearish conditions.',
            0: 'Coppock Curve remains unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'CoppockCurve_ROC1:{self.roc_period1}_ROC2:{self.roc_period2}_WMA:{self.wma_period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'CoppockCurve_ROC1:{self.roc_period1}_TA_Indicator_Value'] = self.coppock
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CoppockCurve_ROC1:{self.roc_period1}_TA_Indicator_Value'] = self.coppock
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class CumulativeForceIndexStrategies:
    def __init__(self, baseline=0, upper_threshold=50000, lower_threshold=-50000):
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.cfi = None

    def compute_values(self, df):
        cfi = (df['Close'].diff() * df['Volume']).cumsum()
        return pd.Series(cfi, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'cfi') or self.cfi is None:
            self.cfi = self.compute_values(df)
        cfi_prev = self.cfi.shift(1)
        cond_bull = (cfi_prev <= self.baseline) & (self.cfi > self.baseline)
        cond_bear = (cfi_prev >= self.baseline) & (self.cfi < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'CFI_Above_Baseline', -1: 'CFI_Below_Baseline', 0: 'CFI_Neutral'}
        mapping_explanation = {
            1: f'CFI crossed above the baseline of {self.baseline}, indicating bullish momentum.',
            -1: f'CFI crossed below the baseline of {self.baseline}, indicating bearish momentum.',
            0: f'CFI remains near the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'CFI_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'CFI_TA_Indicator_Value'] = self.cfi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CFI_TA_Indicator_Value'] = self.cfi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'cfi') or self.cfi is None:
            self.cfi = self.compute_values(df)
        cond_bull = self.cfi > self.upper_threshold
        cond_bear = self.cfi < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'CFI_Strong_Bullish', -1: 'CFI_Strong_Bearish', 0: 'CFI_Neutral'}
        mapping_explanation = {
            1: f'CFI is above {self.upper_threshold}, indicating strong bullish pressure.',
            -1: f'CFI is below {self.lower_threshold}, indicating strong bearish pressure.',
            0: f'CFI is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced force.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'CFI_Upper:{self.upper_threshold}_Lower:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'CFI_TA_Indicator_Value'] = self.cfi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CFI_TA_Indicator_Value'] = self.cfi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'cfi') or self.cfi is None:
            self.cfi = self.compute_values(df)
        diff = self.cfi.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'CFI_Rising', -1: 'CFI_Falling', 0: 'CFI_Unchanged'}
        mapping_explanation = {
            1: 'CFI is rising, indicating increasing bullish force.',
            -1: 'CFI is falling, indicating increasing bearish force.',
            0: 'CFI remains unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'CFI_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'CFI_TA_Indicator_Value'] = self.cfi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CFI_TA_Indicator_Value'] = self.cfi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class CrossSignalsStrategies:
    def __init__(self, fast_period=5, slow_period=20, baseline=0, upper_threshold=1.0, lower_threshold=-1.0):
        self.fast_period = fast_period
        self.slow_period = slow_period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.cross = None

    def compute_values(self, df):
        fast_ma = pd.Series(df['Close']).rolling(window=self.fast_period, min_periods=1).mean()
        slow_ma = pd.Series(df['Close']).rolling(window=self.slow_period, min_periods=1).mean()
        cross = fast_ma - slow_ma
        return pd.Series(cross, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'cross') or self.cross is None:
            self.cross = self.compute_values(df)
        cross_prev = self.cross.shift(1)
        cond_bull = (cross_prev <= self.baseline) & (self.cross > self.baseline)
        cond_bear = (cross_prev >= self.baseline) & (self.cross < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'CrossSignal_Bullish', -1: 'CrossSignal_Bearish', 0: 'CrossSignal_Neutral'}
        mapping_explanation = {
            1: 'Fast MA crossed above Slow MA, indicating bullish momentum.',
            -1: 'Fast MA crossed below Slow MA, indicating bearish momentum.',
            0: 'No crossing detected, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'CrossSignals_Fast:{self.fast_period}_Slow:{self.slow_period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'CrossSignals_Fast:{self.fast_period}_TA_Indicator_Value'] = self.cross
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CrossSignals_Fast:{self.fast_period}_TA_Indicator_Value'] = self.cross
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'cross') or self.cross is None:
            self.cross = self.compute_values(df)
        cond_bull = self.cross > self.upper_threshold
        cond_bear = self.cross < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'CrossSignal_Strong_Bullish', -1: 'CrossSignal_Strong_Bearish', 0: 'CrossSignal_Neutral'}
        mapping_explanation = {
            1: f'CrossSignal is above {self.upper_threshold}, indicating strong bullish conditions.',
            -1: f'CrossSignal is below {self.lower_threshold}, indicating strong bearish conditions.',
            0: f'CrossSignal is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'CrossSignals_Fast:{self.fast_period}_Slow:{self.slow_period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'CrossSignals_Fast:{self.fast_period}_TA_Indicator_Value'] = self.cross
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CrossSignals_Fast:{self.fast_period}_TA_Indicator_Value'] = self.cross
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'cross') or self.cross is None:
            self.cross = self.compute_values(df)
        diff = self.cross.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'CrossSignal_Rising', -1: 'CrossSignal_Falling', 0: 'CrossSignal_Unchanged'}
        mapping_explanation = {
            1: 'The CrossSignal indicator is rising, suggesting increasing bullish momentum.',
            -1: 'The CrossSignal indicator is falling, suggesting increasing bearish momentum.',
            0: 'The CrossSignal indicator remains unchanged, indicating neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'CrossSignals_Fast:{self.fast_period}_Slow:{self.slow_period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'CrossSignals_Fast:{self.fast_period}_TA_Indicator_Value'] = self.cross
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'CrossSignals_Fast:{self.fast_period}_TA_Indicator_Value'] = self.cross
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class DecayStrategies:
    def __init__(self, period=14, baseline=0, upper_threshold=0.05, lower_threshold=-0.05):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.decay = None

    def compute_values(self, df):
        decay = df['Close'] - pd.Series(df['Close']).ewm(span=self.period, adjust=False).mean()
        return pd.Series(decay, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'decay') or self.decay is None:
            self.decay = self.compute_values(df)
        decay_prev = self.decay.shift(1)
        cond_bull = (decay_prev <= self.baseline) & (self.decay > self.baseline)
        cond_bear = (decay_prev >= self.baseline) & (self.decay < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Decay_Above_Baseline', -1: 'Decay_Below_Baseline', 0: 'Decay_Neutral'}
        mapping_explanation = {
            1: f'Decay crossed above the baseline of {self.baseline}, suggesting bullish conditions.',
            -1: f'Decay crossed below the baseline of {self.baseline}, suggesting bearish conditions.',
            0: f'Decay remains near the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'Decay_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'Decay_Period:{self.period}_TA_Indicator_Value'] = self.decay
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Decay_Period:{self.period}_TA_Indicator_Value'] = self.decay
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'decay') or self.decay is None:
            self.decay = self.compute_values(df)
        cond_bull = self.decay > self.upper_threshold
        cond_bear = self.decay < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Decay_Strong_Bullish', -1: 'Decay_Strong_Bearish', 0: 'Decay_Neutral'}
        mapping_explanation = {
            1: f'Decay is above {self.upper_threshold}, indicating strong bullish momentum.',
            -1: f'Decay is below {self.lower_threshold}, indicating strong bearish momentum.',
            0: f'Decay is between {self.lower_threshold} and {self.upper_threshold}, suggesting neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'Decay_Period:{self.period}_Upper:{self.upper_threshold}_Lower:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'Decay_Period:{self.period}_TA_Indicator_Value'] = self.decay
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Decay_Period:{self.period}_TA_Indicator_Value'] = self.decay
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'decay') or self.decay is None:
            self.decay = self.compute_values(df)
        diff = self.decay.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Decay_Rising', -1: 'Decay_Falling', 0: 'Decay_Unchanged'}
        mapping_explanation = {
            1: 'Decay is rising, indicating increasing bullish momentum.',
            -1: 'Decay is falling, indicating increasing bearish momentum.',
            0: 'Decay remains unchanged, suggesting neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'Decay_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'Decay_Period:{self.period}_TA_Indicator_Value'] = self.decay
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Decay_Period:{self.period}_TA_Indicator_Value'] = self.decay
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

class DecreasingPriceStrategies:
    def __init__(self, period=14, baseline=0, lower_threshold=-2, upper_threshold=2):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold

    def compute_values(self, df):
        dp = ((df['Close'].shift(self.period) - df['Close']) / df['Close'].shift(self.period)) * 100
        self.decreasing_price = pd.Series(dp, index=df.index)
        return self.decreasing_price

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'decreasing_price') or self.decreasing_price is None:
            self.decreasing_price = self.compute_values(df)
        dp_prev = self.decreasing_price.shift(1)
        cond_bear = (dp_prev <= self.baseline) & (self.decreasing_price > self.baseline)
        cond_bull = (dp_prev >= self.baseline) & (self.decreasing_price < self.baseline)
        signals = np.select([cond_bear, cond_bull], [-1, 1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'DecPrice_Below_Baseline', -1: 'DecPrice_Above_Baseline', 0: 'DecPrice_Neutral'}
        mapping_explanation = {
            1: f'DecreasingPrice crossed below the baseline of {self.baseline}, indicating a potential recovery (bullish).',
            -1: f'DecreasingPrice crossed above the baseline of {self.baseline}, indicating the onset of price decline (bearish).',
            0: f'DecreasingPrice remains near the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'DecPrice_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'DecPrice_Period:{self.period}_TA_Indicator_Value'] = self.decreasing_price
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'DecPrice_Period:{self.period}_TA_Indicator_Value'] = self.decreasing_price
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'decreasing_price') or self.decreasing_price is None:
            self.decreasing_price = self.compute_values(df)
        cond_bear = self.decreasing_price > self.upper_threshold
        cond_bull = self.decreasing_price < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'DecPrice_Recovery', -1: 'DecPrice_Strong_Decrease', 0: 'DecPrice_Moderate'}
        mapping_explanation = {
            1: f'DecreasingPrice is below the lower threshold of {self.lower_threshold}, indicating significant recovery (bullish).',
            -1: f'DecreasingPrice is above the upper threshold of {self.upper_threshold}, indicating significant price decline (bearish).',
            0: f'DecreasingPrice is between {self.lower_threshold} and {self.upper_threshold}, indicating moderate movement.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'DecPrice_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'DecPrice_Period:{self.period}_TA_Indicator_Value'] = self.decreasing_price
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'DecPrice_Period:{self.period}_TA_Indicator_Value'] = self.decreasing_price
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'decreasing_price') or self.decreasing_price is None:
            self.decreasing_price = self.compute_values(df)
        diff = self.decreasing_price.diff()
        signals = np.where(diff > 0, -1, np.where(diff < 0, 1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'DecPrice_Recovering', -1: 'DecPrice_Accelerating_Decrease', 0: 'DecPrice_Unchanged'}
        mapping_explanation = {
            1: 'A negative slope indicates that the rate of price decline is easing or reversing (bullish).',
            -1: 'A positive slope indicates that the rate of price decline is accelerating (bearish).',
            0: 'No change in the slope indicates stable price movement.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'DecPrice_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'DecPrice_Period:{self.period}_TA_Indicator_Value'] = self.decreasing_price
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'DecPrice_Period:{self.period}_TA_Indicator_Value'] = self.decreasing_price
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)






class DetrendedPriceOscillatorStrategies:
    def __init__(self, period=20, baseline=0, upper_threshold=5, lower_threshold=-5):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.dpo = None

    def compute_values(self, df):
        sma = pd.Series(df['Close']).rolling(window=self.period, min_periods=1).mean()
        offset = int(self.period / 2 + 1)
        sma_offset = sma.shift(offset)
        dpo = df['Close'] - sma_offset
        return pd.Series(dpo, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if self.dpo is None:
            self.dpo = self.compute_values(df)
        dpo_prev = self.dpo.shift(1)
        cond_bull = (dpo_prev <= self.baseline) & (self.dpo > self.baseline)
        cond_bear = (dpo_prev >= self.baseline) & (self.dpo < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'DPO_Above_Baseline', -1: 'DPO_Below_Baseline', 0: 'DPO_Neutral'}
        mapping_explanation = {
            1: f'DPO crossed above the baseline of {self.baseline}, indicating bullish conditions.',
            -1: f'DPO crossed below the baseline of {self.baseline}, indicating bearish conditions.',
            0: f'DPO remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'DPO_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'DPO_Period:{self.period}_TA_Indicator_Value'] = self.dpo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'DPO_Period:{self.period}_TA_Indicator_Value'] = self.dpo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.dpo is None:
            self.dpo = self.compute_values(df)
        cond_bull = self.dpo < self.lower_threshold
        cond_bear = self.dpo > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'DPO_Oversold', -1: 'DPO_Overbought', 0: 'DPO_Neutral'}
        mapping_explanation = {
            1: f'DPO is below the lower threshold of {self.lower_threshold}, indicating oversold conditions and potential bullish reversal.',
            -1: f'DPO is above the upper threshold of {self.upper_threshold}, indicating overbought conditions and potential bearish reversal.',
            0: f'DPO is within the normal range between {self.lower_threshold} and {self.upper_threshold}, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'DPO_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'DPO_Period:{self.period}_TA_Indicator_Value'] = self.dpo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'DPO_Period:{self.period}_TA_Indicator_Value'] = self.dpo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.dpo is None:
            self.dpo = self.compute_values(df)
        diff = self.dpo.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'DPO_Rising', -1: 'DPO_Falling', 0: 'DPO_Unchanged'}
        mapping_explanation = {
            1: 'DPO is rising, indicating increasing bullish momentum.',
            -1: 'DPO is falling, indicating increasing bearish momentum.',
            0: 'DPO remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'DPO_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'DPO_Period:{self.period}_TA_Indicator_Value'] = self.dpo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'DPO_Period:{self.period}_TA_Indicator_Value'] = self.dpo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


class DirectionalMovementStrategies:
    def __init__(self, period=14, baseline=0, upper_threshold=5, lower_threshold=-5):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.dm = None

    def compute_values(self, df):
        up_move = df['High'] - df['High'].shift(1)
        down_move = df['Low'].shift(1) - df['Low']
        dm_plus = np.where((up_move > down_move) & (up_move > 0), up_move, 0)
        dm_minus = np.where((down_move > up_move) & (down_move > 0), down_move, 0)
        dm = dm_plus - dm_minus
        return pd.Series(dm, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if self.dm is None:
            self.dm = self.compute_values(df)
        dm_prev = self.dm.shift(1)
        cond_bull = (dm_prev <= self.baseline) & (self.dm > self.baseline)
        cond_bear = (dm_prev >= self.baseline) & (self.dm < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'DM_Above_Baseline', -1: 'DM_Below_Baseline', 0: 'DM_Neutral'}
        mapping_explanation = {
            1: f'DM crossed above the baseline of {self.baseline}, indicating bullish directional movement.',
            -1: f'DM crossed below the baseline of {self.baseline}, indicating bearish directional movement.',
            0: f'DM remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'DM_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'DM_Period:{self.period}_TA_Indicator_Value'] = self.dm
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'DM_Period:{self.period}_TA_Indicator_Value'] = self.dm
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.dm is None:
            self.dm = self.compute_values(df)
        cond_bull = self.dm > self.upper_threshold
        cond_bear = self.dm < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'DM_Strong_Bullish', -1: 'DM_Strong_Bearish', 0: 'DM_Neutral'}
        mapping_explanation = {
            1: f'DM is above the upper threshold of {self.upper_threshold}, indicating strong bullish directional movement.',
            -1: f'DM is below the lower threshold of {self.lower_threshold}, indicating strong bearish directional movement.',
            0: f'DM is within the normal range between {self.lower_threshold} and {self.upper_threshold}, indicating balanced directional movement.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'DM_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'DM_Period:{self.period}_TA_Indicator_Value'] = self.dm
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'DM_Period:{self.period}_TA_Indicator_Value'] = self.dm
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.dm is None:
            self.dm = self.compute_values(df)
        diff = self.dm.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'DM_Rising', -1: 'DM_Falling', 0: 'DM_Unchanged'}
        mapping_explanation = {
            1: 'DM is rising, indicating increasing bullish directional momentum.',
            -1: 'DM is falling, indicating increasing bearish directional momentum.',
            0: 'DM remains unchanged, indicating neutral directional movement.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'DM_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'DM_Period:{self.period}_TA_Indicator_Value'] = self.dm
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'DM_Period:{self.period}_TA_Indicator_Value'] = self.dm
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class DonchianChannelStrategies:
    def __init__(self, period=20, tolerance=0.01):
        self.period = period
        self.tolerance = tolerance
        self.upper = None
        self.lower = None
        self.midline = None

    def compute_values(self, df):
        self.upper = df['High'].rolling(window=self.period, min_periods=1).max()
        self.lower = df['Low'].rolling(window=self.period, min_periods=1).min()
        self.midline = (self.upper + self.lower) / 2
        return pd.DataFrame({'Donchian_Upper': self.upper, 'Donchian_Lower': self.lower, 'Donchian_Midline': self.midline}, index=df.index)

    def calculate_scores_breakout_strategy(self, df):
        if self.upper is None or self.lower is None:
            self.compute_values(df)
        prev_upper = self.upper.shift(1)
        prev_lower = self.lower.shift(1)
        cond_bull = df['Close'] > prev_upper
        cond_bear = df['Close'] < prev_lower
        signals = pd.Series(np.select([cond_bull, cond_bear], [1, -1], default=0), index=df.index)
        return signals

    def breakout_map(self, series):
        mapping_value = {1: 'Breakout_Bullish', -1: 'Breakout_Bearish', 0: 'Breakout_Neutral'}
        mapping_explanation = {
            1: 'Price has broken above the previous upper channel, indicating a strong bullish breakout.',
            -1: 'Price has broken below the previous lower channel, indicating a strong bearish breakdown.',
            0: 'Price remains within the channel, indicating no breakout.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_breakout_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_breakout_strategy(df)
        value, explanation = self.breakout_map(score)
        column_prefix = f'Donchian_Period:{self.period}_Breakout_Signal'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'Donchian_Period:{self.period}_Upper'] = self.upper
                df[f'Donchian_Period:{self.period}_Lower'] = self.lower
                df[f'Donchian_Period:{self.period}_Midline'] = self.midline
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Donchian_Period:{self.period}_Upper'] = self.upper
            df_copy[f'Donchian_Period:{self.period}_Lower'] = self.lower
            df_copy[f'Donchian_Period:{self.period}_Midline'] = self.midline
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_bounce_strategy(self, df):
        if self.upper is None or self.lower is None:
            self.compute_values(df)
        cond_bull = ((df['Close'] - self.lower) / self.lower) <= self.tolerance
        cond_bear = ((self.upper - df['Close']) / self.upper) <= self.tolerance
        signals = pd.Series(np.select([cond_bull, cond_bear], [1, -1], default=0), index=df.index)
        return signals

    def bounce_map(self, series):
        mapping_value = {1: 'Bounce_Bullish', -1: 'Bounce_Bearish', 0: 'Bounce_Neutral'}
        mapping_explanation = {
            1: f'Price is near the lower channel boundary, suggesting potential bullish reversal from oversold conditions.',
            -1: f'Price is near the upper channel boundary, suggesting potential bearish reversal from overbought conditions.',
            0: 'Price is not at the boundaries, indicating neutral bounce conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_bounce_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_bounce_strategy(df)
        value, explanation = self.bounce_map(score)
        column_prefix = f'Donchian_Period:{self.period}_Bounce_Signal'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'Donchian_Period:{self.period}_Upper'] = self.upper
                df[f'Donchian_Period:{self.period}_Lower'] = self.lower
                df[f'Donchian_Period:{self.period}_Midline'] = self.midline
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Donchian_Period:{self.period}_Upper'] = self.upper
            df_copy[f'Donchian_Period:{self.period}_Lower'] = self.lower
            df_copy[f'Donchian_Period:{self.period}_Midline'] = self.midline
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_trend_strategy(self, df):
        if self.midline is None:
            self.compute_values(df)
        signals = pd.Series(np.where(df['Close'] > self.midline, 1, np.where(df['Close'] < self.midline, -1, 0)), index=df.index)
        return signals

    def trend_map(self, series):
        mapping_value = {1: 'Trend_Bullish', -1: 'Trend_Bearish', 0: 'Trend_Neutral'}
        mapping_explanation = {
            1: 'Price is above the midline of the channel, indicating an overall upward trend.',
            -1: 'Price is below the midline of the channel, indicating an overall downward trend.',
            0: 'Price is exactly at the midline, indicating a neutral trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_trend_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_trend_strategy(df)
        value, explanation = self.trend_map(score)
        column_prefix = f'Donchian_Period:{self.period}_Trend_Signal'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'Donchian_Period:{self.period}_Upper'] = self.upper
                df[f'Donchian_Period:{self.period}_Lower'] = self.lower
                df[f'Donchian_Period:{self.period}_Midline'] = self.midline
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Donchian_Period:{self.period}_Upper'] = self.upper
            df_copy[f'Donchian_Period:{self.period}_Lower'] = self.lower
            df_copy[f'Donchian_Period:{self.period}_Midline'] = self.midline
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_breakout_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_bounce_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_trend_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
  
class DoubleExponentialMovingAverageStrategies:
    def __init__(self, period=20, distance_threshold=0.01):
        self.period = period
        self.distance_threshold = distance_threshold
        self.dema = None

    def _compute_ema(self, values):
        alpha = 2 / (self.period + 1)
        ema = np.empty(len(values))
        ema[0] = values[0]
        for i in range(1, len(values)):
            ema[i] = alpha * values[i] + (1 - alpha) * ema[i - 1]
        return ema

    def compute_values(self, df):
        prices = df['Close'].values.astype(float)
        ema1 = self._compute_ema(prices)
        ema2 = self._compute_ema(ema1)
        self.dema = 2 * ema1 - ema2
        return pd.Series(self.dema, index=df.index)

    def calculate_scores_price_cross_strategy(self, df):
        if self.dema is None:
            self.compute_values(df)
        close = df['Close']
        dema_series = pd.Series(self.dema, index=df.index)
        close_prev = close.shift(1)
        dema_prev = dema_series.shift(1)
        cond_bull = (close_prev <= dema_prev) & (close > dema_series)
        cond_bear = (close_prev >= dema_prev) & (close < dema_series)
        signals = pd.Series(np.select([cond_bull, cond_bear], [1, -1], default=0), index=df.index)
        return signals

    def price_cross_map(self, series):
        mapping_value = {1: 'PriceAboveDEMA', -1: 'PriceBelowDEMA', 0: 'Neutral'}
        mapping_explanation = {
            1: 'Price has crossed above the DEMA, indicating a bullish trend reversal.',
            -1: 'Price has crossed below the DEMA, indicating a bearish trend reversal.',
            0: 'Price remains on the same side of the DEMA, indicating no significant crossover.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = f'DEMA_Period:{self.period}_PriceCross_Signal'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'DEMA_Period:{self.period}_Value'] = pd.Series(self.dema, index=df.index)
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'DEMA_Period:{self.period}_Value'] = pd.Series(self.dema, index=df.index)
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.dema is None:
            self.compute_values(df)
        dema_series = pd.Series(self.dema, index=df.index)
        diff = dema_series.diff()
        signals = pd.Series(np.where(diff > 0, 1, np.where(diff < 0, -1, 0)), index=df.index)
        return signals

    def slope_map(self, series):
        mapping_value = {1: 'DEMA_Rising', -1: 'DEMA_Falling', 0: 'DEMA_Unchanged'}
        mapping_explanation = {
            1: 'DEMA is rising, suggesting upward momentum.',
            -1: 'DEMA is falling, suggesting downward momentum.',
            0: 'DEMA remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'DEMA_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'DEMA_Period:{self.period}_Value'] = pd.Series(self.dema, index=df.index)
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'DEMA_Period:{self.period}_Value'] = pd.Series(self.dema, index=df.index)
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_distance_strategy(self, df):
        if self.dema is None:
            self.compute_values(df)
        dema_series = pd.Series(self.dema, index=df.index)
        close = df['Close']
        distance = (close - dema_series) / dema_series
        cond_bull = distance > self.distance_threshold
        cond_bear = distance < -self.distance_threshold
        signals = pd.Series(np.select([cond_bull, cond_bear], [1, -1], default=0), index=df.index)
        return signals

    def distance_map(self, series):
        mapping_value = {1: 'Price_Distance_Above', -1: 'Price_Distance_Below', 0: 'Price_Distance_Neutral'}
        mapping_explanation = {
            1: f'Price is above the DEMA by more than {self.distance_threshold*100:.1f}%, indicating strong bullish momentum.',
            -1: f'Price is below the DEMA by more than {self.distance_threshold*100:.1f}%, indicating strong bearish momentum.',
            0: f'Price is within {self.distance_threshold*100:.1f}% of the DEMA, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_distance_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_distance_strategy(df)
        value, explanation = self.distance_map(score)
        column_prefix = f'DEMA_Period:{self.period}_Distance_Signal'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'DEMA_Period:{self.period}_Value'] = pd.Series(self.dema, index=df.index)
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'DEMA_Period:{self.period}_Value'] = pd.Series(self.dema, index=df.index)
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_distance_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
  
class EhlersSuperSmootherFilterStrategies:
    def __init__(self, period=10, distance_threshold=0.01):
        self.period = period
        self.distance_threshold = distance_threshold
        self.filter = None

    def compute_values(self, df):
        prices = df['Close'].values.astype(float)
        N = len(prices)
        result = np.empty(N)
        a = np.exp(-1.414 * np.pi / self.period)
        b = 2 * a * np.cos(1.414 * np.pi / self.period)
        c2 = b
        c3 = -a * a
        c1 = 1 - c2 - c3
        result[0] = prices[0]
        if N > 1:
            result[1] = prices[1]
        for i in range(2, N):
            result[i] = c1 * (prices[i] + prices[i-1]) / 2 + c2 * result[i-1] + c3 * result[i-2]
        self.filter = result
        return pd.Series(result, index=df.index)

    def calculate_scores_price_cross_strategy(self, df):
        if self.filter is None:
            self.compute_values(df)
        price = df['Close']
        filter_series = pd.Series(self.filter, index=df.index)
        price_prev = price.shift(1)
        filter_prev = filter_series.shift(1)
        cond_bull = (price_prev <= filter_prev) & (price > filter_series)
        cond_bear = (price_prev >= filter_prev) & (price < filter_series)
        signals = pd.Series(np.select([cond_bull, cond_bear], [1, -1], default=0), index=df.index)
        return signals

    def price_cross_map(self, series):
        mapping_value = {1: 'PriceAboveFilter', -1: 'PriceBelowFilter', 0: 'Neutral'}
        mapping_explanation = {
            1: 'Price has crossed above the Super Smoother Filter, indicating a bullish reversal.',
            -1: 'Price has crossed below the Super Smoother Filter, indicating a bearish reversal.',
            0: 'No price crossover detected relative to the Super Smoother Filter.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = f'SSSF_Period:{self.period}_PriceCross_Signal'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'SSSF_Period:{self.period}_Value'] = pd.Series(self.filter, index=df.index)
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SSSF_Period:{self.period}_Value'] = pd.Series(self.filter, index=df.index)
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.filter is None:
            self.compute_values(df)
        filter_series = pd.Series(self.filter, index=df.index)
        diff = filter_series.diff()
        signals = pd.Series(np.where(diff > 0, 1, np.where(diff < 0, -1, 0)), index=df.index)
        return signals

    def slope_map(self, series):
        mapping_value = {1: 'Filter_Rising', -1: 'Filter_Falling', 0: 'Filter_Unchanged'}
        mapping_explanation = {
            1: 'The Super Smoother Filter is rising, indicating strengthening bullish momentum.',
            -1: 'The Super Smoother Filter is falling, indicating strengthening bearish momentum.',
            0: 'The Super Smoother Filter is unchanged, indicating a neutral trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'SSSF_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'SSSF_Period:{self.period}_Value'] = pd.Series(self.filter, index=df.index)
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SSSF_Period:{self.period}_Value'] = pd.Series(self.filter, index=df.index)
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_distance_strategy(self, df):
        if self.filter is None:
            self.compute_values(df)
        filter_series = pd.Series(self.filter, index=df.index)
        price = df['Close']
        distance = (price - filter_series) / filter_series
        cond_bull = distance > self.distance_threshold
        cond_bear = distance < -self.distance_threshold
        signals = pd.Series(np.select([cond_bull, cond_bear], [1, -1], default=0), index=df.index)
        return signals

    def distance_map(self, series):
        mapping_value = {1: 'PriceFarAboveFilter', -1: 'PriceFarBelowFilter', 0: 'PriceCloseToFilter'}
        mapping_explanation = {
            1: f'Price is more than {self.distance_threshold*100:.1f}% above the Super Smoother Filter, indicating strong bullish momentum.',
            -1: f'Price is more than {self.distance_threshold*100:.1f}% below the Super Smoother Filter, indicating strong bearish momentum.',
            0: f'Price is within {self.distance_threshold*100:.1f}% of the Super Smoother Filter, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_distance_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_distance_strategy(df)
        value, explanation = self.distance_map(score)
        column_prefix = f'SSSF_Period:{self.period}_Distance_Signal'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'SSSF_Period:{self.period}_Value'] = pd.Series(self.filter, index=df.index)
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SSSF_Period:{self.period}_Value'] = pd.Series(self.filter, index=df.index)
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_distance_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
  
class ElderRayIndexStrategies:
    def __init__(self, period=13, distance_threshold=0.01):
        self.period = period
        self.distance_threshold = distance_threshold
        self.ema = None
        self.bull_power = None
        self.bear_power = None

    def compute_values(self, df):
        prices = df['Close'].values.astype(float)
        N = len(prices)
        ema = np.empty(N)
        alpha = 2 / (self.period + 1)
        ema[0] = prices[0]
        for i in range(1, N):
            ema[i] = alpha * prices[i] + (1 - alpha) * ema[i - 1]
        self.ema = pd.Series(ema, index=df.index)
        self.bull_power = df['High'] - self.ema
        self.bear_power = df['Low'] - self.ema
        return pd.DataFrame({'EMA': self.ema, 'Bull_Power': self.bull_power, 'Bear_Power': self.bear_power}, index=df.index)

    def calculate_scores_price_cross_strategy(self, df):
        if self.ema is None:
            self.compute_values(df)
        price = df['Close']
        ema_series = self.ema
        price_prev = price.shift(1)
        ema_prev = ema_series.shift(1)
        cond_bull = (price_prev <= ema_prev) & (price > ema_series)
        cond_bear = (price_prev >= ema_prev) & (price < ema_series)
        signals = pd.Series(np.select([cond_bull, cond_bear], [1, -1], default=0), index=df.index)
        return signals

    def price_cross_map(self, series):
        mapping_value = {1: 'PriceAboveEMA', -1: 'PriceBelowEMA', 0: 'Neutral'}
        mapping_explanation = {
            1: 'Price has crossed above the EMA, indicating a bullish trend reversal.',
            -1: 'Price has crossed below the EMA, indicating a bearish trend reversal.',
            0: 'Price remains on the same side of the EMA, indicating no significant crossover.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = f'ElderRay_Period:{self.period}_PriceCross_Signal'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'ElderRay_Period:{self.period}_EMA'] = self.ema
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ElderRay_Period:{self.period}_EMA'] = self.ema
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_differential_strategy(self, df):
        if self.bull_power is None or self.bear_power is None:
            self.compute_values(df)
        diff = self.bull_power + self.bear_power
        signals = pd.Series(np.where(diff > 0, 1, np.where(diff < 0, -1, 0)), index=df.index)
        return signals

    def differential_map(self, series):
        mapping_value = {1: 'BullPowerDominant', -1: 'BearPowerDominant', 0: 'Neutral'}
        mapping_explanation = {
            1: 'The average of the high and low is above the EMA, indicating that buying pressure dominates.',
            -1: 'The average of the high and low is below the EMA, indicating that selling pressure dominates.',
            0: 'Buying and selling pressures are balanced.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_differential_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_differential_strategy(df)
        value, explanation = self.differential_map(score)
        column_prefix = f'ElderRay_Period:{self.period}_Differential_Signal'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'ElderRay_Period:{self.period}_EMA'] = self.ema
                df[f'ElderRay_Period:{self.period}_Bull_Power'] = self.bull_power
                df[f'ElderRay_Period:{self.period}_Bear_Power'] = self.bear_power
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ElderRay_Period:{self.period}_EMA'] = self.ema
            df_copy[f'ElderRay_Period:{self.period}_Bull_Power'] = self.bull_power
            df_copy[f'ElderRay_Period:{self.period}_Bear_Power'] = self.bear_power
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_ema_slope_strategy(self, df):
        if self.ema is None:
            self.compute_values(df)
        diff = self.ema.diff()
        signals = pd.Series(np.where(diff > 0, 1, np.where(diff < 0, -1, 0)), index=df.index)
        return signals

    def ema_slope_map(self, series):
        mapping_value = {1: 'EMA_Rising', -1: 'EMA_Falling', 0: 'EMA_Unchanged'}
        mapping_explanation = {
            1: 'The EMA is rising, indicating an overall bullish trend.',
            -1: 'The EMA is falling, indicating an overall bearish trend.',
            0: 'The EMA remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_ema_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_ema_slope_strategy(df)
        value, explanation = self.ema_slope_map(score)
        column_prefix = f'ElderRay_Period:{self.period}_EMASlope_Signal'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'ElderRay_Period:{self.period}_EMA'] = self.ema
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ElderRay_Period:{self.period}_EMA'] = self.ema
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_differential_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_ema_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
class EldersForceIndexStrategies:
    def __init__(self, period=13, baseline=0, upper_threshold=50, lower_threshold=-50):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.efi = None

    def compute_values(self, df):
        raw_force = (df['Close'] - df['Close'].shift(1)) * df['Volume']
        raw_force = raw_force.fillna(0)
        alpha = 2 / (self.period + 1)
        ema = [raw_force.iloc[0]]
        for i in range(1, len(raw_force)):
            ema.append(alpha * raw_force.iloc[i] + (1 - alpha) * ema[i - 1])
        return pd.Series(ema, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if self.efi is None:
            self.efi = self.compute_values(df)
        efi_prev = self.efi.shift(1)
        cond_bull = (efi_prev <= self.baseline) & (self.efi > self.baseline)
        cond_bear = (efi_prev >= self.baseline) & (self.efi < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'EFI_Above_Zero', -1: 'EFI_Below_Zero', 0: 'EFI_Neutral'}
        mapping_explanation = {
            1: f'EFI crossed above zero, indicating bullish momentum.',
            -1: f'EFI crossed below zero, indicating bearish momentum.',
            0: 'EFI remains around zero, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'EFI_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'EFI_Period:{self.period}_TA_Indicator_Value'] = self.efi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'EFI_Period:{self.period}_TA_Indicator_Value'] = self.efi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.efi is None:
            self.efi = self.compute_values(df)
        cond_bull = self.efi < self.lower_threshold
        cond_bear = self.efi > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'EFI_Undersold', -1: 'EFI_Overextended', 0: 'EFI_Neutral'}
        mapping_explanation = {
            1: f'EFI is below the lower threshold of {self.lower_threshold}, suggesting oversold conditions and a potential bullish reversal.',
            -1: f'EFI is above the upper threshold of {self.upper_threshold}, suggesting overextended bullish conditions and a potential bearish reversal.',
            0: 'EFI is within the threshold range, indicating balanced market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'EFI_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'EFI_Period:{self.period}_TA_Indicator_Value'] = self.efi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'EFI_Period:{self.period}_TA_Indicator_Value'] = self.efi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.efi is None:
            self.efi = self.compute_values(df)
        diff = self.efi.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'EFI_Rising', -1: 'EFI_Falling', 0: 'EFI_Unchanged'}
        mapping_explanation = {
            1: 'EFI is rising, indicating increasing bullish momentum.',
            -1: 'EFI is falling, indicating increasing bearish momentum.',
            0: 'EFI remains unchanged, indicating neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'EFI_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'EFI_Period:{self.period}_TA_Indicator_Value'] = self.efi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'EFI_Period:{self.period}_TA_Indicator_Value'] = self.efi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class EldersThermometerStrategies:
    def __init__(self, short_period=13, long_period=48, baseline=0, upper_threshold=0.5, lower_threshold=-0.5):
        self.short_period = short_period
        self.long_period = long_period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.thermo = None

    def ema(self, series, period):
        multiplier = 2/(period+1)
        ema_values = []
        for i, price in enumerate(series):
            if i == 0:
                ema_values.append(price)
            else:
                ema_values.append(price * multiplier + ema_values[-1] * (1 - multiplier))
        return pd.Series(ema_values, index=series.index)

    def compute_values(self, df):
        short_ema = self.ema(df['Close'], self.short_period)
        long_ema = self.ema(df['Close'], self.long_period)
        self.thermo = short_ema - long_ema
        return self.thermo

    def calculate_scores_zero_cross_strategy(self, df):
        if self.thermo is None:
            self.compute_values(df)
        thermo_prev = self.thermo.shift(1)
        cond_bull = (thermo_prev <= self.baseline) & (self.thermo > self.baseline)
        cond_bear = (thermo_prev >= self.baseline) & (self.thermo < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Thermo_Cross_Above', -1: 'Thermo_Cross_Below', 0: 'Thermo_Neutral'}
        mapping_explanation = {
            1: f'Thermometer crossed above the baseline of {self.baseline}, indicating a bullish shift.',
            -1: f'Thermometer crossed below the baseline of {self.baseline}, indicating a bearish shift.',
            0: f'Thermometer remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'Thermo_SP:{self.short_period}_LP:{self.long_period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'Thermo_SP:{self.short_period}_LP:{self.long_period}_TA_Indicator_Value'] = self.thermo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Thermo_SP:{self.short_period}_LP:{self.long_period}_TA_Indicator_Value'] = self.thermo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.thermo is None:
            self.compute_values(df)
        cond_bull = self.thermo < self.lower_threshold
        cond_bear = self.thermo > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Thermo_Oversold', -1: 'Thermo_Overheated', 0: 'Thermo_Neutral'}
        mapping_explanation = {
            1: f'Thermometer is below the lower threshold of {self.lower_threshold}, suggesting oversold conditions and a potential bullish reversal.',
            -1: f'Thermometer is above the upper threshold of {self.upper_threshold}, suggesting overheated conditions and a potential bearish reversal.',
            0: f'Thermometer is within the thresholds, indicating neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'Thermo_SP:{self.short_period}_LP:{self.long_period}_Upper:{self.upper_threshold}_Lower:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'Thermo_SP:{self.short_period}_LP:{self.long_period}_TA_Indicator_Value'] = self.thermo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Thermo_SP:{self.short_period}_LP:{self.long_period}_TA_Indicator_Value'] = self.thermo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.thermo is None:
            self.compute_values(df)
        diff = self.thermo.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Thermo_Rising', -1: 'Thermo_Falling', 0: 'Thermo_Unchanged'}
        mapping_explanation = {
            1: 'Thermometer is rising, indicating strengthening bullish momentum.',
            -1: 'Thermometer is falling, indicating strengthening bearish momentum.',
            0: 'Thermometer remains unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'Thermo_SP:{self.short_period}_LP:{self.long_period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'Thermo_SP:{self.short_period}_LP:{self.long_period}_TA_Indicator_Value'] = self.thermo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Thermo_SP:{self.short_period}_LP:{self.long_period}_TA_Indicator_Value'] = self.thermo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class ElasticVolumeMovingAverageStrategies:
    def __init__(self, period=20, upper_threshold=0.05, lower_threshold=-0.05):
        self.period = period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.evma = None

    def compute_values(self, df):
        base_alpha = 2 / (self.period + 1)
        rolling_avg_vol = df['Volume'].rolling(window=self.period, min_periods=1).mean()
        evma_list = []
        evma_list.append(df['Close'].iloc[0])
        for i in range(1, len(df)):
            vol = df['Volume'].iloc[i]
            avg_vol = rolling_avg_vol.iloc[i]
            alpha = base_alpha * (vol / avg_vol) if avg_vol != 0 else base_alpha
            if alpha > 1:
                alpha = 1
            new_val = evma_list[-1] + alpha * (df['Close'].iloc[i] - evma_list[-1])
            evma_list.append(new_val)
        self.evma = pd.Series(evma_list, index=df.index)
        return self.evma

    def calculate_scores_price_cross_strategy(self, df):
        if self.evma is None:
            self.compute_values(df)
        close_prev = df['Close'].shift(1)
        evma_prev = self.evma.shift(1)
        cond_bull = (close_prev <= evma_prev) & (df['Close'] > self.evma)
        cond_bear = (close_prev >= evma_prev) & (df['Close'] < self.evma)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def price_cross_map(self, series):
        mapping_value = {1: 'Price_Above_EVMA', -1: 'Price_Below_EVMA', 0: 'Price_Neutral'}
        mapping_explanation = {
            1: 'The closing price has crossed above the Elastic Volume Moving Average, indicating bullish momentum.',
            -1: 'The closing price has crossed below the Elastic Volume Moving Average, indicating bearish momentum.',
            0: 'No significant price crossover with the Elastic Volume Moving Average detected.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = f'EVMA_Period:{self.period}_PriceCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'EVMA_Period:{self.period}_TA_Indicator_Value'] = self.evma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'EVMA_Period:{self.period}_TA_Indicator_Value'] = self.evma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.evma is None:
            self.compute_values(df)
        divergence = (df['Close'] - self.evma) / self.evma
        cond_bull = divergence < self.lower_threshold
        cond_bear = divergence > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Price_Undersold', -1: 'Price_Overextended', 0: 'Price_Normal'}
        mapping_explanation = {
            1: f'The closing price is significantly below the Elastic Volume Moving Average (by more than {abs(self.lower_threshold)*100:.1f}%), suggesting a potential bullish reversal.',
            -1: f'The closing price is significantly above the Elastic Volume Moving Average (by more than {self.upper_threshold*100:.1f}%), suggesting a potential bearish reversal.',
            0: 'The closing price is within a normal range relative to the Elastic Volume Moving Average.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'EVMA_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'EVMA_Period:{self.period}_TA_Indicator_Value'] = self.evma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'EVMA_Period:{self.period}_TA_Indicator_Value'] = self.evma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.evma is None:
            self.compute_values(df)
        diff = self.evma.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'EVMA_Rising', -1: 'EVMA_Falling', 0: 'EVMA_Unchanged'}
        mapping_explanation = {
            1: 'The Elastic Volume Moving Average is rising, indicating increasing bullish momentum.',
            -1: 'The Elastic Volume Moving Average is falling, indicating increasing bearish momentum.',
            0: 'The Elastic Volume Moving Average is unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'EVMA_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'EVMA_Period:{self.period}_TA_Indicator_Value'] = self.evma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'EVMA_Period:{self.period}_TA_Indicator_Value'] = self.evma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)




class ElasticVolumeMACDStrategies:
    def __init__(self, fast_period=12, slow_period=26, signal_period=9, histogram_upper=0.5, histogram_lower=-0.5):
        self.fast_period = fast_period
        self.slow_period = slow_period
        self.signal_period = signal_period
        self.histogram_upper = histogram_upper
        self.histogram_lower = histogram_lower
        self.macd_line = None
        self.signal_line = None
        self.histogram = None

    def elastic_ema(self, series, volume, period):
        base_alpha = 2/(period+1)
        rolling_avg_vol = volume.rolling(window=period, min_periods=1).mean()
        ema_values = [series.iloc[0]]
        for i in range(1, len(series)):
            vol = volume.iloc[i]
            avg_vol = rolling_avg_vol.iloc[i]
            alpha = base_alpha * (vol/avg_vol) if avg_vol != 0 else base_alpha
            if alpha > 1:
                alpha = 1
            ema_values.append(ema_values[-1] + alpha*(series.iloc[i]-ema_values[-1]))
        return pd.Series(ema_values, index=series.index)

    def standard_ema(self, series, period):
        alpha = 2/(period+1)
        ema_values = [series.iloc[0]]
        for i in range(1, len(series)):
            ema_values.append(ema_values[-1] + alpha*(series.iloc[i]-ema_values[-1]))
        return pd.Series(ema_values, index=series.index)

    def compute_values(self, df):
        fast_ema = self.elastic_ema(df['Close'], df['Volume'], self.fast_period)
        slow_ema = self.elastic_ema(df['Close'], df['Volume'], self.slow_period)
        self.macd_line = fast_ema - slow_ema
        self.signal_line = self.standard_ema(self.macd_line, self.signal_period)
        self.histogram = self.macd_line - self.signal_line
        result = pd.DataFrame({'MACD': self.macd_line, 'Signal': self.signal_line, 'Histogram': self.histogram}, index=df.index)
        return result

    def calculate_scores_price_cross_strategy(self, df):
        if self.macd_line is None or self.signal_line is None:
            self.compute_values(df)
        macd_prev = self.macd_line.shift(1)
        signal_prev = self.signal_line.shift(1)
        cond_bull = (macd_prev <= signal_prev) & (self.macd_line > self.signal_line)
        cond_bear = (macd_prev >= signal_prev) & (self.macd_line < self.signal_line)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def price_cross_map(self, series):
        mapping_value = {1: 'MACD_Cross_Above', -1: 'MACD_Cross_Below', 0: 'MACD_Cross_Neutral'}
        mapping_explanation = {
            1: 'MACD line crossed above the signal line, indicating a bullish momentum shift.',
            -1: 'MACD line crossed below the signal line, indicating a bearish momentum shift.',
            0: 'No significant crossover between MACD and signal line.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = f'EVMACD_F:{self.fast_period}_S:{self.slow_period}_Sig:{self.signal_period}_PriceCross'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'EVMACD_F:{self.fast_period}_S:{self.slow_period}_TA_Indicator_MACD'] = self.macd_line
                df[f'EVMACD_F:{self.fast_period}_S:{self.slow_period}_TA_Indicator_Signal'] = self.signal_line
                df[f'EVMACD_F:{self.fast_period}_S:{self.slow_period}_TA_Indicator_Histogram'] = self.histogram
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'EVMACD_F:{self.fast_period}_S:{self.slow_period}_TA_Indicator_MACD'] = self.macd_line
            df_copy[f'EVMACD_F:{self.fast_period}_S:{self.slow_period}_TA_Indicator_Signal'] = self.signal_line
            df_copy[f'EVMACD_F:{self.fast_period}_S:{self.slow_period}_TA_Indicator_Histogram'] = self.histogram
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.histogram is None:
            self.compute_values(df)
        cond_bull = self.histogram > self.histogram_upper
        cond_bear = self.histogram < self.histogram_lower
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Histogram_High', -1: 'Histogram_Low', 0: 'Histogram_Normal'}
        mapping_explanation = {
            1: f'MACD histogram is above {self.histogram_upper}, indicating strong bullish momentum.',
            -1: f'MACD histogram is below {self.histogram_lower}, indicating strong bearish momentum.',
            0: 'MACD histogram is within normal range, indicating balanced momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'EVMACD_F:{self.fast_period}_S:{self.slow_period}_HistThreshold'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'EVMACD_F:{self.fast_period}_S:{self.slow_period}_TA_Indicator_Histogram'] = self.histogram
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'EVMACD_F:{self.fast_period}_S:{self.slow_period}_TA_Indicator_Histogram'] = self.histogram
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.macd_line is None:
            self.compute_values(df)
        diff = self.macd_line.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'MACD_Rising', -1: 'MACD_Falling', 0: 'MACD_Unchanged'}
        mapping_explanation = {
            1: 'MACD line is rising, indicating increasing bullish momentum.',
            -1: 'MACD line is falling, indicating increasing bearish momentum.',
            0: 'MACD line remains unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'EVMACD_F:{self.fast_period}_S:{self.slow_period}_Slope'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'EVMACD_F:{self.fast_period}_S:{self.slow_period}_TA_Indicator_MACD'] = self.macd_line
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'EVMACD_F:{self.fast_period}_S:{self.slow_period}_TA_Indicator_MACD'] = self.macd_line
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


  
class ExponentialMovingAverageStrategies:
    def __init__(self, period=20, upper_threshold=0.03, lower_threshold=-0.03):
        self.period = period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.ema = None

    def compute_values(self, df):
        multiplier = 2 / (self.period + 1)
        ema_values = [df['Close'].iloc[0]]
        for i in range(1, len(df)):
            ema_values.append(df['Close'].iloc[i] * multiplier + ema_values[-1] * (1 - multiplier))
        self.ema = pd.Series(ema_values, index=df.index)
        return self.ema

    def calculate_scores_price_cross_strategy(self, df):
        if self.ema is None:
            self.compute_values(df)
        close_prev = df['Close'].shift(1)
        ema_prev = self.ema.shift(1)
        cond_bull = (close_prev <= ema_prev) & (df['Close'] > self.ema)
        cond_bear = (close_prev >= ema_prev) & (df['Close'] < self.ema)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def price_cross_map(self, series):
        mapping_value = {1: 'Price_Above_EMA', -1: 'Price_Below_EMA', 0: 'Price_Neutral'}
        mapping_explanation = {
            1: 'The price has crossed above the EMA, suggesting a bullish trend.',
            -1: 'The price has crossed below the EMA, suggesting a bearish trend.',
            0: 'No price crossover detected relative to the EMA.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = f'EMA_Period:{self.period}_PriceCross'
        if append:
            if ta_indicator_value:
                df[f'EMA_Period:{self.period}_TA_Indicator_Value'] = self.ema
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'EMA_Period:{self.period}_TA_Indicator_Value'] = self.ema
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.ema is None:
            self.compute_values(df)
        divergence = (df['Close'] - self.ema) / self.ema
        cond_bull = divergence < self.lower_threshold
        cond_bear = divergence > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Price_Undersold', -1: 'Price_Overextended', 0: 'Price_Normal'}
        mapping_explanation = {
            1: f'The price is significantly below the EMA (by more than {abs(self.lower_threshold)*100:.1f}%), indicating potential undervaluation and a bullish reversal.',
            -1: f'The price is significantly above the EMA (by more than {self.upper_threshold*100:.1f}%), indicating potential overextension and a bearish reversal.',
            0: 'The price is close to the EMA, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'EMA_Period:{self.period}_Threshold'
        if append:
            if ta_indicator_value:
                df[f'EMA_Period:{self.period}_TA_Indicator_Value'] = self.ema
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'EMA_Period:{self.period}_TA_Indicator_Value'] = self.ema
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.ema is None:
            self.compute_values(df)
        diff = self.ema.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'EMA_Rising', -1: 'EMA_Falling', 0: 'EMA_Unchanged'}
        mapping_explanation = {
            1: 'The EMA is rising, indicating upward momentum.',
            -1: 'The EMA is falling, indicating downward momentum.',
            0: 'The EMA is stable, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'EMA_Period:{self.period}_Slope'
        if append:
            if ta_indicator_value:
                df[f'EMA_Period:{self.period}_TA_Indicator_Value'] = self.ema
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'EMA_Period:{self.period}_TA_Indicator_Value'] = self.ema
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


  
class FibonacciPivotPointsStrategies:
    def __init__(self):
        self.pp = None

    def compute_values(self, df):
        pivot = (df['High'].shift(1) + df['Low'].shift(1) + df['Close'].shift(1)) / 3
        range_val = df['High'].shift(1) - df['Low'].shift(1)
        R1 = pivot + 0.382 * range_val
        R2 = pivot + 0.618 * range_val
        R3 = pivot + 1.000 * range_val
        S1 = pivot - 0.382 * range_val
        S2 = pivot - 0.618 * range_val
        S3 = pivot - 1.000 * range_val
        self.pp = pd.DataFrame({'Pivot': pivot, 'R1': R1, 'R2': R2, 'R3': R3, 'S1': S1, 'S2': S2, 'S3': S3}, index=df.index)
        return self.pp

    def calculate_scores_pivot_cross_strategy(self, df):
        if self.pp is None:
            self.compute_values(df)
        pivot = self.pp['Pivot']
        close_prev = df['Close'].shift(1)
        close_curr = df['Close']
        cond_bull = (close_prev <= pivot) & (close_curr > pivot)
        cond_bear = (close_prev >= pivot) & (close_curr < pivot)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def pivot_cross_map(self, series):
        mapping_value = {1: 'Price_Above_Pivot', -1: 'Price_Below_Pivot', 0: 'Pivot_Neutral'}
        mapping_explanation = {
            1: 'Price crossed above the pivot point, indicating bullish momentum.',
            -1: 'Price crossed below the pivot point, indicating bearish momentum.',
            0: 'Price remains around the pivot, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_pivot_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_pivot_cross_strategy(df)
        value, explanation = self.pivot_cross_map(score)
        column_prefix = 'FibPivot_PivotCross'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df['FibPivot_Pivot'] = self.pp['Pivot']
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['FibPivot_Pivot'] = self.pp['Pivot']
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_fib_bounce_strategy(self, df):
        if self.pp is None:
            self.compute_values(df)
        S1 = self.pp['S1']
        R1 = self.pp['R1']
        close_prev = df['Close'].shift(1)
        close_curr = df['Close']
        cond_bull = (close_prev < S1) & (close_curr > S1)
        cond_bear = (close_prev > R1) & (close_curr < R1)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def fib_bounce_map(self, series):
        mapping_value = {1: 'Bounce_From_Support', -1: 'Rejection_From_Resistance', 0: 'Bounce_Neutral'}
        mapping_explanation = {
            1: 'Price bounced upward from the support level (S1), indicating a potential bullish reversal.',
            -1: 'Price was rejected at the resistance level (R1), indicating a potential bearish reversal.',
            0: 'No significant bounce observed at key Fibonacci levels.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_fib_bounce_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_fib_bounce_strategy(df)
        value, explanation = self.fib_bounce_map(score)
        column_prefix = 'FibPivot_FibBounce'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df['FibPivot_S1'] = self.pp['S1']
                df['FibPivot_R1'] = self.pp['R1']
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['FibPivot_S1'] = self.pp['S1']
            df_copy['FibPivot_R1'] = self.pp['R1']
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_fib_zone_strategy(self, df):
        if self.pp is None:
            self.compute_values(df)
        close = df['Close']
        R2 = self.pp['R2']
        S2 = self.pp['S2']
        cond_bear = close > R2
        cond_bull = close < S2
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def fib_zone_map(self, series):
        mapping_value = {1: 'Oversold_Zone', -1: 'Overbought_Zone', 0: 'Zone_Neutral'}
        mapping_explanation = {
            1: 'Price is in the lower zone below S2, indicating oversold conditions and a potential bullish reversal.',
            -1: 'Price is in the upper zone above R2, indicating overbought conditions and a potential bearish reversal.',
            0: 'Price is within a neutral zone between key Fibonacci levels.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_fib_zone_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_fib_zone_strategy(df)
        value, explanation = self.fib_zone_map(score)
        column_prefix = 'FibPivot_FibZone'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df['FibPivot_R2'] = self.pp['R2']
                df['FibPivot_S2'] = self.pp['S2']
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['FibPivot_R2'] = self.pp['R2']
            df_copy['FibPivot_S2'] = self.pp['S2']
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_pivot_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        # df_copy_2 = self.calculate_fib_bounce_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_fib_zone_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        # return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
        return pd.concat([df_copy_1, df_copy_3], axis=1)


  
class FibonacciWeightedMovingAverageStrategies:
    def __init__(self, period=10, upper_threshold=0.03, lower_threshold=-0.03):
        self.period = period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.fwma = None

    def compute_values(self, df):
        prices = df['Close']
        fib_sequence = []
        for i in range(self.period):
            if i < 2:
                fib_sequence.append(1)
            else:
                fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])
        total_weight = sum(fib_sequence)
        fwma_list = [np.nan] * (self.period - 1)
        for i in range(self.period - 1, len(prices)):
            window = prices.iloc[i - self.period + 1:i + 1].tolist()
            weighted_sum = sum(fib_sequence[j] * window[j] for j in range(self.period))
            fwma_list.append(weighted_sum / total_weight)
        self.fwma = pd.Series(fwma_list, index=df.index)
        return self.fwma

    def calculate_scores_price_cross_strategy(self, df):
        if self.fwma is None:
            self.compute_values(df)
        close_prev = df['Close'].shift(1)
        fwma_prev = self.fwma.shift(1)
        cond_bull = (close_prev <= fwma_prev) & (df['Close'] > self.fwma)
        cond_bear = (close_prev >= fwma_prev) & (df['Close'] < self.fwma)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def price_cross_map(self, series):
        mapping_value = {1: 'Price_Above_FWMA', -1: 'Price_Below_FWMA', 0: 'Price_Neutral'}
        mapping_explanation = {
            1: 'The closing price crossed above the Fibonacci Weighted Moving Average, indicating bullish momentum.',
            -1: 'The closing price crossed below the Fibonacci Weighted Moving Average, indicating bearish momentum.',
            0: 'No significant price crossover relative to the Fibonacci Weighted Moving Average.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = f'FWMA_Period:{self.period}_PriceCross'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'FWMA_Period:{self.period}_TA_Indicator_Value'] = self.fwma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'FWMA_Period:{self.period}_TA_Indicator_Value'] = self.fwma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.fwma is None:
            self.compute_values(df)
        divergence = (df['Close'] - self.fwma) / self.fwma
        cond_bull = divergence < self.lower_threshold
        cond_bear = divergence > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Price_Undersold', -1: 'Price_Overextended', 0: 'Price_Normal'}
        mapping_explanation = {
            1: f'The closing price is significantly below the Fibonacci Weighted Moving Average (by more than {abs(self.lower_threshold)*100:.1f}%), suggesting bullish reversal.',
            -1: f'The closing price is significantly above the Fibonacci Weighted Moving Average (by more than {self.upper_threshold*100:.1f}%), suggesting bearish reversal.',
            0: 'The closing price is close to the Fibonacci Weighted Moving Average, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'FWMA_Period:{self.period}_Threshold'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'FWMA_Period:{self.period}_TA_Indicator_Value'] = self.fwma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'FWMA_Period:{self.period}_TA_Indicator_Value'] = self.fwma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.fwma is None:
            self.compute_values(df)
        diff = self.fwma.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'FWMA_Rising', -1: 'FWMA_Falling', 0: 'FWMA_Unchanged'}
        mapping_explanation = {
            1: 'The Fibonacci Weighted Moving Average is rising, indicating bullish momentum.',
            -1: 'The Fibonacci Weighted Moving Average is falling, indicating bearish momentum.',
            0: 'The Fibonacci Weighted Moving Average remains unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'FWMA_Period:{self.period}_Slope'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'FWMA_Period:{self.period}_TA_Indicator_Value'] = self.fwma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'FWMA_Period:{self.period}_TA_Indicator_Value'] = self.fwma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


  
class FiniteVolumeElementStrategies:
    def __init__(self, period=10, upper_threshold=1.0, lower_threshold=-1.0):
        self.period = period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.fve = None

    def compute_values(self, df):
        epsilon = 1e-10
        raw_fve = (df['Close'] - df['Open']) * df['Volume'] / (df['High'] - df['Low'] + epsilon)
        self.fve = raw_fve.rolling(window=self.period, min_periods=1).mean()
        return self.fve

    def calculate_scores_zero_cross_strategy(self, df):
        if self.fve is None:
            self.compute_values(df)
        fve_prev = self.fve.shift(1)
        cond_bull = (fve_prev <= 0) & (self.fve > 0)
        cond_bear = (fve_prev >= 0) & (self.fve < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'FVE_Cross_Above_Zero', -1: 'FVE_Cross_Below_Zero', 0: 'FVE_Zero_Neutral'}
        mapping_explanation = {
            1: 'The Finite Volume Element has crossed above zero, suggesting a shift to bullish momentum.',
            -1: 'The Finite Volume Element has crossed below zero, indicating a shift to bearish momentum.',
            0: 'No significant zero crossing detected in the Finite Volume Element.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'FVE_Period:{self.period}_ZeroCross'
        if append:
            if ta_indicator_value:
                df[f'FVE_Period:{self.period}_TA_Indicator_Value'] = self.fve
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'FVE_Period:{self.period}_TA_Indicator_Value'] = self.fve
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.fve is None:
            self.compute_values(df)
        cond_bull = self.fve > self.upper_threshold
        cond_bear = self.fve < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'FVE_Above_Threshold', -1: 'FVE_Below_Threshold', 0: 'FVE_Within_Threshold'}
        mapping_explanation = {
            1: f'The Finite Volume Element is above {self.upper_threshold}, indicating strong bullish momentum.',
            -1: f'The Finite Volume Element is below {self.lower_threshold}, indicating strong bearish momentum.',
            0: 'The Finite Volume Element is within the defined thresholds, suggesting neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'FVE_Period:{self.period}_Threshold'
        if append:
            if ta_indicator_value:
                df[f'FVE_Period:{self.period}_TA_Indicator_Value'] = self.fve
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'FVE_Period:{self.period}_TA_Indicator_Value'] = self.fve
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.fve is None:
            self.compute_values(df)
        diff = self.fve.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'FVE_Rising', -1: 'FVE_Falling', 0: 'FVE_Unchanged'}
        mapping_explanation = {
            1: 'The Finite Volume Element is rising, suggesting increasing bullish momentum.',
            -1: 'The Finite Volume Element is falling, indicating increasing bearish momentum.',
            0: 'The Finite Volume Element remains unchanged, suggesting neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'FVE_Period:{self.period}_Slope'
        if append:
            if ta_indicator_value:
                df[f'FVE_Period:{self.period}_TA_Indicator_Value'] = self.fve
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'FVE_Period:{self.period}_TA_Indicator_Value'] = self.fve
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


  
class FisherTransformStrategies:
    def __init__(self, period=10, upper_threshold=1.5, lower_threshold=-1.5):
        self.period = period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.fisher = None

    def compute_values(self, df):
        highest = df['High'].rolling(window=self.period, min_periods=1).max()
        lowest = df['Low'].rolling(window=self.period, min_periods=1).min()
        norm = 2 * ((df['Close'] - lowest) / (highest - lowest)) - 1
        norm = norm.clip(-0.999, 0.999)
        fisher_values = []
        for i in range(len(norm)):
            fisher_values.append(0.5 * np.log((1 + norm.iloc[i]) / (1 - norm.iloc[i])))
        self.fisher = pd.Series(fisher_values, index=df.index)
        return self.fisher

    def calculate_scores_zero_cross_strategy(self, df):
        if self.fisher is None:
            self.compute_values(df)
        fisher_prev = self.fisher.shift(1)
        cond_bull = (fisher_prev <= 0) & (self.fisher > 0)
        cond_bear = (fisher_prev >= 0) & (self.fisher < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def fisher_cross_map(self, series):
        mapping_value = {1: 'Fisher_Cross_Above_Zero', -1: 'Fisher_Cross_Below_Zero', 0: 'Fisher_Neutral'}
        mapping_explanation = {
            1: 'Fisher Transform crossed above zero, indicating potential bullish reversal.',
            -1: 'Fisher Transform crossed below zero, indicating potential bearish reversal.',
            0: 'No significant zero crossing in the Fisher Transform.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.fisher_cross_map(score)
        column_prefix = f'Fisher_Period:{self.period}_ZeroCross'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'Fisher_Period:{self.period}_TA_Indicator_Value'] = self.fisher
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Fisher_Period:{self.period}_TA_Indicator_Value'] = self.fisher
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.fisher is None:
            self.compute_values(df)
        cond_bull = self.fisher < self.lower_threshold
        cond_bear = self.fisher > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Fisher_Oversold', -1: 'Fisher_Overbought', 0: 'Fisher_Normal'}
        mapping_explanation = {
            1: f'Fisher Transform is below {self.lower_threshold}, indicating oversold conditions and a potential bullish reversal.',
            -1: f'Fisher Transform is above {self.upper_threshold}, indicating overbought conditions and a potential bearish reversal.',
            0: 'Fisher Transform is within normal range, suggesting balanced market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'Fisher_Period:{self.period}_Threshold'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'Fisher_Period:{self.period}_TA_Indicator_Value'] = self.fisher
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Fisher_Period:{self.period}_TA_Indicator_Value'] = self.fisher
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.fisher is None:
            self.compute_values(df)
        diff = self.fisher.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Fisher_Rising', -1: 'Fisher_Falling', 0: 'Fisher_Unchanged'}
        mapping_explanation = {
            1: 'Fisher Transform is rising, indicating strengthening bullish momentum.',
            -1: 'Fisher Transform is falling, indicating strengthening bearish momentum.',
            0: 'Fisher Transform remains unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'Fisher_Period:{self.period}_Slope'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'Fisher_Period:{self.period}_TA_Indicator_Value'] = self.fisher
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Fisher_Period:{self.period}_TA_Indicator_Value'] = self.fisher
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


  
class ForceIndexStrategies:
    def __init__(self, upper_threshold=1000, lower_threshold=-1000):
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.force_index = None

    def compute_values(self, df):
        force = (df['Close'] - df['Close'].shift(1)) * df['Volume']
        self.force_index = force.fillna(0)
        return self.force_index

    def calculate_scores_zero_cross_strategy(self, df):
        if self.force_index is None:
            self.compute_values(df)
        force_prev = self.force_index.shift(1)
        cond_bull = (force_prev <= 0) & (self.force_index > 0)
        cond_bear = (force_prev >= 0) & (self.force_index < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'ForceIndex_Cross_Above_Zero', -1: 'ForceIndex_Cross_Below_Zero', 0: 'ForceIndex_Zero_Neutral'}
        mapping_explanation = {
            1: 'The Force Index crossed above zero, indicating a shift to bullish momentum.',
            -1: 'The Force Index crossed below zero, indicating a shift to bearish momentum.',
            0: 'No significant zero crossing in the Force Index, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'ForceIndex_ZeroCross'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df['ForceIndex_TA_Value'] = self.force_index
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['ForceIndex_TA_Value'] = self.force_index
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.force_index is None:
            self.compute_values(df)
        cond_bull = self.force_index > self.upper_threshold
        cond_bear = self.force_index < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'ForceIndex_Above_Threshold', -1: 'ForceIndex_Below_Threshold', 0: 'ForceIndex_Within_Threshold'}
        mapping_explanation = {
            1: f'The Force Index is above {self.upper_threshold}, indicating strong bullish force.',
            -1: f'The Force Index is below {self.lower_threshold}, indicating strong bearish force.',
            0: 'The Force Index is within the defined thresholds, indicating neutral force.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'ForceIndex_Threshold'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df['ForceIndex_TA_Value'] = self.force_index
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['ForceIndex_TA_Value'] = self.force_index
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.force_index is None:
            self.compute_values(df)
        diff = self.force_index.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'ForceIndex_Rising', -1: 'ForceIndex_Falling', 0: 'ForceIndex_Unchanged'}
        mapping_explanation = {
            1: 'The Force Index is rising, indicating increasing bullish momentum.',
            -1: 'The Force Index is falling, indicating increasing bearish momentum.',
            0: 'The Force Index remains unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'ForceIndex_Slope'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df['ForceIndex_TA_Value'] = self.force_index
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['ForceIndex_TA_Value'] = self.force_index
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


  
class FractalAdaptiveMovingAverageStrategies:
    def __init__(self, period=10, divergence_upper_threshold=0.03, divergence_lower_threshold=-0.03):
        self.period = period
        self.divergence_upper_threshold = divergence_upper_threshold
        self.divergence_lower_threshold = divergence_lower_threshold
        self.frama = None

    def compute_values(self, df):
        prices = df['Close']
        frama_values = []
        for i in range(len(prices)):
            if i == 0:
                frama_values.append(prices.iloc[i])
            elif i < self.period - 1:
                frama_values.append(prices.iloc[i])
            else:
                window = prices.iloc[i - self.period + 1 : i + 1]
                first_half = window.iloc[:self.period // 2]
                second_half = window.iloc[self.period // 2:]
                range1 = first_half.max() - first_half.min()
                range2 = second_half.max() - second_half.min()
                range_full = window.max() - window.min()
                if range_full == 0:
                    D = 1
                else:
                    D = np.log((range1 + range2) / range_full) / np.log(2)
                alpha = np.exp(-4.6 * (D - 1))
                lower_bound = 1 / self.period
                if alpha < lower_bound:
                    alpha = lower_bound
                if alpha > 1:
                    alpha = 1
                prev_frama = frama_values[-1]
                current_frama = prev_frama + alpha * (prices.iloc[i] - prev_frama)
                frama_values.append(current_frama)
        self.frama = pd.Series(frama_values, index=df.index)
        return self.frama

    def calculate_scores_price_cross_strategy(self, df):
        if self.frama is None:
            self.compute_values(df)
        close_prev = df['Close'].shift(1)
        frama_prev = self.frama.shift(1)
        cond_bull = (close_prev <= frama_prev) & (df['Close'] > self.frama)
        cond_bear = (close_prev >= frama_prev) & (df['Close'] < self.frama)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def price_cross_map(self, series):
        mapping_value = {1: 'Price_Above_FRAMA', -1: 'Price_Below_FRAMA', 0: 'Price_Neutral'}
        mapping_explanation = {
            1: 'Price crossed above the Fractal Adaptive Moving Average, indicating a bullish shift.',
            -1: 'Price crossed below the Fractal Adaptive Moving Average, indicating a bearish shift.',
            0: 'No significant price crossover relative to the FRAMA.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = f'FRAMA_Period:{self.period}_PriceCross'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'FRAMA_Period:{self.period}_TA_Indicator_Value'] = self.frama
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'FRAMA_Period:{self.period}_TA_Indicator_Value'] = self.frama
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.frama is None:
            self.compute_values(df)
        divergence = (df['Close'] - self.frama) / self.frama
        cond_bull = divergence < self.divergence_lower_threshold
        cond_bear = divergence > self.divergence_upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Price_Undersold', -1: 'Price_Overextended', 0: 'Price_Normal'}
        mapping_explanation = {
            1: 'Price is significantly below the FRAMA, suggesting undervalued conditions and a potential bullish reversal.',
            -1: 'Price is significantly above the FRAMA, suggesting overvalued conditions and a potential bearish reversal.',
            0: 'Price is close to the FRAMA, indicating neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'FRAMA_Period:{self.period}_Threshold'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'FRAMA_Period:{self.period}_TA_Indicator_Value'] = self.frama
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'FRAMA_Period:{self.period}_TA_Indicator_Value'] = self.frama
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.frama is None:
            self.compute_values(df)
        diff = self.frama.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'FRAMA_Rising', -1: 'FRAMA_Falling', 0: 'FRAMA_Unchanged'}
        mapping_explanation = {
            1: 'FRAMA is rising, indicating strengthening bullish momentum.',
            -1: 'FRAMA is falling, indicating increasing bearish momentum.',
            0: 'FRAMA remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'FRAMA_Period:{self.period}_Slope'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'FRAMA_Period:{self.period}_TA_Indicator_Value'] = self.frama
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'FRAMA_Period:{self.period}_TA_Indicator_Value'] = self.frama
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        # df_copy_1 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        # df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        # return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
        return pd.concat([df_copy_3], axis=1)



  
class GannHighLowActivatorStrategies:
    def __init__(self, divergence_upper_threshold=0.03, divergence_lower_threshold=-0.03):
        self.divergence_upper_threshold = divergence_upper_threshold
        self.divergence_lower_threshold = divergence_lower_threshold
        self.activator = None

    def compute_values(self, df):
        activator = []
        for i in range(len(df)):
            if i == 0:
                activator.append(df['Close'].iloc[i])
            else:
                if df['Close'].iloc[i] > activator[i - 1]:
                    new_val = min(df['Low'].iloc[i], activator[i - 1])
                elif df['Close'].iloc[i] < activator[i - 1]:
                    new_val = max(df['High'].iloc[i], activator[i - 1])
                else:
                    new_val = activator[i - 1]
                activator.append(new_val)
        self.activator = pd.Series(activator, index=df.index)
        return self.activator

    def calculate_scores_zero_cross_strategy(self, df):
        if self.activator is None:
            self.compute_values(df)
        activator_prev = self.activator.shift(1)
        close_prev = df['Close'].shift(1)
        cond_bull = (close_prev <= activator_prev) & (df['Close'] > self.activator)
        cond_bear = (close_prev >= activator_prev) & (df['Close'] < self.activator)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Price_Above_Activator', -1: 'Price_Below_Activator', 0: 'Activator_Neutral'}
        mapping_explanation = {
            1: 'Price crossed above the Gann High Low Activator, indicating bullish momentum.',
            -1: 'Price crossed below the Gann High Low Activator, indicating bearish momentum.',
            0: 'No significant crossover relative to the activator.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = 'GannHLActivator_ZeroCross'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df['GannHLActivator_TA_Value'] = self.activator
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['GannHLActivator_TA_Value'] = self.activator
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.activator is None:
            self.compute_values(df)
        divergence = (df['Close'] - self.activator) / self.activator
        cond_bull = divergence > self.divergence_upper_threshold
        cond_bear = divergence < self.divergence_lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Price_Significantly_Above', -1: 'Price_Significantly_Below', 0: 'Price_Near_Activator'}
        mapping_explanation = {
            1: f'Price is significantly above the activator (by more than {self.divergence_upper_threshold * 100:.1f}%), indicating strong bullish conditions.',
            -1: f'Price is significantly below the activator (by more than {abs(self.divergence_lower_threshold) * 100:.1f}%), indicating strong bearish conditions.',
            0: 'Price is close to the activator, suggesting neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = 'GannHLActivator_Threshold'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df['GannHLActivator_TA_Value'] = self.activator
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['GannHLActivator_TA_Value'] = self.activator
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.activator is None:
            self.compute_values(df)
        diff = self.activator.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Activator_Rising', -1: 'Activator_Falling', 0: 'Activator_Unchanged'}
        mapping_explanation = {
            1: 'The activator is rising, suggesting a strengthening uptrend.',
            -1: 'The activator is falling, suggesting a weakening trend or potential reversal.',
            0: 'The activator remains unchanged, indicating neutral trend conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'GannHLActivator_Slope'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df['GannHLActivator_TA_Value'] = self.activator
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['GannHLActivator_TA_Value'] = self.activator
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class HighLowAverageStrategies:
    def __init__(self, upper_threshold=0.02, lower_threshold=-0.02):
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.hla = None

    def compute_values(self, df):
        self.hla = (df['High'] + df['Low']) / 2
        return self.hla

    def calculate_scores_price_cross_strategy(self, df):
        if self.hla is None:
            self.compute_values(df)
        close_prev = df['Close'].shift(1)
        hla_prev = self.hla.shift(1)
        cond_bull = (close_prev <= hla_prev) & (df['Close'] > self.hla)
        cond_bear = (close_prev >= hla_prev) & (df['Close'] < self.hla)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def price_cross_map(self, series):
        mapping_value = {1: 'Price_Above_HLA', -1: 'Price_Below_HLA', 0: 'HLA_Neutral'}
        mapping_explanation = {
            1: 'Price crossed above the HighLowAverage, indicating bullish momentum.',
            -1: 'Price crossed below the HighLowAverage, indicating bearish momentum.',
            0: 'No significant price crossover relative to the HighLowAverage.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = 'HLA_PriceCross'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df['HLA_TA_Value'] = self.hla
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['HLA_TA_Value'] = self.hla
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.hla is None:
            self.compute_values(df)
        divergence = (df['Close'] - self.hla) / self.hla
        cond_bull = divergence < self.lower_threshold
        cond_bear = divergence > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Price_Undersold', -1: 'Price_Overextended', 0: 'Price_Normal'}
        mapping_explanation = {
            1: 'Price is significantly below the HighLowAverage, indicating potential bullish reversal.',
            -1: 'Price is significantly above the HighLowAverage, indicating potential bearish reversal.',
            0: 'Price is close to the HighLowAverage, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = 'HLA_Threshold'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df['HLA_TA_Value'] = self.hla
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['HLA_TA_Value'] = self.hla
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.hla is None:
            self.compute_values(df)
        diff = self.hla.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'HLA_Rising', -1: 'HLA_Falling', 0: 'HLA_Unchanged'}
        mapping_explanation = {
            1: 'The HighLowAverage is rising, indicating bullish momentum.',
            -1: 'The HighLowAverage is falling, indicating bearish momentum.',
            0: 'The HighLowAverage remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'HLA_Slope'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df['HLA_TA_Value'] = self.hla
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['HLA_TA_Value'] = self.hla
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


  
class HilbertTransformDominantCyclePeriodStrategies:
    def __init__(self, period=14, baseline=15, lower_threshold=10, upper_threshold=20):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.htdcp = None

    def compute_values(self, df):
        self.htdcp = df['Close'].rolling(window=self.period, min_periods=1).std() * 10 + 10
        return self.htdcp

    def calculate_scores_baseline_strategy(self, df):
        if self.htdcp is None:
            self.compute_values(df)
        htdcp_prev = self.htdcp.shift(1)
        cond_bull = (htdcp_prev >= self.baseline) & (self.htdcp < self.baseline)
        cond_bear = (htdcp_prev <= self.baseline) & (self.htdcp > self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def baseline_map(self, series):
        mapping_value = {1: 'HTDCP_Below_Baseline', -1: 'HTDCP_Above_Baseline', 0: 'HTDCP_Neutral'}
        mapping_explanation = {
            1: f'HTDCP has crossed below the baseline of {self.baseline}, indicating a contraction of cycle periods and potential bullish momentum.',
            -1: f'HTDCP has crossed above the baseline of {self.baseline}, indicating an expansion of cycle periods and potential bearish conditions.',
            0: f'HTDCP remains near the baseline of {self.baseline}, suggesting neutral cycle conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_baseline_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_baseline_strategy(df)
        value, explanation = self.baseline_map(score)
        column_prefix = f'HTDCP_Period:{self.period}_Baseline'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'HTDCP_Period:{self.period}_TA_Value'] = self.htdcp
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'HTDCP_Period:{self.period}_TA_Value'] = self.htdcp
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.htdcp is None:
            self.compute_values(df)
        cond_bull = self.htdcp < self.lower_threshold
        cond_bear = self.htdcp > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'HTDCP_Fast_Cycle', -1: 'HTDCP_Slow_Cycle', 0: 'HTDCP_Normal'}
        mapping_explanation = {
            1: f'HTDCP is below {self.lower_threshold}, indicating a rapid cycle and potential bullish momentum.',
            -1: f'HTDCP is above {self.upper_threshold}, indicating a slow cycle and potential bearish conditions.',
            0: 'HTDCP is within the defined thresholds, suggesting normal cycle conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'HTDCP_Period:{self.period}_Threshold'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'HTDCP_Period:{self.period}_TA_Value'] = self.htdcp
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'HTDCP_Period:{self.period}_TA_Value'] = self.htdcp
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.htdcp is None:
            self.compute_values(df)
        diff = self.htdcp.diff()
        signals = np.where(diff < 0, 1, np.where(diff > 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'HTDCP_Contracting', -1: 'HTDCP_Expanding', 0: 'HTDCP_Unchanged'}
        mapping_explanation = {
            1: 'HTDCP is contracting, suggesting shorter cycles and potential bullish momentum.',
            -1: 'HTDCP is expanding, suggesting longer cycles and potential bearish conditions.',
            0: 'HTDCP remains unchanged, indicating stable cycle conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'HTDCP_Period:{self.period}_Slope'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'HTDCP_Period:{self.period}_TA_Value'] = self.htdcp
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'HTDCP_Period:{self.period}_TA_Value'] = self.htdcp
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_baseline_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)




  
class HilbertTransformDominantCyclePhaseStrategies:
    def __init__(self, period=10, baseline=0, lower_threshold=-0.5, upper_threshold=0.5):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.phase = None

    def compute_values(self, df):
        epsilon = 1e-10
        delta = df['Close'].diff()
        raw_phase = np.arctan(delta / (np.abs(delta) + epsilon))
        phase = raw_phase.rolling(window=self.period, min_periods=1).mean()
        self.phase = phase
        return self.phase

    def calculate_scores_baseline_strategy(self, df):
        if self.phase is None:
            self.compute_values(df)
        phase_prev = self.phase.shift(1)
        cond_bull = (phase_prev <= self.baseline) & (self.phase > self.baseline)
        cond_bear = (phase_prev >= self.baseline) & (self.phase < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def baseline_map(self, series):
        mapping_value = {1: 'Phase_Above_Baseline', -1: 'Phase_Below_Baseline', 0: 'Phase_Neutral'}
        mapping_explanation = {
            1: f'The dominant cycle phase has crossed above the baseline of {self.baseline}, suggesting bullish cyclic momentum.',
            -1: f'The dominant cycle phase has crossed below the baseline of {self.baseline}, suggesting bearish cyclic momentum.',
            0: f'The dominant cycle phase remains around the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_baseline_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_baseline_strategy(df)
        value, explanation = self.baseline_map(score)
        column_prefix = f'HTDCP_Phase_Period:{self.period}_Baseline'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'HTDCP_Phase_Period:{self.period}_TA_Value'] = self.phase
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'HTDCP_Phase_Period:{self.period}_TA_Value'] = self.phase
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.phase is None:
            self.compute_values(df)
        cond_bull = self.phase < self.lower_threshold
        cond_bear = self.phase > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Phase_Low', -1: 'Phase_High', 0: 'Phase_Normal'}
        mapping_explanation = {
            1: f'The dominant cycle phase is below {self.lower_threshold}, indicating an oversold cyclic condition and potential bullish reversal.',
            -1: f'The dominant cycle phase is above {self.upper_threshold}, indicating an overbought cyclic condition and potential bearish reversal.',
            0: 'The dominant cycle phase is within normal range, suggesting balanced cycle conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'HTDCP_Phase_Period:{self.period}_Threshold'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'HTDCP_Phase_Period:{self.period}_TA_Value'] = self.phase
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'HTDCP_Phase_Period:{self.period}_TA_Value'] = self.phase
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.phase is None:
            self.compute_values(df)
        diff = self.phase.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Phase_Rising', -1: 'Phase_Falling', 0: 'Phase_Unchanged'}
        mapping_explanation = {
            1: 'The dominant cycle phase is rising, indicating strengthening bullish cyclic momentum.',
            -1: 'The dominant cycle phase is falling, indicating strengthening bearish cyclic momentum.',
            0: 'The dominant cycle phase remains unchanged, suggesting neutral cyclic conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'HTDCP_Phase_Period:{self.period}_Slope'
        if append:
            if ta_indicator_value:
                self.compute_values(df)
                df[f'HTDCP_Phase_Period:{self.period}_TA_Value'] = self.phase
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'HTDCP_Phase_Period:{self.period}_TA_Value'] = self.phase
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_baseline_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


  
class HilbertTransformInstantaneousTrendlineStrategies:
    def __init__(self, deviation_threshold=0.5):
        self.deviation_threshold = deviation_threshold
        self.htit = None

    def compute_values(self, df):
        self.htit = (4 * df['Close'] + 3 * df['Close'].shift(1) + 2 * df['Close'].shift(2) + df['Close'].shift(3)) / 10
        return pd.Series(self.htit, index=df.index)

    def calculate_scores_crossover_strategy(self, df):
        if self.htit is None:
            self.compute_values(df)
        close_prev = df['Close'].shift(1)
        trend_prev = self.htit.shift(1)
        close_current = df['Close']
        trend_current = self.htit
        cond_bull = (close_prev <= trend_prev) & (close_current > trend_current)
        cond_bear = (close_prev >= trend_prev) & (close_current < trend_current)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def crossover_map(self, series):
        mapping_value = {1: 'Price_Above_Trendline', -1: 'Price_Below_Trendline', 0: 'No_Crossover'}
        mapping_explanation = {
            1: 'Price crossed above the Hilbert Transform Instantaneous Trendline, indicating a bullish signal.',
            -1: 'Price crossed below the Hilbert Transform Instantaneous Trendline, indicating a bearish signal.',
            0: 'No significant price crossover detected relative to the trendline.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_crossover_strategy(df)
        value, explanation = self.crossover_map(score)
        column_prefix = 'HTIT_Crossover_Signal'
        if append:
            if ta_indicator_value:
                df['HTIT_TA_Indicator_Value'] = self.htit
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['HTIT_TA_Indicator_Value'] = self.htit
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.htit is None:
            self.compute_values(df)
        slope = self.htit.diff()
        signals = np.where(slope > 0, 1, np.where(slope < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Trend_Rising', -1: 'Trend_Falling', 0: 'Trend_Flat'}
        mapping_explanation = {
            1: 'The instantaneous trendline is rising, indicating bullish momentum.',
            -1: 'The instantaneous trendline is falling, indicating bearish momentum.',
            0: 'The instantaneous trendline is flat, indicating no clear momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'HTIT_Slope_Signal'
        if append:
            if ta_indicator_value:
                df['HTIT_TA_Indicator_Value'] = self.htit
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['HTIT_TA_Indicator_Value'] = self.htit
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_deviation_strategy(self, df):
        if self.htit is None:
            self.compute_values(df)
        deviation = ((df['Close'] - self.htit) / self.htit) * 100
        cond_bull = deviation < -self.deviation_threshold
        cond_bear = deviation > self.deviation_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def deviation_map(self, series):
        mapping_value = {1: 'Price_Under_Trendline', -1: 'Price_Over_Trendline', 0: 'Price_Near_Trendline'}
        mapping_explanation = {
            1: f'Price is significantly below the Hilbert Transform Instantaneous Trendline by more than {self.deviation_threshold}%, indicating potential bullish reversal.',
            -1: f'Price is significantly above the Hilbert Transform Instantaneous Trendline by more than {self.deviation_threshold}%, indicating potential bearish reversal.',
            0: 'Price is within the acceptable range of the trendline, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_deviation_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_deviation_strategy(df)
        value, explanation = self.deviation_map(score)
        column_prefix = 'HTIT_Deviation_Signal'
        if append:
            if ta_indicator_value:
                df['HTIT_TA_Indicator_Value'] = self.htit
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['HTIT_TA_Indicator_Value'] = self.htit
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_crossover_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_deviation_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class HilbertTransformPhasorComponentsStrategies:
    def __init__(self, phase_threshold=0):
        self.phase_threshold = phase_threshold
        self.I = None
        self.Q = None

    def compute_values(self, df):
        detrender = (0.075 * df['Close'] + 0.54 * df['Close'].shift(2) - 0.54 * df['Close'].shift(4) - 0.075 * df['Close'].shift(6))
        self.I = detrender
        self.Q = (0.075 * detrender + 0.54 * detrender.shift(2) - 0.54 * detrender.shift(4) - 0.075 * detrender.shift(6))
        return pd.DataFrame({'HTPC_I': self.I, 'HTPC_Q': self.Q}, index=df.index)

    def calculate_scores_phase_crossover_strategy(self, df):
        if self.I is None or self.Q is None:
            self.compute_values(df)
        phase = np.degrees(np.arctan2(self.Q, self.I))
        phase_prev = phase.shift(1)
        cond_bull = (phase_prev <= self.phase_threshold) & (phase > self.phase_threshold)
        cond_bear = (phase_prev >= self.phase_threshold) & (phase < self.phase_threshold)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def phase_crossover_map(self, series):
        mapping_value = {1: 'Phase_Above_Threshold', -1: 'Phase_Below_Threshold', 0: 'No_Phase_Crossover'}
        mapping_explanation = {
            1: f'Phase angle crossed above the threshold of {self.phase_threshold}, indicating bullish cyclic momentum.',
            -1: f'Phase angle crossed below the threshold of {self.phase_threshold}, indicating bearish cyclic momentum.',
            0: f'No phase crossover relative to the threshold of {self.phase_threshold} detected.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_phase_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_phase_crossover_strategy(df)
        value, explanation = self.phase_crossover_map(score)
        column_prefix = 'HTPC_PhaseCrossover_Signal'
        if append:
            if ta_indicator_value:
                phase = np.degrees(np.arctan2(self.Q, self.I))
                df['HTPC_Phase_Angle'] = phase
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            phase = np.degrees(np.arctan2(self.Q, self.I))
            df_copy['HTPC_Phase_Angle'] = phase
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_magnitude_slope_strategy(self, df):
        if self.I is None or self.Q is None:
            self.compute_values(df)
        magnitude = np.sqrt(self.I**2 + self.Q**2)
        slope = magnitude.diff()
        signals = np.where(slope > 0, 1, np.where(slope < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def magnitude_slope_map(self, series):
        mapping_value = {1: 'Magnitude_Increasing', -1: 'Magnitude_Decreasing', 0: 'Magnitude_Unchanged'}
        mapping_explanation = {
            1: 'The phasor magnitude is rising, suggesting increasing cyclic momentum and a bullish signal.',
            -1: 'The phasor magnitude is falling, suggesting decreasing cyclic momentum and a bearish signal.',
            0: 'The phasor magnitude remains unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_magnitude_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_magnitude_slope_strategy(df)
        value, explanation = self.magnitude_slope_map(score)
        column_prefix = 'HTPC_MagnitudeSlope_Signal'
        if append:
            magnitude = np.sqrt(self.I**2 + self.Q**2)
            if ta_indicator_value:
                df['HTPC_Phasor_Magnitude'] = magnitude
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        magnitude = np.sqrt(self.I**2 + self.Q**2)
        if ta_indicator_value:
            df_copy['HTPC_Phasor_Magnitude'] = magnitude
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_phase_crossover_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_magnitude_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2], axis=1)

  
  
class HilbertTransformSineWaveStrategies:
    def __init__(self):
        self.sine = None
        self.leadsine = None

    def compute_values(self, df):
        detrender = (0.0962 * df['Close'] + 0.5769 * df['Close'].shift(2) - 0.5769 * df['Close'].shift(4) - 0.0962 * df['Close'].shift(6))
        inphase = detrender
        quadrature = (0.0962 * inphase + 0.5769 * inphase.shift(2) - 0.5769 * inphase.shift(4) - 0.0962 * inphase.shift(6))
        phase = np.arctan2(quadrature, inphase)
        self.sine = np.sin(phase)
        self.leadsine = np.sin(phase + np.pi/4)
        return pd.DataFrame({'HTSW_Sine': self.sine, 'HTSW_LeadSine': self.leadsine}, index=df.index)

    def calculate_scores_crossover_strategy(self, df):
        if self.sine is None or self.leadsine is None:
            self.compute_values(df)
        sine_prev = self.sine.shift(1)
        leadsine_prev = self.leadsine.shift(1)
        cond_bull = (sine_prev <= leadsine_prev) & (self.sine > self.leadsine)
        cond_bear = (sine_prev >= leadsine_prev) & (self.sine < self.leadsine)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def crossover_map(self, series):
        mapping_value = {1: 'Sine_Above_LeadSine', -1: 'Sine_Below_LeadSine', 0: 'No_Crossover'}
        mapping_explanation = {
            1: 'Sine crossed above LeadSine, indicating a bullish shift in the market cycle.',
            -1: 'Sine crossed below LeadSine, indicating a bearish shift in the market cycle.',
            0: 'No crossover detected between Sine and LeadSine, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_crossover_strategy(df)
        value, explanation = self.crossover_map(score)
        column_prefix = 'HTSW_Crossover_Signal'
        if append:
            if ta_indicator_value:
                df['HTSW_TA_Indicator_Sine'] = self.sine
                df['HTSW_TA_Indicator_LeadSine'] = self.leadsine
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['HTSW_TA_Indicator_Sine'] = self.sine
            df_copy['HTSW_TA_Indicator_LeadSine'] = self.leadsine
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.sine is None:
            self.compute_values(df)
        slope = self.sine.diff()
        signals = np.where(slope > 0, 1, np.where(slope < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Sine_Rising', -1: 'Sine_Falling', 0: 'Sine_Flat'}
        mapping_explanation = {
            1: 'The Sine is rising, indicating increasing bullish cyclic momentum.',
            -1: 'The Sine is falling, indicating increasing bearish cyclic momentum.',
            0: 'The Sine is flat, indicating neutral cyclic momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'HTSW_Slope_Signal'
        if append:
            if ta_indicator_value:
                df['HTSW_TA_Indicator_Sine'] = self.sine
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['HTSW_TA_Indicator_Sine'] = self.sine
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_crossover_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2], axis=1)



class HilbertTransformTrendCycleStrategies:
    def __init__(self, deviation_threshold=1.0):
        self.deviation_threshold = deviation_threshold
        self.httc = None

    def compute_values(self, df):
        self.httc = (df['Close'] + 2 * df['Close'].shift(1) + 3 * df['Close'].shift(2) + 2 * df['Close'].shift(3) + df['Close'].shift(4)) / 9
        return pd.Series(self.httc, index=df.index)

    def calculate_scores_crossover_strategy(self, df):
        if self.httc is None:
            self.compute_values(df)
        price_prev = df['Close'].shift(1)
        cycle_prev = pd.Series(self.httc, index=df.index).shift(1)
        price_current = df['Close']
        cycle_current = pd.Series(self.httc, index=df.index)
        cond_bull = (price_prev <= cycle_prev) & (price_current > cycle_current)
        cond_bear = (price_prev >= cycle_prev) & (price_current < cycle_current)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def crossover_map(self, series):
        mapping_value = {1: 'Price_Above_TrendCycle', -1: 'Price_Below_TrendCycle', 0: 'No_Crossover'}
        mapping_explanation = {
            1: 'Price crossed above the Hilbert Transform Trend Cycle, suggesting bullish momentum.',
            -1: 'Price crossed below the Hilbert Transform Trend Cycle, suggesting bearish momentum.',
            0: 'No significant price crossover relative to the Trend Cycle was detected.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_crossover_strategy(df)
        value, explanation = self.crossover_map(score)
        column_prefix = 'HTTC_Crossover_Signal'
        if append:
            if ta_indicator_value:
                df['HTTC_TA_Indicator_Value'] = self.httc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['HTTC_TA_Indicator_Value'] = self.httc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.httc is None:
            self.compute_values(df)
        slope = pd.Series(self.httc, index=df.index).diff()
        signals = np.where(slope > 0, 1, np.where(slope < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'TrendCycle_Rising', -1: 'TrendCycle_Falling', 0: 'TrendCycle_Flat'}
        mapping_explanation = {
            1: 'The Trend Cycle is rising, indicating increasing bullish momentum.',
            -1: 'The Trend Cycle is falling, indicating increasing bearish momentum.',
            0: 'The Trend Cycle is flat, indicating neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'HTTC_Slope_Signal'
        if append:
            if ta_indicator_value:
                df['HTTC_TA_Indicator_Value'] = self.httc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['HTTC_TA_Indicator_Value'] = self.httc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_deviation_strategy(self, df):
        if self.httc is None:
            self.compute_values(df)
        deviation = ((df['Close'] - self.httc) / self.httc) * 100
        cond_bull = deviation < -self.deviation_threshold
        cond_bear = deviation > self.deviation_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def deviation_map(self, series):
        mapping_value = {1: 'Price_Under_TrendCycle', -1: 'Price_Over_TrendCycle', 0: 'Price_Near_TrendCycle'}
        mapping_explanation = {
            1: f'Price is significantly below the Trend Cycle by more than {self.deviation_threshold}%, suggesting a potential bullish reversal.',
            -1: f'Price is significantly above the Trend Cycle by more than {self.deviation_threshold}%, suggesting a potential bearish reversal.',
            0: 'Price is close to the Trend Cycle, indicating balanced market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_deviation_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_deviation_strategy(df)
        value, explanation = self.deviation_map(score)
        column_prefix = 'HTTC_Deviation_Signal'
        if append:
            if ta_indicator_value:
                df['HTTC_TA_Indicator_Value'] = self.httc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['HTTC_TA_Indicator_Value'] = self.httc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_crossover_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_deviation_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class HoltWinterChannelStrategies:
    def __init__(self, alpha=0.2, beta=0.1, window=14, channel_multiplier=2, deviation_percent_threshold=20):
        self.alpha = alpha
        self.beta = beta
        self.window = window
        self.channel_multiplier = channel_multiplier
        self.deviation_percent_threshold = deviation_percent_threshold
        self.center = None
        self.upper_channel = None
        self.lower_channel = None

    def compute_values(self, df):
        n = len(df)
        price = df['Close'].values
        level = [0] * n
        trend = [0] * n
        forecast = [0] * n
        level[0] = price[0]
        trend[0] = price[1] - price[0] if n > 1 else 0
        forecast[0] = level[0] + trend[0]
        for i in range(1, n):
            level[i] = self.alpha * price[i] + (1 - self.alpha) * (level[i - 1] + trend[i - 1])
            trend[i] = self.beta * (level[i] - level[i - 1]) + (1 - self.beta) * trend[i - 1]
            forecast[i] = level[i] + trend[i]
        series_forecast = pd.Series(forecast, index=df.index)
        residual = df['Close'] - series_forecast
        error = residual.rolling(window=self.window, min_periods=1).std()
        upper_channel = series_forecast + self.channel_multiplier * error
        lower_channel = series_forecast - self.channel_multiplier * error
        self.center = series_forecast
        self.upper_channel = upper_channel
        self.lower_channel = lower_channel
        return pd.DataFrame({'HWC_Center': series_forecast, 'HWC_Upper': upper_channel, 'HWC_Lower': lower_channel}, index=df.index)

    def calculate_scores_crossover_strategy(self, df):
        if self.upper_channel is None or self.lower_channel is None:
            self.compute_values(df)
        price_prev = df['Close'].shift(1)
        price_current = df['Close']
        upper_prev = self.upper_channel.shift(1)
        lower_prev = self.lower_channel.shift(1)
        cond_bull = (price_prev < upper_prev) & (price_current >= self.upper_channel)
        cond_bear = (price_prev > lower_prev) & (price_current <= self.lower_channel)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def crossover_map(self, series):
        mapping_value = {1: 'Price_Breakout_Upper', -1: 'Price_Breakout_Lower', 0: 'Price_Within_Channel'}
        mapping_explanation = {
            1: 'Price crossed above the upper Holt-Winters channel, suggesting strong bullish momentum.',
            -1: 'Price crossed below the lower Holt-Winters channel, suggesting strong bearish momentum.',
            0: 'Price remains within the channel boundaries, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_crossover_strategy(df)
        value, explanation = self.crossover_map(score)
        column_prefix = 'HWC_Crossover_Signal'
        if append:
            if ta_indicator_value:
                ta_values = self.compute_values(df)
                df['HWC_Center'] = ta_values['HWC_Center']
                df['HWC_Upper'] = ta_values['HWC_Upper']
                df['HWC_Lower'] = ta_values['HWC_Lower']
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['HWC_Center'] = self.center
            df_copy['HWC_Upper'] = self.upper_channel
            df_copy['HWC_Lower'] = self.lower_channel
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.center is None:
            self.compute_values(df)
        slope = self.center.diff()
        signals = np.where(slope > 0, 1, np.where(slope < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Channel_Rising', -1: 'Channel_Falling', 0: 'Channel_Flat'}
        mapping_explanation = {
            1: 'The center line of the Holt-Winters channel is rising, indicating an uptrend.',
            -1: 'The center line of the Holt-Winters channel is falling, indicating a downtrend.',
            0: 'The center line of the Holt-Winters channel is flat, indicating neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'HWC_Slope_Signal'
        if append:
            if ta_indicator_value:
                ta_values = self.compute_values(df)
                df['HWC_Center'] = ta_values['HWC_Center']
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['HWC_Center'] = self.center
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_deviation_strategy(self, df):
        if self.center is None:
            self.compute_values(df)
        deviation = ((df['Close'] - self.center) / self.center) * 100
        cond_bull = deviation < -self.deviation_percent_threshold
        cond_bear = deviation > self.deviation_percent_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def deviation_map(self, series):
        mapping_value = {1: 'Price_Undersold_Relative', -1: 'Price_Overbought_Relative', 0: 'Price_Near_Center'}
        mapping_explanation = {
            1: f'Price is significantly below the center channel by more than {self.deviation_percent_threshold}%, suggesting potential bullish reversal.',
            -1: f'Price is significantly above the center channel by more than {self.deviation_percent_threshold}%, suggesting potential bearish reversal.',
            0: 'Price is near the center channel, indicating balanced market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_deviation_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_deviation_strategy(df)
        value, explanation = self.deviation_map(score)
        column_prefix = 'HWC_Deviation_Signal'
        if append:
            if ta_indicator_value:
                ta_values = self.compute_values(df)
                df['HWC_Center'] = ta_values['HWC_Center']
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['HWC_Center'] = self.center
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_crossover_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_deviation_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


  
  
class HoltWinterMovingAverageStrategies:
    def __init__(self, alpha=0.2, beta=0.1, deviation_percent_threshold=2.0):
        self.alpha = alpha
        self.beta = beta
        self.deviation_percent_threshold = deviation_percent_threshold
        self.hwma = None

    def compute_values(self, df):
        n = len(df)
        price = df['Close'].values
        level = [0] * n
        trend = [0] * n
        forecast = [0] * n
        level[0] = price[0]
        trend[0] = price[1] - price[0] if n > 1 else 0
        forecast[0] = level[0] + trend[0]
        for i in range(1, n):
            level[i] = self.alpha * price[i] + (1 - self.alpha) * (level[i - 1] + trend[i - 1])
            trend[i] = self.beta * (level[i] - level[i - 1]) + (1 - self.beta) * trend[i - 1]
            forecast[i] = level[i] + trend[i]
        self.hwma = pd.Series(forecast, index=df.index)
        return self.hwma

    def calculate_scores_crossover_strategy(self, df):
        if self.hwma is None:
            self.compute_values(df)
        price_prev = df['Close'].shift(1)
        hwma_prev = self.hwma.shift(1)
        price_current = df['Close']
        hwma_current = self.hwma
        cond_bull = (price_prev < hwma_prev) & (price_current >= hwma_current)
        cond_bear = (price_prev > hwma_prev) & (price_current <= hwma_current)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def crossover_map(self, series):
        mapping_value = {1: 'Price_Above_HWMA', -1: 'Price_Below_HWMA', 0: 'Price_Near_HWMA'}
        mapping_explanation = {
            1: 'Price crossed above the Holt-Winters Moving Average, indicating bullish momentum.',
            -1: 'Price crossed below the Holt-Winters Moving Average, indicating bearish momentum.',
            0: 'Price remains near the Holt-Winters Moving Average, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_crossover_strategy(df)
        value, explanation = self.crossover_map(score)
        column_prefix = 'HWMA_Crossover_Signal'
        if append:
            if ta_indicator_value:
                hwma_values = self.compute_values(df)
                df['HWMA'] = hwma_values
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['HWMA'] = self.hwma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.hwma is None:
            self.compute_values(df)
        slope = self.hwma.diff()
        signals = np.where(slope > 0, 1, np.where(slope < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'HWMA_Rising', -1: 'HWMA_Falling', 0: 'HWMA_Flat'}
        mapping_explanation = {
            1: 'The Holt-Winters Moving Average is rising, suggesting increasing bullish momentum.',
            -1: 'The Holt-Winters Moving Average is falling, suggesting increasing bearish momentum.',
            0: 'The Holt-Winters Moving Average is flat, indicating neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'HWMA_Slope_Signal'
        if append:
            if ta_indicator_value:
                hwma_values = self.compute_values(df)
                df['HWMA'] = hwma_values
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['HWMA'] = self.hwma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_deviation_strategy(self, df):
        if self.hwma is None:
            self.compute_values(df)
        deviation = ((df['Close'] - self.hwma) / self.hwma) * 100
        cond_bull = deviation > self.deviation_percent_threshold
        cond_bear = deviation < -self.deviation_percent_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def deviation_map(self, series):
        mapping_value = {1: 'Price_Above_HWMA', -1: 'Price_Below_HWMA', 0: 'Price_Near_HWMA'}
        mapping_explanation = {
            1: f'Price is significantly above the Holt-Winters Moving Average by more than {self.deviation_percent_threshold}%, indicating bullish conditions.',
            -1: f'Price is significantly below the Holt-Winters Moving Average by more than {self.deviation_percent_threshold}%, indicating bearish conditions.',
            0: 'Price is within a close range of the Holt-Winters Moving Average, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_deviation_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_deviation_strategy(df)
        value, explanation = self.deviation_map(score)
        column_prefix = 'HWMA_Deviation_Signal'
        if append:
            if ta_indicator_value:
                hwma_values = self.compute_values(df)
                df['HWMA'] = hwma_values
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['HWMA'] = self.hwma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_crossover_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_deviation_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class HullExponentialMovingAverageStrategies:
    def __init__(self, period=14, deviation_percent_threshold=2.0):
        self.period = period
        self.deviation_percent_threshold = deviation_percent_threshold
        self.hema = None

    def compute_ema(self, series, period):
        multiplier = 2 / (period + 1)
        ema = [series.iloc[0]]
        for i in range(1, len(series)):
            ema.append((series.iloc[i] - ema[-1]) * multiplier + ema[-1])
        return pd.Series(ema, index=series.index)

    def compute_values(self, df):
        period_half = max(1, int(round(self.period / 2)))
        period_sqrt = max(1, int(round(self.period ** 0.5)))
        ema_half = self.compute_ema(df['Close'], period_half)
        ema_full = self.compute_ema(df['Close'], self.period)
        intermediate = 2 * ema_half - ema_full
        hema = self.compute_ema(intermediate, period_sqrt)
        self.hema = hema
        return self.hema

    def calculate_scores_crossover_strategy(self, df):
        if self.hema is None:
            self.compute_values(df)
        price_prev = df['Close'].shift(1)
        hema_prev = self.hema.shift(1)
        price_current = df['Close']
        hema_current = self.hema
        cond_bull = (price_prev < hema_prev) & (price_current >= hema_current)
        cond_bear = (price_prev > hema_prev) & (price_current <= hema_current)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def crossover_map(self, series):
        mapping_value = {1: 'Price_Above_HEMA', -1: 'Price_Below_HEMA', 0: 'Price_Near_HEMA'}
        mapping_explanation = {
            1: 'Price crossed above the Hull Exponential Moving Average, indicating bullish momentum.',
            -1: 'Price crossed below the Hull Exponential Moving Average, indicating bearish momentum.',
            0: 'No significant crossover detected between price and the Hull Exponential Moving Average.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_crossover_strategy(df)
        value, explanation = self.crossover_map(score)
        column_prefix = 'HEMA_Crossover_Signal'
        if append:
            if ta_indicator_value:
                hema_values = self.compute_values(df)
                df['HEMA'] = hema_values
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['HEMA'] = self.hema
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.hema is None:
            self.compute_values(df)
        slope = self.hema.diff()
        signals = np.where(slope > 0, 1, np.where(slope < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'HEMA_Rising', -1: 'HEMA_Falling', 0: 'HEMA_Flat'}
        mapping_explanation = {
            1: 'The Hull Exponential Moving Average is rising, indicating increasing bullish momentum.',
            -1: 'The Hull Exponential Moving Average is falling, indicating increasing bearish momentum.',
            0: 'The Hull Exponential Moving Average is flat, indicating neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'HEMA_Slope_Signal'
        if append:
            if ta_indicator_value:
                hema_values = self.compute_values(df)
                df['HEMA'] = hema_values
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['HEMA'] = self.hema
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_deviation_strategy(self, df):
        if self.hema is None:
            self.compute_values(df)
        deviation = ((df['Close'] - self.hema) / self.hema) * 100
        cond_bull = deviation > self.deviation_percent_threshold
        cond_bear = deviation < -self.deviation_percent_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def deviation_map(self, series):
        mapping_value = {1: 'Price_Above_HEMA', -1: 'Price_Below_HEMA', 0: 'Price_Near_HEMA'}
        mapping_explanation = {
            1: f'Price is significantly above the Hull Exponential Moving Average by more than {self.deviation_percent_threshold}%, indicating bullish conditions.',
            -1: f'Price is significantly below the Hull Exponential Moving Average by more than {self.deviation_percent_threshold}%, indicating bearish conditions.',
            0: 'Price is close to the Hull Exponential Moving Average, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_deviation_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_deviation_strategy(df)
        value, explanation = self.deviation_map(score)
        column_prefix = 'HEMA_Deviation_Signal'
        if append:
            if ta_indicator_value:
                hema_values = self.compute_values(df)
                df['HEMA'] = hema_values
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['HEMA'] = self.hema
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_crossover_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_deviation_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


  
class HullMovingAverageStrategies:
    def __init__(self, period=14, price_threshold=0.01):
        self.period = period
        self.price_threshold = price_threshold
        self.hma = None

    def wma(self, series, window):
        return series.rolling(window=window, min_periods=1).apply(lambda x: (np.dot(x, np.arange(1, len(x)+1)))/np.sum(np.arange(1, len(x)+1)), raw=True)

    def compute_values(self, df):
        half_period = max(1, int(round(self.period / 2)))
        sqrt_period = max(1, int(round(np.sqrt(self.period))))
        wma_full = self.wma(df['Close'], self.period)
        wma_half = self.wma(df['Close'], half_period)
        intermediate = 2 * wma_half - wma_full
        self.hma = self.wma(intermediate, sqrt_period)
        return self.hma

    def calculate_scores_price_cross_strategy(self, df):
        if self.hma is None:
            self.compute_values(df)
        close = df['Close']
        hma_prev = self.hma.shift(1)
        close_prev = close.shift(1)
        cond_bull = (close_prev <= hma_prev) & (close > self.hma)
        cond_bear = (close_prev >= hma_prev) & (close < self.hma)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def price_cross_map(self, series):
        mapping_value = {1: 'Price_Above_HMA', -1: 'Price_Below_HMA', 0: 'Price_Neutral'}
        mapping_explanation = {
            1: 'Closing price crossed above HMA, indicating bullish conditions.',
            -1: 'Closing price crossed below HMA, indicating bearish conditions.',
            0: 'No significant crossover between closing price and HMA.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = f'HMA_Period:{self.period}_PriceCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'HMA_Period:{self.period}_TA_Indicator_Value'] = self.hma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'HMA_Period:{self.period}_TA_Indicator_Value'] = self.hma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.hma is None:
            self.compute_values(df)
        diff = self.hma.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'HMA_Rising', -1: 'HMA_Falling', 0: 'HMA_Unchanged'}
        mapping_explanation = {
            1: 'HMA is rising, suggesting bullish momentum.',
            -1: 'HMA is falling, suggesting bearish momentum.',
            0: 'HMA remains unchanged, suggesting neutral trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'HMA_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'HMA_Period:{self.period}_TA_Indicator_Value'] = self.hma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'HMA_Period:{self.period}_TA_Indicator_Value'] = self.hma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_distance_strategy(self, df):
        if self.hma is None:
            self.compute_values(df)
        diff = (df['Close'] - self.hma) / self.hma
        signals = np.where(diff > self.price_threshold, 1, np.where(diff < -self.price_threshold, -1, 0))
        return pd.Series(signals, index=df.index)

    def distance_map(self, series):
        mapping_value = {1: 'Price_Much_Above_HMA', -1: 'Price_Much_Below_HMA', 0: 'Price_Close_to_HMA'}
        mapping_explanation = {
            1: f'Closing price is above HMA by more than {self.price_threshold * 100}%, indicating bullish momentum.',
            -1: f'Closing price is below HMA by more than {self.price_threshold * 100}%, indicating bearish momentum.',
            0: f'Closing price is within {self.price_threshold * 100}% of HMA, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_distance_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_distance_strategy(df)
        value, explanation = self.distance_map(score)
        column_prefix = f'HMA_Period:{self.period}_Distance_Signal'
        if append:
            if ta_indicator_value:
                df[f'HMA_Period:{self.period}_TA_Indicator_Value'] = self.hma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'HMA_Period:{self.period}_TA_Indicator_Value'] = self.hma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_distance_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class IchimokuCloudStrategies:
    def __init__(self, conversion_line_period=9, base_line_period=26, leading_span_b_period=52, displacement=26):
        self.conversion_line_period = conversion_line_period
        self.base_line_period = base_line_period
        self.leading_span_b_period = leading_span_b_period
        self.displacement = displacement
        self.ichimoku = None

    def compute_values(self, df):
        tenkan = (df['High'].rolling(window=self.conversion_line_period, min_periods=1).max() + df['Low'].rolling(window=self.conversion_line_period, min_periods=1).min()) / 2
        kijun = (df['High'].rolling(window=self.base_line_period, min_periods=1).max() + df['Low'].rolling(window=self.base_line_period, min_periods=1).min()) / 2
        senkouA = ((tenkan + kijun) / 2).shift(self.displacement)
        senkouB = ((df['High'].rolling(window=self.leading_span_b_period, min_periods=1).max() + df['Low'].rolling(window=self.leading_span_b_period, min_periods=1).min()) / 2).shift(self.displacement)
        self.ichimoku = {'tenkan': tenkan, 'kijun': kijun, 'senkouA': senkouA, 'senkouB': senkouB}
        return self.ichimoku

    def calculate_scores_price_cloud_strategy(self, df):
        if self.ichimoku is None:
            self.compute_values(df)
        senkouA = self.ichimoku['senkouA']
        senkouB = self.ichimoku['senkouB']
        upper_cloud = np.maximum(senkouA, senkouB)
        lower_cloud = np.minimum(senkouA, senkouB)
        close = df['Close']
        signals = np.where(close > upper_cloud, 1, np.where(close < lower_cloud, -1, 0))
        return pd.Series(signals, index=df.index)

    def price_cloud_map(self, series):
        mapping_value = {1: 'Price_Above_Cloud', -1: 'Price_Below_Cloud', 0: 'Price_Within_Cloud'}
        mapping_explanation = {
            1: 'The closing price is above the cloud, indicating strong bullish conditions.',
            -1: 'The closing price is below the cloud, indicating strong bearish conditions.',
            0: 'The closing price is within the cloud, indicating a neutral or indecisive market.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cloud_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cloud_strategy(df)
        value, explanation = self.price_cloud_map(score)
        column_prefix = f'Ichimoku_Cloud_Conv:{self.conversion_line_period}_Base:{self.base_line_period}_PriceCloud_Signal'
        if append:
            if ta_indicator_value:
                df[f'Ichimoku_TA_Indicator'] = self.ichimoku['tenkan']
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Ichimoku_TA_Indicator'] = self.ichimoku['tenkan']
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_tenkan_kijun_strategy(self, df):
        if self.ichimoku is None:
            self.compute_values(df)
        tenkan = self.ichimoku['tenkan']
        kijun = self.ichimoku['kijun']
        tenkan_prev = tenkan.shift(1)
        kijun_prev = kijun.shift(1)
        signals = np.select([ (tenkan_prev <= kijun_prev) & (tenkan > kijun),
                              (tenkan_prev >= kijun_prev) & (tenkan < kijun) ], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def tenkan_kijun_map(self, series):
        mapping_value = {1: 'Tenkan_Above_Kijun', -1: 'Tenkan_Below_Kijun', 0: 'No_Crossover'}
        mapping_explanation = {
            1: 'Tenkan-Sen has crossed above Kijun-Sen, suggesting bullish momentum.',
            -1: 'Tenkan-Sen has crossed below Kijun-Sen, suggesting bearish momentum.',
            0: 'No significant crossover between Tenkan-Sen and Kijun-Sen detected.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_tenkan_kijun_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_tenkan_kijun_strategy(df)
        value, explanation = self.tenkan_kijun_map(score)
        column_prefix = f'Ichimoku_Cloud_Conv:{self.conversion_line_period}_Base:{self.base_line_period}_TenkanKijun_Signal'
        if append:
            if ta_indicator_value:
                df[f'Ichimoku_TA_Indicator'] = self.ichimoku['tenkan']
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Ichimoku_TA_Indicator'] = self.ichimoku['tenkan']
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_chikou_span_strategy(self, df):
        displacement = self.displacement
        close = df['Close']
        past_close = close.shift(displacement)
        signals = np.where(close > past_close, 1, np.where(close < past_close, -1, 0))
        return pd.Series(signals, index=df.index)

    def chikou_span_map(self, series):
        mapping_value = {1: 'Chikou_Above_Price', -1: 'Chikou_Below_Price', 0: 'Chikou_Neutral'}
        mapping_explanation = {
            1: f'The current closing price is higher than the closing price {self.displacement} periods ago, confirming bullish momentum.',
            -1: f'The current closing price is lower than the closing price {self.displacement} periods ago, confirming bearish momentum.',
            0: f'The current closing price is equal to the closing price {self.displacement} periods ago, indicating neutrality.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_chikou_span_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_chikou_span_strategy(df)
        value, explanation = self.chikou_span_map(score)
        column_prefix = f'Ichimoku_Cloud_ChikouSpan_Signal'
        if append:
            if ta_indicator_value:
                df[f'Ichimoku_Chikou_Value'] = df['Close']
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Ichimoku_Chikou_Value'] = df['Close']
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_cloud_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_tenkan_kijun_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_chikou_span_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class IncreasingPriceStrategies:
    def __init__(self, period=14, baseline=0, lower_threshold=-2, upper_threshold=2):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold

    def compute_values(self, df):
        ip = ((df['Close'] - df['Close'].shift(self.period)) / df['Close'].shift(self.period)) * 100
        self.increasing_price = pd.Series(ip, index=df.index)
        return self.increasing_price

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'increasing_price') or self.increasing_price is None:
            self.increasing_price = self.compute_values(df)
        ip_prev = self.increasing_price.shift(1)
        cond_bull = (ip_prev <= self.baseline) & (self.increasing_price > self.baseline)
        cond_bear = (ip_prev >= self.baseline) & (self.increasing_price < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'IncPrice_Above_Baseline', -1: 'IncPrice_Below_Baseline', 0: 'IncPrice_Neutral'}
        mapping_explanation = {
            1: f'IncreasingPrice crossed above the baseline of {self.baseline}, indicating a bullish trend.',
            -1: f'IncreasingPrice crossed below the baseline of {self.baseline}, indicating a bearish trend.',
            0: f'IncreasingPrice remains around the baseline of {self.baseline}, indicating neutral price movement.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'IncPrice_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'IncPrice_Period:{self.period}_TA_Indicator_Value'] = self.increasing_price
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'IncPrice_Period:{self.period}_TA_Indicator_Value'] = self.increasing_price
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'increasing_price') or self.increasing_price is None:
            self.increasing_price = self.compute_values(df)
        cond_bull = self.increasing_price > self.upper_threshold
        cond_bear = self.increasing_price < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'IncPrice_High', -1: 'IncPrice_Low', 0: 'IncPrice_Moderate'}
        mapping_explanation = {
            1: f'IncreasingPrice is above the upper threshold of {self.upper_threshold}, indicating strong price appreciation.',
            -1: f'IncreasingPrice is below the lower threshold of {self.lower_threshold}, indicating strong price depreciation.',
            0: f'IncreasingPrice is between {self.lower_threshold} and {self.upper_threshold}, indicating moderate price movement.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'IncPrice_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'IncPrice_Period:{self.period}_TA_Indicator_Value'] = self.increasing_price
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'IncPrice_Period:{self.period}_TA_Indicator_Value'] = self.increasing_price
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'increasing_price') or self.increasing_price is None:
            self.increasing_price = self.compute_values(df)
        diff = self.increasing_price.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'IncPrice_Rising', -1: 'IncPrice_Falling', 0: 'IncPrice_Unchanged'}
        mapping_explanation = {
            1: 'IncreasingPrice is rising, indicating accelerating price gains.',
            -1: 'IncreasingPrice is falling, indicating accelerating price losses.',
            0: 'IncreasingPrice remains unchanged, indicating stable price trends.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'IncPrice_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'IncPrice_Period:{self.period}_TA_Indicator_Value'] = self.increasing_price
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'IncPrice_Period:{self.period}_TA_Indicator_Value'] = self.increasing_price
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)




  
  
class InertiaStrategies:
    def __init__(self, period=14, threshold=0.0, acceleration_threshold=0.0):
        self.period = period
        self.threshold = threshold
        self.acceleration_threshold = acceleration_threshold
        self.inertia = None

    def compute_values(self, df):
        self.inertia = df['Close'].diff().rolling(window=self.period, min_periods=1).mean()
        return self.inertia

    def calculate_scores_zero_cross_strategy(self, df):
        if self.inertia is None:
            self.compute_values(df)
        inertia_prev = self.inertia.shift(1)
        cond_bull = (inertia_prev <= 0) & (self.inertia > 0)
        cond_bear = (inertia_prev >= 0) & (self.inertia < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Inertia_Positive_Cross', -1: 'Inertia_Negative_Cross', 0: 'Inertia_Neutral'}
        mapping_explanation = {
            1: 'Inertia has crossed from negative to positive, indicating a potential bullish reversal.',
            -1: 'Inertia has crossed from positive to negative, indicating a potential bearish reversal.',
            0: 'No significant zero-cross event detected in inertia.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'Inertia_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'Inertia_Period:{self.period}_TA_Indicator_Value'] = self.inertia
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Inertia_Period:{self.period}_TA_Indicator_Value'] = self.inertia
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.inertia is None:
            self.compute_values(df)
        cond_bull = self.inertia > self.threshold
        cond_bear = self.inertia < -self.threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Inertia_Above_Threshold', -1: 'Inertia_Below_Threshold', 0: 'Inertia_Within_Threshold'}
        mapping_explanation = {
            1: f'Inertia is above the threshold of {self.threshold}, suggesting sustained bullish momentum.',
            -1: f'Inertia is below the negative threshold of {-self.threshold}, suggesting sustained bearish momentum.',
            0: f'Inertia is within the threshold range of -{self.threshold} to {self.threshold}, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'Inertia_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'Inertia_Period:{self.period}_TA_Indicator_Value'] = self.inertia
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Inertia_Period:{self.period}_TA_Indicator_Value'] = self.inertia
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_acceleration_strategy(self, df):
        if self.inertia is None:
            self.compute_values(df)
        acceleration = self.inertia.diff()
        signals = np.where(acceleration > self.acceleration_threshold, 1, np.where(acceleration < -self.acceleration_threshold, -1, 0))
        return pd.Series(signals, index=df.index)

    def acceleration_map(self, series):
        mapping_value = {1: 'Acceleration_Positive', -1: 'Acceleration_Negative', 0: 'Acceleration_Neutral'}
        mapping_explanation = {
            1: 'The inertia acceleration is positive, indicating that bullish momentum is increasing.',
            -1: 'The inertia acceleration is negative, indicating that bearish momentum is increasing.',
            0: 'There is no significant acceleration in inertia, indicating stable momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_acceleration_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_acceleration_strategy(df)
        value, explanation = self.acceleration_map(score)
        column_prefix = f'Inertia_Period:{self.period}_Acceleration_Signal'
        if append:
            if ta_indicator_value:
                df[f'Inertia_Period:{self.period}_TA_Indicator_Value'] = self.inertia
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Inertia_Period:{self.period}_TA_Indicator_Value'] = self.inertia
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_acceleration_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class InverseFisherTransformRSIStrategies:
    def __init__(self, rsi_period=14, upper_threshold=0.5, lower_threshold=-0.5):
        self.rsi_period = rsi_period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.ift_rsi = None

    def compute_values(self, df):
        delta = df['Close'].diff()
        gain = np.where(delta > 0, delta, 0)
        loss = np.where(delta < 0, -delta, 0)
        avg_gain = pd.Series(gain).rolling(window=self.rsi_period, min_periods=1).mean()
        avg_loss = pd.Series(loss).rolling(window=self.rsi_period, min_periods=1).mean()
        rs = np.where(avg_loss == 0, np.inf, avg_gain / avg_loss)
        rsi = 100 - (100 / (1 + rs))
        x = 0.1 * (rsi - 50)
        ift = (np.exp(2 * x) - 1) / (np.exp(2 * x) + 1)
        self.ift_rsi = pd.Series(ift, index=df.index)
        return self.ift_rsi

    def calculate_scores_zero_cross_strategy(self, df):
        if self.ift_rsi is None:
            self.compute_values(df)
        ift_prev = self.ift_rsi.shift(1)
        cond_bull = (ift_prev <= 0) & (self.ift_rsi > 0)
        cond_bear = (ift_prev >= 0) & (self.ift_rsi < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'IFT_RSI_Cross_Above_Zero', -1: 'IFT_RSI_Cross_Below_Zero', 0: 'IFT_RSI_Neutral'}
        mapping_explanation = {
            1: 'The Inverse Fisher Transform RSI crossed above zero, suggesting bullish momentum.',
            -1: 'The Inverse Fisher Transform RSI crossed below zero, suggesting bearish momentum.',
            0: 'No zero-cross event detected in the Inverse Fisher Transform RSI.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'IFT_RSI_Period:{self.rsi_period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'IFT_RSI_Period:{self.rsi_period}_TA_Indicator_Value'] = self.ift_rsi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'IFT_RSI_Period:{self.rsi_period}_TA_Indicator_Value'] = self.ift_rsi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.ift_rsi is None:
            self.compute_values(df)
        cond_bull = self.ift_rsi > self.upper_threshold
        cond_bear = self.ift_rsi < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'IFT_RSI_Above_Upper', -1: 'IFT_RSI_Below_Lower', 0: 'IFT_RSI_Neutral'}
        mapping_explanation = {
            1: f'The Inverse Fisher Transform RSI is above {self.upper_threshold}, indicating strong bullish conditions.',
            -1: f'The Inverse Fisher Transform RSI is below {self.lower_threshold}, indicating strong bearish conditions.',
            0: 'The Inverse Fisher Transform RSI is between the defined thresholds, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'IFT_RSI_Period:{self.rsi_period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'IFT_RSI_Period:{self.rsi_period}_TA_Indicator_Value'] = self.ift_rsi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'IFT_RSI_Period:{self.rsi_period}_TA_Indicator_Value'] = self.ift_rsi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.ift_rsi is None:
            self.compute_values(df)
        diff = self.ift_rsi.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'IFT_RSI_Rising', -1: 'IFT_RSI_Falling', 0: 'IFT_RSI_Unchanged'}
        mapping_explanation = {
            1: 'The Inverse Fisher Transform RSI is rising, indicating increasing bullish momentum.',
            -1: 'The Inverse Fisher Transform RSI is falling, indicating increasing bearish momentum.',
            0: 'The Inverse Fisher Transform RSI remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'IFT_RSI_Period:{self.rsi_period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'IFT_RSI_Period:{self.rsi_period}_TA_Indicator_Value'] = self.ift_rsi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'IFT_RSI_Period:{self.rsi_period}_TA_Indicator_Value'] = self.ift_rsi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class JurikMovingAverageStrategies:
    def __init__(self, period=20, phase=0.0, power=1.0, distance_threshold=0.01):
        self.period = period
        self.phase = phase
        self.power = power
        self.distance_threshold = distance_threshold
        self.jma = None

    def compute_values(self, df):
        price = df['Close'].values
        vol = pd.Series(price).diff().abs().rolling(window=self.period, min_periods=1).mean().values
        alpha = 2.0 / (self.period + 1)
        adaptive_alpha = alpha * (1 + self.phase * (vol ** self.power))
        jma_array = np.empty_like(price)
        jma_array[0] = price[0]
        for i in range(1, len(price)):
            jma_array[i] = jma_array[i - 1] + adaptive_alpha[i] * (price[i] - jma_array[i - 1])
        self.jma = pd.Series(jma_array, index=df.index)
        return self.jma

    def calculate_scores_price_cross_strategy(self, df):
        if self.jma is None:
            self.compute_values(df)
        price = df['Close']
        jma_prev = self.jma.shift(1)
        price_prev = price.shift(1)
        cond_bull = (price_prev <= jma_prev) & (price > self.jma)
        cond_bear = (price_prev >= jma_prev) & (price < self.jma)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def price_cross_map(self, series):
        mapping_value = {1: 'Price_Above_JMA', -1: 'Price_Below_JMA', 0: 'Price_Near_JMA'}
        mapping_explanation = {
            1: 'The closing price has crossed above the Jurik Moving Average, indicating bullish conditions.',
            -1: 'The closing price has crossed below the Jurik Moving Average, indicating bearish conditions.',
            0: 'The closing price is near the Jurik Moving Average, suggesting no clear trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = f'JMA_Period:{self.period}_PriceCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'JMA_Period:{self.period}_TA_Indicator_Value'] = self.jma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'JMA_Period:{self.period}_TA_Indicator_Value'] = self.jma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.jma is None:
            self.compute_values(df)
        diff = self.jma.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'JMA_Rising', -1: 'JMA_Falling', 0: 'JMA_Flat'}
        mapping_explanation = {
            1: 'The Jurik Moving Average is rising, indicating upward momentum.',
            -1: 'The Jurik Moving Average is falling, indicating downward momentum.',
            0: 'The Jurik Moving Average is flat, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'JMA_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'JMA_Period:{self.period}_TA_Indicator_Value'] = self.jma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'JMA_Period:{self.period}_TA_Indicator_Value'] = self.jma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_distance_strategy(self, df):
        if self.jma is None:
            self.compute_values(df)
        price = df['Close']
        diff = (price - self.jma) / self.jma
        signals = np.where(diff > self.distance_threshold, 1, np.where(diff < -self.distance_threshold, -1, 0))
        return pd.Series(signals, index=df.index)

    def distance_map(self, series):
        mapping_value = {1: 'Price_Significantly_Above_JMA', -1: 'Price_Significantly_Below_JMA', 0: 'Price_Close_to_JMA'}
        mapping_explanation = {
            1: f'The closing price is more than {self.distance_threshold * 100}% above the Jurik Moving Average, indicating strong bullish conditions.',
            -1: f'The closing price is more than {self.distance_threshold * 100}% below the Jurik Moving Average, indicating strong bearish conditions.',
            0: f'The closing price is within {self.distance_threshold * 100}% of the Jurik Moving Average, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_distance_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_distance_strategy(df)
        value, explanation = self.distance_map(score)
        column_prefix = f'JMA_Period:{self.period}_Distance_Signal'
        if append:
            if ta_indicator_value:
                df[f'JMA_Period:{self.period}_TA_Indicator_Value'] = self.jma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'JMA_Period:{self.period}_TA_Indicator_Value'] = self.jma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_distance_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class KDJIndicatorStrategies:
    def __init__(self, period=9, lower_threshold=20, upper_threshold=80):
        self.period = period
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.k = None
        self.d = None
        self.j = None

    def compute_values(self, df):
        k_values = []
        d_values = []
        j_values = []
        k_prev = 50
        d_prev = 50
        for i in range(len(df)):
            window_start = max(0, i - self.period + 1)
            high_max = df['High'].iloc[window_start:i+1].max()
            low_min = df['Low'].iloc[window_start:i+1].min()
            if high_max == low_min:
                rsv = 0
            else:
                rsv = (df['Close'].iloc[i] - low_min) / (high_max - low_min) * 100
            k_curr = (2/3)*k_prev + (1/3)*rsv
            d_curr = (2/3)*d_prev + (1/3)*k_curr
            j_curr = 3*k_curr - 2*d_curr
            k_values.append(k_curr)
            d_values.append(d_curr)
            j_values.append(j_curr)
            k_prev = k_curr
            d_prev = d_curr
        self.k = pd.Series(k_values, index=df.index)
        self.d = pd.Series(d_values, index=df.index)
        self.j = pd.Series(j_values, index=df.index)
        return self.k, self.d, self.j

    def calculate_scores_kd_crossover_strategy(self, df):
        if self.k is None or self.d is None:
            self.compute_values(df)
        k_prev = self.k.shift(1)
        d_prev = self.d.shift(1)
        cond_bull = (k_prev <= d_prev) & (self.k > self.d)
        cond_bear = (k_prev >= d_prev) & (self.k < self.d)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def kd_crossover_map(self, series):
        mapping_value = {1: 'K_Above_D', -1: 'K_Below_D', 0: 'K_D_Neutral'}
        mapping_explanation = {
            1: 'The %K line has crossed above the %D line, indicating a bullish signal.',
            -1: 'The %K line has crossed below the %D line, indicating a bearish signal.',
            0: 'No crossover between %K and %D detected.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_kd_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_kd_crossover_strategy(df)
        value, explanation = self.kd_crossover_map(score)
        column_prefix = f'KDJ_Period:{self.period}_KDCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'KDJ_Period:{self.period}_TA_Indicator_Value'] = self.k
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'KDJ_Period:{self.period}_TA_Indicator_Value'] = self.k
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.j is None:
            self.compute_values(df)
        cond_bull = self.j < self.lower_threshold
        cond_bear = self.j > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'J_Oversold', -1: 'J_Overbought', 0: 'J_Neutral'}
        mapping_explanation = {
            1: f'The %J value is below {self.lower_threshold}, indicating oversold conditions and a potential bullish reversal.',
            -1: f'The %J value is above {self.upper_threshold}, indicating overbought conditions and a potential bearish reversal.',
            0: f'The %J value is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'KDJ_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'KDJ_Period:{self.period}_TA_Indicator_Value'] = self.j
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'KDJ_Period:{self.period}_TA_Indicator_Value'] = self.j
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.k is None:
            self.compute_values(df)
        diff = self.k.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'K_Rising', -1: 'K_Falling', 0: 'K_Flat'}
        mapping_explanation = {
            1: 'The %K line is rising, suggesting increasing bullish momentum.',
            -1: 'The %K line is falling, suggesting increasing bearish momentum.',
            0: 'The %K line remains flat, suggesting neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'KDJ_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'KDJ_Period:{self.period}_TA_Indicator_Value'] = self.k
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'KDJ_Period:{self.period}_TA_Indicator_Value'] = self.k
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_kd_crossover_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class KaufmanAdaptiveMovingAverageStrategies:
    def __init__(self, period=10, fast_period=2, slow_period=30, distance_threshold=0.01):
        self.period = period
        self.fast_period = fast_period
        self.slow_period = slow_period
        self.distance_threshold = distance_threshold
        self.kama = None

    def compute_values(self, df):
        price = df['Close'].values
        n = len(price)
        kama = np.empty(n)
        kama[0] = price[0]
        fastest_sc = 2 / (self.fast_period + 1)
        slowest_sc = 2 / (self.slow_period + 1)
        for i in range(1, n):
            if i < self.period:
                er = 0
            else:
                change = abs(price[i] - price[i - self.period])
                volatility = np.sum(np.abs(np.diff(price[i - self.period:i + 1])))
                er = change / volatility if volatility != 0 else 0
            sc = (er * (fastest_sc - slowest_sc) + slowest_sc) ** 2
            kama[i] = kama[i - 1] + sc * (price[i] - kama[i - 1])
        self.kama = pd.Series(kama, index=df.index)
        return self.kama

    def calculate_scores_price_cross_strategy(self, df):
        if self.kama is None:
            self.compute_values(df)
        price = df['Close']
        kama_prev = self.kama.shift(1)
        price_prev = price.shift(1)
        cond_bull = (price_prev <= kama_prev) & (price > self.kama)
        cond_bear = (price_prev >= kama_prev) & (price < self.kama)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def price_cross_map(self, series):
        mapping_value = {1: 'Price_Above_KAMA', -1: 'Price_Below_KAMA', 0: 'Price_Near_KAMA'}
        mapping_explanation = {
            1: 'The closing price has crossed above the Kaufman Adaptive Moving Average, indicating bullish conditions.',
            -1: 'The closing price has crossed below the Kaufman Adaptive Moving Average, indicating bearish conditions.',
            0: 'No clear crossover between the closing price and the KAMA is detected.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = f'KAMA_Period:{self.period}_PriceCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'KAMA_Period:{self.period}_TA_Indicator_Value'] = self.kama
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'KAMA_Period:{self.period}_TA_Indicator_Value'] = self.kama
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.kama is None:
            self.compute_values(df)
        diff = self.kama.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'KAMA_Rising', -1: 'KAMA_Falling', 0: 'KAMA_Flat'}
        mapping_explanation = {
            1: 'The Kaufman Adaptive Moving Average is rising, indicating upward momentum.',
            -1: 'The Kaufman Adaptive Moving Average is falling, indicating downward momentum.',
            0: 'The Kaufman Adaptive Moving Average is flat, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'KAMA_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'KAMA_Period:{self.period}_TA_Indicator_Value'] = self.kama
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'KAMA_Period:{self.period}_TA_Indicator_Value'] = self.kama
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_distance_strategy(self, df):
        if self.kama is None:
            self.compute_values(df)
        price = df['Close']
        diff = (price - self.kama) / self.kama
        signals = np.where(diff > self.distance_threshold, 1, np.where(diff < -self.distance_threshold, -1, 0))
        return pd.Series(signals, index=df.index)

    def distance_map(self, series):
        mapping_value = {1: 'Price_Significantly_Above_KAMA', -1: 'Price_Significantly_Below_KAMA', 0: 'Price_Close_to_KAMA'}
        mapping_explanation = {
            1: f'The closing price is more than {self.distance_threshold * 100}% above the Kaufman Adaptive Moving Average, indicating strong bullish conditions.',
            -1: f'The closing price is more than {self.distance_threshold * 100}% below the Kaufman Adaptive Moving Average, indicating strong bearish conditions.',
            0: f'The closing price is within {self.distance_threshold * 100}% of the KAMA, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_distance_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_distance_strategy(df)
        value, explanation = self.distance_map(score)
        column_prefix = f'KAMA_Period:{self.period}_Distance_Signal'
        if append:
            if ta_indicator_value:
                df[f'KAMA_Period:{self.period}_TA_Indicator_Value'] = self.kama
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'KAMA_Period:{self.period}_TA_Indicator_Value'] = self.kama
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_distance_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class KaufmanEfficiencyIndicatorStrategies:
    def __init__(self, period=10, baseline=0.5, upper_threshold=0.7, lower_threshold=0.3):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.efficiency = None

    def compute_values(self, df):
        delta = df['Close'].diff()
        abs_delta = delta.abs()
        net_change = (df['Close'] - df['Close'].shift(self.period - 1)).abs()
        sum_abs = abs_delta.rolling(window=self.period, min_periods=1).sum()
        efficiency = net_change / sum_abs
        self.efficiency = pd.Series(efficiency, index=df.index)
        return self.efficiency

    def calculate_scores_zero_cross_strategy(self, df):
        if self.efficiency is None:
            self.compute_values(df)
        eff_prev = self.efficiency.shift(1)
        cond_bull = (eff_prev <= self.baseline) & (self.efficiency > self.baseline)
        cond_bear = (eff_prev >= self.baseline) & (self.efficiency < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Efficiency_Above_Baseline', -1: 'Efficiency_Below_Baseline', 0: 'Efficiency_Neutral'}
        mapping_explanation = {
            1: f'Efficiency Ratio crossed above the baseline of {self.baseline}, indicating a move to a more trending market.',
            -1: f'Efficiency Ratio crossed below the baseline of {self.baseline}, indicating a move to a less trending or choppy market.',
            0: f'Efficiency Ratio remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'KEI_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'KEI_Period:{self.period}_TA_Indicator_Value'] = self.efficiency
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'KEI_Period:{self.period}_TA_Indicator_Value'] = self.efficiency
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.efficiency is None:
            self.compute_values(df)
        cond_bull = self.efficiency > self.upper_threshold
        cond_bear = self.efficiency < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Trending_Efficient', -1: 'Choppy_Market', 0: 'Neutral_Efficiency'}
        mapping_explanation = {
            1: f'Efficiency Ratio is above {self.upper_threshold}, indicating a highly efficient, trending market (potential bullish conditions).',
            -1: f'Efficiency Ratio is below {self.lower_threshold}, indicating a choppy, non-trending market (potential bearish or sideways conditions).',
            0: f'Efficiency Ratio is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral market efficiency.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'KEI_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'KEI_Period:{self.period}_TA_Indicator_Value'] = self.efficiency
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'KEI_Period:{self.period}_TA_Indicator_Value'] = self.efficiency
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.efficiency is None:
            self.compute_values(df)
        diff = self.efficiency.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Efficiency_Rising', -1: 'Efficiency_Falling', 0: 'Efficiency_Unchanged'}
        mapping_explanation = {
            1: 'Efficiency Ratio is rising, suggesting the market is becoming more trending.',
            -1: 'Efficiency Ratio is falling, suggesting the market is becoming less trending.',
            0: 'Efficiency Ratio remains unchanged, indicating stable market efficiency.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'KEI_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'KEI_Period:{self.period}_TA_Indicator_Value'] = self.efficiency
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'KEI_Period:{self.period}_TA_Indicator_Value'] = self.efficiency
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class KeltnerChannelStrategies:
    def __init__(self, period=20, multiplier=2, atr_period=10, distance_threshold=0.0):
        self.period = period
        self.multiplier = multiplier
        self.atr_period = atr_period
        self.distance_threshold = distance_threshold
        self.center = None
        self.upper = None
        self.lower = None

    def compute_values(self, df):
        self.center = df['Close'].ewm(span=self.period, adjust=False).mean()
        tr1 = df['High'] - df['Low']
        tr2 = (df['High'] - df['Close'].shift()).abs()
        tr3 = (df['Low'] - df['Close'].shift()).abs()
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
        atr = tr.rolling(window=self.atr_period, min_periods=1).mean()
        self.upper = self.center + self.multiplier * atr
        self.lower = self.center - self.multiplier * atr
        return {'center': self.center, 'upper': self.upper, 'lower': self.lower, 'atr': atr}

    def calculate_scores_breakout_strategy(self, df):
        if self.upper is None or self.lower is None:
            self.compute_values(df)
        price = df['Close']
        cond_bull = price > self.upper
        cond_bear = price < self.lower
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def breakout_map(self, series):
        mapping_value = {1: 'Price_Above_Upper_Band', -1: 'Price_Below_Lower_Band', 0: 'Price_Within_Channel'}
        mapping_explanation = {
            1: 'Closing price is above the upper band of the Keltner Channel, indicating a bullish breakout.',
            -1: 'Closing price is below the lower band of the Keltner Channel, indicating a bearish breakout.',
            0: 'Closing price is within the channel, indicating no breakout.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_breakout_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_breakout_strategy(df)
        value, explanation = self.breakout_map(score)
        column_prefix = f'KeltnerChannel_Breakout_Signal'
        if append:
            if ta_indicator_value:
                computed = self.compute_values(df)
                df[f'KeltnerChannel_Center'] = computed['center']
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'KeltnerChannel_Center'] = self.center
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_middle_cross_strategy(self, df):
        if self.center is None:
            self.compute_values(df)
        price = df['Close']
        center_prev = self.center.shift(1)
        price_prev = price.shift(1)
        cond_bull = (price_prev <= center_prev) & (price > self.center)
        cond_bear = (price_prev >= center_prev) & (price < self.center)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def middle_cross_map(self, series):
        mapping_value = {1: 'Price_Crossed_Above_Center', -1: 'Price_Crossed_Below_Center', 0: 'No_Cross'}
        mapping_explanation = {
            1: 'Price crossed above the center line (EMA), indicating a bullish signal.',
            -1: 'Price crossed below the center line (EMA), indicating a bearish signal.',
            0: 'No crossover with the center line detected.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_middle_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_middle_cross_strategy(df)
        value, explanation = self.middle_cross_map(score)
        column_prefix = f'KeltnerChannel_MiddleCross_Signal'
        if append:
            if ta_indicator_value:
                computed = self.compute_values(df)
                df[f'KeltnerChannel_Center'] = computed['center']
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'KeltnerChannel_Center'] = self.center
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.center is None:
            self.compute_values(df)
        diff = self.center.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Center_Rising', -1: 'Center_Falling', 0: 'Center_Flat'}
        mapping_explanation = {
            1: 'The center line is rising, suggesting upward momentum.',
            -1: 'The center line is falling, suggesting downward momentum.',
            0: 'The center line is flat, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'KeltnerChannel_Slope_Signal'
        if append:
            if ta_indicator_value:
                computed = self.compute_values(df)
                df[f'KeltnerChannel_Center'] = computed['center']
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'KeltnerChannel_Center'] = self.center
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_breakout_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_middle_cross_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class KlingerVolumeOscillatorStrategies:
    def __init__(self, fast_period=34, slow_period=55, distance_threshold=0.0):
        self.fast_period = fast_period
        self.slow_period = slow_period
        self.distance_threshold = distance_threshold
        self.kvo = None

    def compute_values(self, df):
        hl2 = (df['High'] + df['Low']) / 2
        trend = np.where(hl2 > hl2.shift(1), 1, np.where(hl2 < hl2.shift(1), -1, 0))
        vol_force = df['Volume'] * (df['High'] - df['Low']) * trend
        fast_ema = pd.Series(vol_force).ewm(span=self.fast_period, adjust=False).mean()
        slow_ema = pd.Series(vol_force).ewm(span=self.slow_period, adjust=False).mean()
        self.kvo = pd.Series(fast_ema - slow_ema, index=df.index)
        return self.kvo

    def calculate_scores_zero_cross_strategy(self, df):
        if self.kvo is None:
            self.compute_values(df)
        kvo_prev = self.kvo.shift(1)
        cond_bull = (kvo_prev <= 0) & (self.kvo > 0)
        cond_bear = (kvo_prev >= 0) & (self.kvo < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'KVO_Crossed_Above_Zero', -1: 'KVO_Crossed_Below_Zero', 0: 'KVO_Neutral'}
        mapping_explanation = {
            1: 'KVO crossed above zero, indicating bullish momentum.',
            -1: 'KVO crossed below zero, indicating bearish momentum.',
            0: 'KVO remains near zero, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'KVO_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'KVO_TA_Indicator_Value'] = self.kvo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'KVO_TA_Indicator_Value'] = self.kvo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.kvo is None:
            self.compute_values(df)
        cond_bull = self.kvo > self.distance_threshold
        cond_bear = self.kvo < -self.distance_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'KVO_Above_Threshold', -1: 'KVO_Below_Threshold', 0: 'KVO_Within_Threshold'}
        mapping_explanation = {
            1: f'KVO is above {self.distance_threshold}, indicating strong bullish momentum.',
            -1: f'KVO is below {-self.distance_threshold}, indicating strong bearish momentum.',
            0: f'KVO is within {self.distance_threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'KVO_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'KVO_TA_Indicator_Value'] = self.kvo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'KVO_TA_Indicator_Value'] = self.kvo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.kvo is None:
            self.compute_values(df)
        diff = self.kvo.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'KVO_Rising', -1: 'KVO_Falling', 0: 'KVO_Unchanged'}
        mapping_explanation = {
            1: 'KVO is rising, indicating increasing bullish momentum.',
            -1: 'KVO is falling, indicating increasing bearish momentum.',
            0: 'KVO is unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'KVO_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'KVO_TA_Indicator_Value'] = self.kvo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'KVO_TA_Indicator_Value'] = self.kvo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class KnowSureThingStrategies:
    def __init__(self, roc1_period=10, roc2_period=15, roc3_period=20, roc4_period=30, ma1_period=10, ma2_period=10, ma3_period=10, ma4_period=15, weight1=1, weight2=2, weight3=3, weight4=4, signal_period=9, upper_threshold=0.5, lower_threshold=-0.5):
        self.roc1_period = roc1_period
        self.roc2_period = roc2_period
        self.roc3_period = roc3_period
        self.roc4_period = roc4_period
        self.ma1_period = ma1_period
        self.ma2_period = ma2_period
        self.ma3_period = ma3_period
        self.ma4_period = ma4_period
        self.weight1 = weight1
        self.weight2 = weight2
        self.weight3 = weight3
        self.weight4 = weight4
        self.signal_period = signal_period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.kst = None

    def compute_values(self, df):
        roc1 = ((df['Close'] / df['Close'].shift(self.roc1_period)) - 1) * 100
        sma_roc1 = pd.Series(roc1).rolling(window=self.ma1_period, min_periods=1).mean()
        roc2 = ((df['Close'] / df['Close'].shift(self.roc2_period)) - 1) * 100
        sma_roc2 = pd.Series(roc2).rolling(window=self.ma2_period, min_periods=1).mean()
        roc3 = ((df['Close'] / df['Close'].shift(self.roc3_period)) - 1) * 100
        sma_roc3 = pd.Series(roc3).rolling(window=self.ma3_period, min_periods=1).mean()
        roc4 = ((df['Close'] / df['Close'].shift(self.roc4_period)) - 1) * 100
        sma_roc4 = pd.Series(roc4).rolling(window=self.ma4_period, min_periods=1).mean()
        self.kst = (self.weight1 * sma_roc1) + (self.weight2 * sma_roc2) + (self.weight3 * sma_roc3) + (self.weight4 * sma_roc4)
        return self.kst

    def calculate_scores_zero_cross_strategy(self, df):
        if self.kst is None:
            self.compute_values(df)
        kst_prev = self.kst.shift(1)
        cond_bull = (kst_prev <= 0) & (self.kst > 0)
        cond_bear = (kst_prev >= 0) & (self.kst < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'KST_Cross_Above_Zero', -1: 'KST_Cross_Below_Zero', 0: 'KST_Neutral'}
        mapping_explanation = {
            1: 'KST has crossed above zero, indicating bullish momentum.',
            -1: 'KST has crossed below zero, indicating bearish momentum.',
            0: 'KST remains neutral around zero.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'KST_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'KST_TA_Indicator_Value'] = self.kst
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'KST_TA_Indicator_Value'] = self.kst
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.kst is None:
            self.compute_values(df)
        cond_bull = self.kst > self.upper_threshold
        cond_bear = self.kst < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'KST_Above_Upper', -1: 'KST_Below_Lower', 0: 'KST_Neutral'}
        mapping_explanation = {
            1: f'KST is above {self.upper_threshold}, suggesting strong bullish momentum.',
            -1: f'KST is below {self.lower_threshold}, suggesting strong bearish momentum.',
            0: f'KST is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'KST_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'KST_TA_Indicator_Value'] = self.kst
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'KST_TA_Indicator_Value'] = self.kst
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.kst is None:
            self.compute_values(df)
        diff = self.kst.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'KST_Rising', -1: 'KST_Falling', 0: 'KST_Flat'}
        mapping_explanation = {
            1: 'KST is rising, indicating increasing bullish momentum.',
            -1: 'KST is falling, indicating increasing bearish momentum.',
            0: 'KST remains flat, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'KST_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'KST_TA_Indicator_Value'] = self.kst
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'KST_TA_Indicator_Value'] = self.kst
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class LinearRegressionStrategies:
    def __init__(self, period=14, distance_threshold=0.01):
        self.period = period
        self.distance_threshold = distance_threshold
        self.reg_line = None

    def _linear_regression(self, y):
        n = len(y)
        x = np.arange(n)
        denom = n * np.sum(x**2) - (np.sum(x))**2
        slope = (n * np.dot(x, y) - np.sum(x) * np.sum(y)) / denom if denom != 0 else 0
        intercept = (np.sum(y) - slope * np.sum(x)) / n
        return intercept + slope * (n - 1)

    def compute_values(self, df):
        reg = df['Close'].rolling(window=self.period, min_periods=self.period).apply(lambda y: self._linear_regression(y), raw=True)
        self.reg_line = pd.Series(reg, index=df.index)
        return self.reg_line

    def calculate_scores_price_cross_strategy(self, df):
        if self.reg_line is None:
            self.compute_values(df)
        price = df['Close']
        reg_prev = self.reg_line.shift(1)
        price_prev = price.shift(1)
        cond_bull = (price_prev <= reg_prev) & (price > self.reg_line)
        cond_bear = (price_prev >= reg_prev) & (price < self.reg_line)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def price_cross_map(self, series):
        mapping_value = {1: 'Price_Above_Regression', -1: 'Price_Below_Regression', 0: 'Price_Near_Regression'}
        mapping_explanation = {
            1: 'Closing price has crossed above the regression line, indicating bullish conditions.',
            -1: 'Closing price has crossed below the regression line, indicating bearish conditions.',
            0: 'No crossover detected between the price and the regression line.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = f'LinearRegression_Period:{self.period}_PriceCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'LinearRegression_Period:{self.period}_TA_Indicator_Value'] = self.reg_line
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'LinearRegression_Period:{self.period}_TA_Indicator_Value'] = self.reg_line
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.reg_line is None:
            self.compute_values(df)
        diff = self.reg_line.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Regression_Rising', -1: 'Regression_Falling', 0: 'Regression_Flat'}
        mapping_explanation = {
            1: 'The regression line is rising, indicating an uptrend.',
            -1: 'The regression line is falling, indicating a downtrend.',
            0: 'The regression line is flat, indicating a neutral trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'LinearRegression_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'LinearRegression_Period:{self.period}_TA_Indicator_Value'] = self.reg_line
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'LinearRegression_Period:{self.period}_TA_Indicator_Value'] = self.reg_line
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_distance_strategy(self, df):
        if self.reg_line is None:
            self.compute_values(df)
        price = df['Close']
        diff = (price - self.reg_line) / self.reg_line
        signals = np.where(diff > self.distance_threshold, 1, np.where(diff < -self.distance_threshold, -1, 0))
        return pd.Series(signals, index=df.index)

    def distance_map(self, series):
        mapping_value = {1: 'Price_Significantly_Above_Regression', -1: 'Price_Significantly_Below_Regression', 0: 'Price_Close_to_Regression'}
        mapping_explanation = {
            1: f'Closing price is more than {self.distance_threshold * 100}% above the regression line, indicating strong bullish momentum.',
            -1: f'Closing price is more than {self.distance_threshold * 100}% below the regression line, indicating strong bearish momentum.',
            0: f'Closing price is within {self.distance_threshold * 100}% of the regression line, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_distance_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_distance_strategy(df)
        value, explanation = self.distance_map(score)
        column_prefix = f'LinearRegression_Period:{self.period}_Distance_Signal'
        if append:
            if ta_indicator_value:
                df[f'LinearRegression_Period:{self.period}_TA_Indicator_Value'] = self.reg_line
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'LinearRegression_Period:{self.period}_TA_Indicator_Value'] = self.reg_line
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_distance_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class LinearRegressionAngleStrategies:
    def __init__(self, period=14, upper_threshold=5, lower_threshold=-5, distance_threshold=0.01):
        self.period = period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.distance_threshold = distance_threshold
        self.lr_angle = None

    def _linear_regression_angle(self, y):
        n = len(y)
        x = np.arange(n)
        denom = n * np.sum(x**2) - (np.sum(x))**2
        slope = (n * np.dot(x, y) - np.sum(x) * np.sum(y)) / denom if denom != 0 else 0
        angle = np.degrees(np.arctan(slope))
        return angle

    def compute_values(self, df):
        angles = df['Close'].rolling(window=self.period, min_periods=self.period).apply(lambda y: self._linear_regression_angle(y), raw=True)
        self.lr_angle = pd.Series(angles, index=df.index)
        return self.lr_angle

    def calculate_scores_zero_cross_strategy(self, df):
        if self.lr_angle is None:
            self.compute_values(df)
        angle_prev = self.lr_angle.shift(1)
        cond_bull = (angle_prev <= 0) & (self.lr_angle > 0)
        cond_bear = (angle_prev >= 0) & (self.lr_angle < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Angle_Crossed_Above_Zero', -1: 'Angle_Crossed_Below_Zero', 0: 'Angle_Neutral'}
        mapping_explanation = {
            1: 'The linear regression angle crossed above zero, indicating a shift toward an uptrend.',
            -1: 'The linear regression angle crossed below zero, indicating a shift toward a downtrend.',
            0: 'No zero-cross event detected in the linear regression angle.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'LRAngle_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'LRAngle_Period:{self.period}_TA_Indicator_Value'] = self.lr_angle
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'LRAngle_Period:{self.period}_TA_Indicator_Value'] = self.lr_angle
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.lr_angle is None:
            self.compute_values(df)
        cond_bull = self.lr_angle > self.upper_threshold
        cond_bear = self.lr_angle < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Angle_Above_Upper', -1: 'Angle_Below_Lower', 0: 'Angle_Neutral'}
        mapping_explanation = {
            1: f'The linear regression angle is above {self.upper_threshold}, indicating strong bullish momentum.',
            -1: f'The linear regression angle is below {self.lower_threshold}, indicating strong bearish momentum.',
            0: f'The linear regression angle is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'LRAngle_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'LRAngle_Period:{self.period}_TA_Indicator_Value'] = self.lr_angle
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'LRAngle_Period:{self.period}_TA_Indicator_Value'] = self.lr_angle
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.lr_angle is None:
            self.compute_values(df)
        diff = self.lr_angle.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Angle_Rising', -1: 'Angle_Falling', 0: 'Angle_Flat'}
        mapping_explanation = {
            1: 'The linear regression angle is rising, suggesting increasing bullish momentum.',
            -1: 'The linear regression angle is falling, suggesting increasing bearish momentum.',
            0: 'The linear regression angle remains flat, indicating neutral trend conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'LRAngle_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'LRAngle_Period:{self.period}_TA_Indicator_Value'] = self.lr_angle
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'LRAngle_Period:{self.period}_TA_Indicator_Value'] = self.lr_angle
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class LinearRegressionInterceptStrategies:
    def __init__(self, period=14, distance_threshold=0.01):
        self.period = period
        self.distance_threshold = distance_threshold
        self.lr_intercept = None

    def _linear_regression_intercept(self, y):
        n = len(y)
        x = np.arange(n)
        denom = n * np.sum(x**2) - (np.sum(x))**2
        slope = (n * np.dot(x, y) - np.sum(x) * np.sum(y)) / denom if denom != 0 else 0
        intercept = (np.sum(y) - slope * np.sum(x)) / n
        return intercept

    def compute_values(self, df):
        intercepts = df['Close'].rolling(window=self.period, min_periods=self.period).apply(lambda y: self._linear_regression_intercept(y), raw=True)
        self.lr_intercept = pd.Series(intercepts, index=df.index)
        return self.lr_intercept

    def calculate_scores_price_cross_strategy(self, df):
        if self.lr_intercept is None:
            self.compute_values(df)
        price = df['Close']
        intercept_prev = self.lr_intercept.shift(1)
        price_prev = price.shift(1)
        cond_bull = (price_prev <= intercept_prev) & (price > self.lr_intercept)
        cond_bear = (price_prev >= intercept_prev) & (price < self.lr_intercept)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def price_cross_map(self, series):
        mapping_value = {1: 'Price_Above_Intercept', -1: 'Price_Below_Intercept', 0: 'Price_Near_Intercept'}
        mapping_explanation = {
            1: 'Closing price crossed above the regression intercept, suggesting bullish conditions.',
            -1: 'Closing price crossed below the regression intercept, suggesting bearish conditions.',
            0: 'No significant crossover between the closing price and regression intercept detected.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = f'LRIntercept_Period:{self.period}_PriceCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'LRIntercept_Period:{self.period}_TA_Indicator_Value'] = self.lr_intercept
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'LRIntercept_Period:{self.period}_TA_Indicator_Value'] = self.lr_intercept
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.lr_intercept is None:
            self.compute_values(df)
        diff = self.lr_intercept.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Intercept_Rising', -1: 'Intercept_Falling', 0: 'Intercept_Stable'}
        mapping_explanation = {
            1: 'The regression intercept is rising, indicating improving support levels and bullish sentiment.',
            -1: 'The regression intercept is falling, indicating weakening support levels and bearish sentiment.',
            0: 'The regression intercept remains stable, suggesting neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'LRIntercept_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'LRIntercept_Period:{self.period}_TA_Indicator_Value'] = self.lr_intercept
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'LRIntercept_Period:{self.period}_TA_Indicator_Value'] = self.lr_intercept
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_distance_strategy(self, df):
        if self.lr_intercept is None:
            self.compute_values(df)
        price = df['Close']
        diff = (price - self.lr_intercept) / self.lr_intercept
        signals = np.where(diff > self.distance_threshold, 1, np.where(diff < -self.distance_threshold, -1, 0))
        return pd.Series(signals, index=df.index)

    def distance_map(self, series):
        mapping_value = {1: 'Price_Significantly_Above_Intercept', -1: 'Price_Significantly_Below_Intercept', 0: 'Price_Near_Intercept'}
        mapping_explanation = {
            1: f'Closing price is more than {self.distance_threshold * 100}% above the regression intercept, indicating strong bullish conditions.',
            -1: f'Closing price is more than {self.distance_threshold * 100}% below the regression intercept, indicating strong bearish conditions.',
            0: f'Closing price is within {self.distance_threshold * 100}% of the regression intercept, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_distance_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_distance_strategy(df)
        value, explanation = self.distance_map(score)
        column_prefix = f'LRIntercept_Period:{self.period}_Distance_Signal'
        if append:
            if ta_indicator_value:
                df[f'LRIntercept_Period:{self.period}_TA_Indicator_Value'] = self.lr_intercept
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'LRIntercept_Period:{self.period}_TA_Indicator_Value'] = self.lr_intercept
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_distance_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class LinearRegressionSlopeStrategies:
    def __init__(self, period=14, threshold=0.0):
        self.period = period
        self.threshold = threshold
        self.slope = None

    def _linear_regression_slope(self, y):
        n = len(y)
        x = np.arange(n)
        denom = n * np.sum(x**2) - (np.sum(x))**2
        slope = (n * np.dot(x, y) - np.sum(x) * np.sum(y)) / denom if denom != 0 else 0
        return slope

    def compute_values(self, df):
        slopes = df['Close'].rolling(window=self.period, min_periods=self.period).apply(lambda y: self._linear_regression_slope(y), raw=True)
        self.slope = pd.Series(slopes, index=df.index)
        return self.slope

    def calculate_scores_zero_cross_strategy(self, df):
        if self.slope is None:
            self.compute_values(df)
        slope_prev = self.slope.shift(1)
        cond_bull = (slope_prev <= 0) & (self.slope > 0)
        cond_bear = (slope_prev >= 0) & (self.slope < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Slope_Crossed_Above_Zero', -1: 'Slope_Crossed_Below_Zero', 0: 'Slope_Neutral'}
        mapping_explanation = {
            1: 'The linear regression slope crossed above zero, indicating a potential bullish trend reversal.',
            -1: 'The linear regression slope crossed below zero, indicating a potential bearish trend reversal.',
            0: 'No significant zero-cross event in the slope detected.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'LR_Slope_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'LR_Slope_Period:{self.period}_TA_Indicator_Value'] = self.slope
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'LR_Slope_Period:{self.period}_TA_Indicator_Value'] = self.slope
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.slope is None:
            self.compute_values(df)
        cond_bull = self.slope > self.threshold
        cond_bear = self.slope < -self.threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Slope_Above_Threshold', -1: 'Slope_Below_Threshold', 0: 'Slope_Neutral'}
        mapping_explanation = {
            1: f'The slope is above {self.threshold}, indicating strong bullish momentum.',
            -1: f'The slope is below -{self.threshold}, indicating strong bearish momentum.',
            0: f'The slope is between -{self.threshold} and {self.threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'LR_Slope_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'LR_Slope_Period:{self.period}_TA_Indicator_Value'] = self.slope
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'LR_Slope_Period:{self.period}_TA_Indicator_Value'] = self.slope
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_acceleration_strategy(self, df):
        if self.slope is None:
            self.compute_values(df)
        acceleration = self.slope.diff()
        signals = np.where(acceleration > 0, 1, np.where(acceleration < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def acceleration_map(self, series):
        mapping_value = {1: 'Slope_Accelerating', -1: 'Slope_Decelerating', 0: 'Slope_Stable'}
        mapping_explanation = {
            1: 'The acceleration (change in slope) is positive, indicating that bullish momentum is increasing.',
            -1: 'The acceleration is negative, indicating that bearish momentum is increasing.',
            0: 'No significant acceleration in slope, indicating stable conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_acceleration_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_acceleration_strategy(df)
        value, explanation = self.acceleration_map(score)
        column_prefix = f'LR_Slope_Period:{self.period}_Acceleration_Signal'
        if append:
            if ta_indicator_value:
                df[f'LR_Slope_Period:{self.period}_TA_Indicator_Value'] = self.slope
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'LR_Slope_Period:{self.period}_TA_Indicator_Value'] = self.slope
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_acceleration_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class LongRunStrategies:
    def __init__(self, period=200, baseline=0.0, upper_threshold=0.05, lower_threshold=-0.05):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.longrun = None

    def compute_values(self, df):
        ma = df['Close'].rolling(window=self.period, min_periods=self.period).mean()
        self.longrun = (df['Close'] - ma) / ma
        return self.longrun

    def calculate_scores_zero_cross_strategy(self, df):
        if self.longrun is None:
            self.compute_values(df)
        lr_prev = self.longrun.shift(1)
        cond_bull = (lr_prev <= self.baseline) & (self.longrun > self.baseline)
        cond_bear = (lr_prev >= self.baseline) & (self.longrun < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Price_Above_LongRun', -1: 'Price_Below_LongRun', 0: 'Neutral_LongRun'}
        mapping_explanation = {
            1: 'Price has crossed above its long-run average, indicating a bullish long-term regime.',
            -1: 'Price has crossed below its long-run average, indicating a bearish long-term regime.',
            0: 'No significant crossover relative to the long-run average.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'LongRun_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'LongRun_Period:{self.period}_TA_Indicator_Value'] = self.longrun
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'LongRun_Period:{self.period}_TA_Indicator_Value'] = self.longrun
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.longrun is None:
            self.compute_values(df)
        cond_bull = self.longrun > self.upper_threshold
        cond_bear = self.longrun < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'LongRun_Overbought', -1: 'LongRun_Oversold', 0: 'LongRun_Neutral'}
        mapping_explanation = {
            1: f'Price is more than {self.upper_threshold*100:.1f}% above its long-run average, indicating strong bullish momentum.',
            -1: f'Price is more than {abs(self.lower_threshold)*100:.1f}% below its long-run average, indicating strong bearish momentum.',
            0: 'Price is within a neutral range of its long-run average.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'LongRun_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'LongRun_Period:{self.period}_TA_Indicator_Value'] = self.longrun
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'LongRun_Period:{self.period}_TA_Indicator_Value'] = self.longrun
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.longrun is None:
            self.compute_values(df)
        diff = self.longrun.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'LongRun_Rising', -1: 'LongRun_Falling', 0: 'LongRun_Unchanged'}
        mapping_explanation = {
            1: 'The LongRun indicator is rising, indicating increasing long-term bullish strength.',
            -1: 'The LongRun indicator is falling, indicating increasing long-term bearish strength.',
            0: 'The LongRun indicator remains unchanged, suggesting a neutral long-term trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'LongRun_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'LongRun_Period:{self.period}_TA_Indicator_Value'] = self.longrun
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'LongRun_Period:{self.period}_TA_Indicator_Value'] = self.longrun
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class MarkWhistlersWAVEPMStrategies:
    def __init__(self, period=20, upper_threshold=0.7, lower_threshold=-0.7):
        self.period = period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.mark_wavepm = None

    def compute_values(self, df):
        sma = df['Close'].rolling(window=self.period, min_periods=self.period).mean()
        std = df['Close'].rolling(window=self.period, min_periods=self.period).std()
        zscore = (df['Close'] - sma) / std
        self.mark_wavepm = np.sin(zscore)
        return self.mark_wavepm

    def calculate_scores_zero_cross_strategy(self, df):
        if self.mark_wavepm is None:
            self.compute_values(df)
        mw_prev = self.mark_wavepm.shift(1)
        cond_bull = (mw_prev <= 0) & (self.mark_wavepm > 0)
        cond_bear = (mw_prev >= 0) & (self.mark_wavepm < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'WAVEPM_Cross_Above_Zero', -1: 'WAVEPM_Cross_Below_Zero', 0: 'WAVEPM_Neutral'}
        mapping_explanation = {
            1: 'The MarkWhistlersWAVEPM indicator crossed above zero, indicating bullish momentum.',
            -1: 'The MarkWhistlersWAVEPM indicator crossed below zero, indicating bearish momentum.',
            0: 'No zero-cross event detected in the MarkWhistlersWAVEPM indicator.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'WAVEPM_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'WAVEPM_Period:{self.period}_TA_Indicator_Value'] = self.mark_wavepm
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'WAVEPM_Period:{self.period}_TA_Indicator_Value'] = self.mark_wavepm
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.mark_wavepm is None:
            self.compute_values(df)
        cond_bull = self.mark_wavepm > self.upper_threshold
        cond_bear = self.mark_wavepm < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'WAVEPM_Above_Upper', -1: 'WAVEPM_Below_Lower', 0: 'WAVEPM_Neutral'}
        mapping_explanation = {
            1: f'The indicator is above {self.upper_threshold}, suggesting strong bullish momentum.',
            -1: f'The indicator is below {self.lower_threshold}, suggesting strong bearish momentum.',
            0: f'The indicator is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'WAVEPM_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'WAVEPM_Period:{self.period}_TA_Indicator_Value'] = self.mark_wavepm
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'WAVEPM_Period:{self.period}_TA_Indicator_Value'] = self.mark_wavepm
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.mark_wavepm is None:
            self.compute_values(df)
        diff = self.mark_wavepm.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'WAVEPM_Rising', -1: 'WAVEPM_Falling', 0: 'WAVEPM_Flat'}
        mapping_explanation = {
            1: 'The MarkWhistlersWAVEPM indicator is rising, indicating increasing bullish momentum.',
            -1: 'The MarkWhistlersWAVEPM indicator is falling, indicating increasing bearish momentum.',
            0: 'The indicator remains flat, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'WAVEPM_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'WAVEPM_Period:{self.period}_TA_Indicator_Value'] = self.mark_wavepm
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'WAVEPM_Period:{self.period}_TA_Indicator_Value'] = self.mark_wavepm
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class MarketMomentumStrategies:
    def __init__(self, period=14, upper_threshold=0.05, lower_threshold=-0.05):
        self.period = period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.momentum = None

    def compute_values(self, df):
        self.momentum = (df['Close'] / df['Close'].shift(self.period)) - 1
        return self.momentum

    def calculate_scores_zero_cross_strategy(self, df):
        if self.momentum is None:
            self.compute_values(df)
        momentum_prev = self.momentum.shift(1)
        cond_bull = (momentum_prev <= 0) & (self.momentum > 0)
        cond_bear = (momentum_prev >= 0) & (self.momentum < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Momentum_Cross_Above_Zero', -1: 'Momentum_Cross_Below_Zero', 0: 'Momentum_Neutral'}
        mapping_explanation = {
            1: 'The MarketMomentum indicator crossed above zero, indicating a bullish momentum shift.',
            -1: 'The MarketMomentum indicator crossed below zero, indicating a bearish momentum shift.',
            0: 'The MarketMomentum indicator remains neutral relative to zero.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'MarketMomentum_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'MarketMomentum_Period:{self.period}_TA_Indicator_Value'] = self.momentum
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MarketMomentum_Period:{self.period}_TA_Indicator_Value'] = self.momentum
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.momentum is None:
            self.compute_values(df)
        cond_bull = self.momentum > self.upper_threshold
        cond_bear = self.momentum < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Momentum_Above_Upper', -1: 'Momentum_Below_Lower', 0: 'Momentum_Neutral'}
        mapping_explanation = {
            1: f'The MarketMomentum indicator is above {self.upper_threshold*100:.1f}%, suggesting strong bullish momentum.',
            -1: f'The MarketMomentum indicator is below {abs(self.lower_threshold)*100:.1f}%, suggesting strong bearish momentum.',
            0: 'The MarketMomentum indicator is within neutral bounds.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'MarketMomentum_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'MarketMomentum_Period:{self.period}_TA_Indicator_Value'] = self.momentum
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MarketMomentum_Period:{self.period}_TA_Indicator_Value'] = self.momentum
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.momentum is None:
            self.compute_values(df)
        diff = self.momentum.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Momentum_Rising', -1: 'Momentum_Falling', 0: 'Momentum_Flat'}
        mapping_explanation = {
            1: 'The MarketMomentum indicator is rising, indicating increasing bullish momentum.',
            -1: 'The MarketMomentum indicator is falling, indicating increasing bearish momentum.',
            0: 'The MarketMomentum indicator is flat, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'MarketMomentum_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'MarketMomentum_Period:{self.period}_TA_Indicator_Value'] = self.momentum
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MarketMomentum_Period:{self.period}_TA_Indicator_Value'] = self.momentum
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value,
                                                       signal_score=signal_score, signal_value=signal_value,
                                                       signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False,
                                                      signal_score=signal_score, signal_value=signal_value,
                                                      signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False,
                                                  signal_score=signal_score, signal_value=signal_value,
                                                  signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class MassIndexStrategies:
    def __init__(self, period=25, inner_period=9, upper_threshold=27.0, lower_threshold=26.5):
        self.period = period
        self.inner_period = inner_period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.baseline = (upper_threshold + lower_threshold) / 2
        self.mass_index = None

    def compute_values(self, df):
        rng = df['High'] - df['Low']
        ema1 = pd.Series(rng).ewm(span=self.inner_period, adjust=False).mean()
        ema2 = ema1.ewm(span=self.inner_period, adjust=False).mean()
        ratio = ema1 / ema2
        self.mass_index = pd.Series(ratio).rolling(window=self.period, min_periods=1).sum()
        self.mass_index.index = df.index
        return self.mass_index

    def calculate_scores_zero_cross_strategy(self, df):
        if self.mass_index is None:
            self.compute_values(df)
        mi_prev = self.mass_index.shift(1)
        cond_bull = (mi_prev <= self.baseline) & (self.mass_index > self.baseline)
        cond_bear = (mi_prev >= self.baseline) & (self.mass_index < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'MI_Crossed_Above_Baseline', -1: 'MI_Crossed_Below_Baseline', 0: 'MI_Neutral'}
        mapping_explanation = {
            1: f'Mass Index crossed above the baseline of {self.baseline}, indicating potential bullish reversal.',
            -1: f'Mass Index crossed below the baseline of {self.baseline}, indicating potential bearish reversal.',
            0: f'Mass Index remains around the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'MI_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'MI_Period:{self.period}_TA_Indicator_Value'] = self.mass_index
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MI_Period:{self.period}_TA_Indicator_Value'] = self.mass_index
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.mass_index is None:
            self.compute_values(df)
        cond_bull = self.mass_index < self.lower_threshold
        cond_bear = self.mass_index > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'MI_Below_Lower', -1: 'MI_Above_Upper', 0: 'MI_Neutral'}
        mapping_explanation = {
            1: f'Mass Index is below {self.lower_threshold}, suggesting a potential bullish reversal.',
            -1: f'Mass Index is above {self.upper_threshold}, suggesting a potential bearish reversal.',
            0: f'Mass Index is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'MI_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'MI_Period:{self.period}_TA_Indicator_Value'] = self.mass_index
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MI_Period:{self.period}_TA_Indicator_Value'] = self.mass_index
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.mass_index is None:
            self.compute_values(df)
        diff = self.mass_index.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'MI_Rising', -1: 'MI_Falling', 0: 'MI_Flat'}
        mapping_explanation = {
            1: 'Mass Index is rising, suggesting that the volatility range is expanding.',
            -1: 'Mass Index is falling, suggesting that the volatility range is contracting, potentially signaling a reversal.',
            0: 'Mass Index remains flat, indicating neutral volatility conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'MI_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'MI_Period:{self.period}_TA_Indicator_Value'] = self.mass_index
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MI_Period:{self.period}_TA_Indicator_Value'] = self.mass_index
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class McGinleyDynamicStrategies:
    def __init__(self, period=10, threshold=0.01):
        self.period = period
        self.threshold = threshold
        self.mcg_dynamic = None

    def compute_values(self, df):
        prices = df['Close'].values
        mcg = np.empty_like(prices)
        mcg[0] = prices[0]
        for i in range(1, len(prices)):
            prev_val = mcg[i - 1]
            ratio = prices[i] / prev_val if prev_val != 0 else 1
            factor = self.period * (ratio ** 4)
            if factor == 0:
                factor = self.period
            mcg[i] = prev_val + (prices[i] - prev_val) / factor
        self.mcg_dynamic = pd.Series(mcg, index=df.index)
        return self.mcg_dynamic

    def calculate_scores_price_cross_strategy(self, df):
        if self.mcg_dynamic is None:
            self.compute_values(df)
        price = df['Close']
        mcg_prev = self.mcg_dynamic.shift(1)
        price_prev = price.shift(1)
        cond_bull = (price_prev <= mcg_prev) & (price > self.mcg_dynamic)
        cond_bear = (price_prev >= mcg_prev) & (price < self.mcg_dynamic)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def price_cross_map(self, series):
        mapping_value = {1: 'Price_Above_McGinley', -1: 'Price_Below_McGinley', 0: 'Price_Near_McGinley'}
        mapping_explanation = {
            1: 'Price crossed above the McGinley Dynamic, indicating bullish conditions.',
            -1: 'Price crossed below the McGinley Dynamic, indicating bearish conditions.',
            0: 'No significant price crossover with the McGinley Dynamic detected.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = f'McGinleyDynamic_Period:{self.period}_PriceCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'McGinleyDynamic_Period:{self.period}_TA_Indicator_Value'] = self.mcg_dynamic
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'McGinleyDynamic_Period:{self.period}_TA_Indicator_Value'] = self.mcg_dynamic
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.mcg_dynamic is None:
            self.compute_values(df)
        diff = self.mcg_dynamic.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'McGinley_Rising', -1: 'McGinley_Falling', 0: 'McGinley_Flat'}
        mapping_explanation = {
            1: 'The McGinley Dynamic is rising, indicating upward momentum.',
            -1: 'The McGinley Dynamic is falling, indicating downward momentum.',
            0: 'The McGinley Dynamic remains flat, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'McGinleyDynamic_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'McGinleyDynamic_Period:{self.period}_TA_Indicator_Value'] = self.mcg_dynamic
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'McGinleyDynamic_Period:{self.period}_TA_Indicator_Value'] = self.mcg_dynamic
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_distance_strategy(self, df):
        if self.mcg_dynamic is None:
            self.compute_values(df)
        diff_ratio = (df['Close'] - self.mcg_dynamic) / self.mcg_dynamic
        signals = np.where(diff_ratio > self.threshold, 1, np.where(diff_ratio < -self.threshold, -1, 0))
        return pd.Series(signals, index=df.index)

    def distance_map(self, series):
        mapping_value = {1: 'Price_Significantly_Above_McGinley', -1: 'Price_Significantly_Below_McGinley', 0: 'Price_Close_to_McGinley'}
        mapping_explanation = {
            1: f'Price is more than {self.threshold*100:.1f}% above the McGinley Dynamic, indicating strong bullish conditions.',
            -1: f'Price is more than {self.threshold*100:.1f}% below the McGinley Dynamic, indicating strong bearish conditions.',
            0: f'Price is within {self.threshold*100:.1f}% of the McGinley Dynamic, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_distance_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_distance_strategy(df)
        value, explanation = self.distance_map(score)
        column_prefix = f'McGinleyDynamic_Period:{self.period}_Distance_Signal'
        if append:
            if ta_indicator_value:
                df[f'McGinleyDynamic_Period:{self.period}_TA_Indicator_Value'] = self.mcg_dynamic
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'McGinleyDynamic_Period:{self.period}_TA_Indicator_Value'] = self.mcg_dynamic
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_distance_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class MedianPriceStrategies:
    def __init__(self, threshold=0.01):
        self.threshold = threshold
        self.median = None

    def compute_values(self, df):
        self.median = (df['High'] + df['Low']) / 2
        return self.median

    def calculate_scores_price_cross_strategy(self, df):
        if self.median is None:
            self.compute_values(df)
        close = df['Close']
        median_prev = self.median.shift(1)
        close_prev = close.shift(1)
        cond_bull = (close_prev <= median_prev) & (close > self.median)
        cond_bear = (close_prev >= median_prev) & (close < self.median)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def price_cross_map(self, series):
        mapping_value = {1: 'Price_Above_Median', -1: 'Price_Below_Median', 0: 'Price_Neutral'}
        mapping_explanation = {
            1: 'Closing price crossed above the median price, indicating bullish conditions.',
            -1: 'Closing price crossed below the median price, indicating bearish conditions.',
            0: 'Closing price remains near the median price, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = f'MedianPrice_PriceCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'MedianPrice_TA_Indicator_Value'] = self.median
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MedianPrice_TA_Indicator_Value'] = self.median
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.median is None:
            self.compute_values(df)
        diff = self.median.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Median_Rising', -1: 'Median_Falling', 0: 'Median_Flat'}
        mapping_explanation = {
            1: 'The median price is rising, indicating an upward trend in the price range.',
            -1: 'The median price is falling, indicating a downward trend in the price range.',
            0: 'The median price is flat, indicating neutral price movement.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'MedianPrice_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'MedianPrice_TA_Indicator_Value'] = self.median
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MedianPrice_TA_Indicator_Value'] = self.median
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_distance_strategy(self, df):
        if self.median is None:
            self.compute_values(df)
        diff = (df['Close'] - self.median) / self.median
        signals = np.where(diff > self.threshold, 1, np.where(diff < -self.threshold, -1, 0))
        return pd.Series(signals, index=df.index)

    def distance_map(self, series):
        mapping_value = {1: 'Price_Significantly_Above_Median', -1: 'Price_Significantly_Below_Median', 0: 'Price_Close_to_Median'}
        mapping_explanation = {
            1: f'Closing price is more than {self.threshold*100:.1f}% above the median price, indicating strong bullish conditions.',
            -1: f'Closing price is more than {self.threshold*100:.1f}% below the median price, indicating strong bearish conditions.',
            0: f'Closing price is within {self.threshold*100:.1f}% of the median price, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_distance_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_distance_strategy(df)
        value, explanation = self.distance_map(score)
        column_prefix = f'MedianPrice_Distance_Signal'
        if append:
            if ta_indicator_value:
                df[f'MedianPrice_TA_Indicator_Value'] = self.median
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MedianPrice_TA_Indicator_Value'] = self.median
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_distance_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class MidPointOverPeriodStrategies:
    def __init__(self, period=20, threshold=0.01):
        self.period = period
        self.threshold = threshold
        self.midpoint = None

    def compute_values(self, df):
        high_max = df['High'].rolling(window=self.period, min_periods=1).max()
        low_min = df['Low'].rolling(window=self.period, min_periods=1).min()
        self.midpoint = (high_max + low_min) / 2
        return self.midpoint

    def calculate_scores_price_cross_strategy(self, df):
        if self.midpoint is None:
            self.compute_values(df)
        close = df['Close']
        midpoint_prev = self.midpoint.shift(1)
        close_prev = close.shift(1)
        cond_bull = (close_prev <= midpoint_prev) & (close > self.midpoint)
        cond_bear = (close_prev >= midpoint_prev) & (close < self.midpoint)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def price_cross_map(self, series):
        mapping_value = {1: 'Price_Above_MidPoint', -1: 'Price_Below_MidPoint', 0: 'Price_Neutral'}
        mapping_explanation = {
            1: 'Closing price crossed above the midpoint, indicating bullish conditions.',
            -1: 'Closing price crossed below the midpoint, indicating bearish conditions.',
            0: 'No significant crossover between the price and the midpoint detected.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = f'MidPointOverPeriod_Period:{self.period}_PriceCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'MidPointOverPeriod_Period:{self.period}_TA_Indicator_Value'] = self.midpoint
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MidPointOverPeriod_Period:{self.period}_TA_Indicator_Value'] = self.midpoint
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.midpoint is None:
            self.compute_values(df)
        diff_ratio = (df['Close'] - self.midpoint) / self.midpoint
        signals = np.where(diff_ratio > self.threshold, 1, np.where(diff_ratio < -self.threshold, -1, 0))
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Price_Significantly_Above_MidPoint', -1: 'Price_Significantly_Below_MidPoint', 0: 'Price_Close_to_MidPoint'}
        mapping_explanation = {
            1: f'Closing price is more than {self.threshold*100:.1f}% above the midpoint, indicating strong bullish conditions.',
            -1: f'Closing price is more than {self.threshold*100:.1f}% below the midpoint, indicating strong bearish conditions.',
            0: f'Closing price is within {self.threshold*100:.1f}% of the midpoint, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'MidPointOverPeriod_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'MidPointOverPeriod_Period:{self.period}_TA_Indicator_Value'] = self.midpoint
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MidPointOverPeriod_Period:{self.period}_TA_Indicator_Value'] = self.midpoint
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.midpoint is None:
            self.compute_values(df)
        diff = self.midpoint.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'MidPoint_Rising', -1: 'MidPoint_Falling', 0: 'MidPoint_Flat'}
        mapping_explanation = {
            1: 'The midpoint is rising, indicating an upward shift in the price range.',
            -1: 'The midpoint is falling, indicating a downward shift in the price range.',
            0: 'The midpoint remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'MidPointOverPeriod_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'MidPointOverPeriod_Period:{self.period}_TA_Indicator_Value'] = self.midpoint
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MidPointOverPeriod_Period:{self.period}_TA_Indicator_Value'] = self.midpoint
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=ta_indicator_value,
                                                        signal_score=signal_score, signal_value=signal_value,
                                                        signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False,
                                                      signal_score=signal_score, signal_value=signal_value,
                                                      signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False,
                                                  signal_score=signal_score, signal_value=signal_value,
                                                  signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class MidpointPricePeriodStrategies:
    def __init__(self, period=20, threshold=0.01):
        self.period = period
        self.threshold = threshold
        self.midpoint = None

    def compute_values(self, df):
        high_max = df['High'].rolling(window=self.period, min_periods=1).max()
        low_min = df['Low'].rolling(window=self.period, min_periods=1).min()
        self.midpoint = (high_max + low_min) / 2
        return self.midpoint

    def calculate_scores_price_cross_strategy(self, df):
        if self.midpoint is None:
            self.compute_values(df)
        close = df['Close']
        midpoint_prev = self.midpoint.shift(1)
        close_prev = close.shift(1)
        cond_bull = (close_prev <= midpoint_prev) & (close > self.midpoint)
        cond_bear = (close_prev >= midpoint_prev) & (close < self.midpoint)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def price_cross_map(self, series):
        mapping_value = {1: 'Price_Above_Midpoint', -1: 'Price_Below_Midpoint', 0: 'Price_Neutral'}
        mapping_explanation = {
            1: 'Closing price crossed above the midpoint, indicating bullish conditions.',
            -1: 'Closing price crossed below the midpoint, indicating bearish conditions.',
            0: 'Closing price remains near the midpoint, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = f'MidpointPricePeriod_Period:{self.period}_PriceCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'MidpointPricePeriod_Period:{self.period}_TA_Indicator_Value'] = self.midpoint
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MidpointPricePeriod_Period:{self.period}_TA_Indicator_Value'] = self.midpoint
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.midpoint is None:
            self.compute_values(df)
        diff_ratio = (df['Close'] - self.midpoint) / self.midpoint
        signals = np.where(diff_ratio > self.threshold, 1, np.where(diff_ratio < -self.threshold, -1, 0))
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Price_Significantly_Above_Midpoint', -1: 'Price_Significantly_Below_Midpoint', 0: 'Price_Close_to_Midpoint'}
        mapping_explanation = {
            1: f'Closing price is more than {self.threshold*100:.1f}% above the midpoint, indicating strong bullish conditions.',
            -1: f'Closing price is more than {self.threshold*100:.1f}% below the midpoint, indicating strong bearish conditions.',
            0: f'Closing price is within {self.threshold*100:.1f}% of the midpoint, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'MidpointPricePeriod_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'MidpointPricePeriod_Period:{self.period}_TA_Indicator_Value'] = self.midpoint
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MidpointPricePeriod_Period:{self.period}_TA_Indicator_Value'] = self.midpoint
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.midpoint is None:
            self.compute_values(df)
        diff = self.midpoint.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Midpoint_Rising', -1: 'Midpoint_Falling', 0: 'Midpoint_Flat'}
        mapping_explanation = {
            1: 'The midpoint is rising, indicating an upward shift in the price range.',
            -1: 'The midpoint is falling, indicating a downward shift in the price range.',
            0: 'The midpoint remains flat, indicating neutral price movement.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'MidpointPricePeriod_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'MidpointPricePeriod_Period:{self.period}_TA_Indicator_Value'] = self.midpoint
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MidpointPricePeriod_Period:{self.period}_TA_Indicator_Value'] = self.midpoint
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=ta_indicator_value,
                                                        signal_score=signal_score, signal_value=signal_value,
                                                        signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False,
                                                      signal_score=signal_score, signal_value=signal_value,
                                                      signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False,
                                                  signal_score=signal_score, signal_value=signal_value,
                                                  signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class MinusDirectionalIndicatorStrategies:
    def __init__(self, period=14, baseline=20, lower_threshold=20, upper_threshold=40):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.di_minus = None

    def compute_values(self, df):
        high = df['High']
        low = df['Low']
        close = df['Close']
        prev_close = close.shift(1)
        prev_high = high.shift(1)
        prev_low = low.shift(1)
        tr = pd.concat([high - low, (high - prev_close).abs(), (low - prev_close).abs()], axis=1).max(axis=1)
        dm_minus = prev_low - low
        dm_minus = dm_minus.where((dm_minus > (high - prev_high)) & (dm_minus > 0), 0)
        tr_sum = tr.rolling(window=self.period, min_periods=1).sum()
        dm_minus_sum = dm_minus.rolling(window=self.period, min_periods=1).sum()
        di_minus = 100 * dm_minus_sum / tr_sum
        self.di_minus = pd.Series(di_minus, index=df.index)
        return self.di_minus

    def calculate_scores_zero_cross_strategy(self, df):
        if self.di_minus is None:
            self.compute_values(df)
        di_minus_prev = self.di_minus.shift(1)
        cond_bear = (di_minus_prev <= self.baseline) & (self.di_minus > self.baseline)
        cond_bull = (di_minus_prev >= self.baseline) & (self.di_minus < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'DI-_Below_Baseline', -1: 'DI-_Above_Baseline', 0: 'DI-_Neutral'}
        mapping_explanation = {
            1: f'DI crossed below the baseline of {self.baseline}, indicating waning bearish momentum (bullish signal).',
            -1: f'DI crossed above the baseline of {self.baseline}, indicating rising bearish momentum (bearish signal).',
            0: f'DI remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'DI-_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'DI-_Period:{self.period}_TA_Indicator_Value'] = self.di_minus
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'DI-_Period:{self.period}_TA_Indicator_Value'] = self.di_minus
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.di_minus is None:
            self.compute_values(df)
        cond_bull = self.di_minus < self.lower_threshold
        cond_bear = self.di_minus > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'DI-_Low', -1: 'DI-_High', 0: 'DI-_Neutral'}
        mapping_explanation = {
            1: f'DI is below the lower threshold of {self.lower_threshold}, indicating weak bearish pressure (bullish signal).',
            -1: f'DI is above the upper threshold of {self.upper_threshold}, indicating strong bearish pressure (bearish signal).',
            0: f'DI is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'DI-_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'DI-_Period:{self.period}_TA_Indicator_Value'] = self.di_minus
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'DI-_Period:{self.period}_TA_Indicator_Value'] = self.di_minus
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.di_minus is None:
            self.compute_values(df)
        diff = self.di_minus.diff()
        signals = np.where(diff > 0, -1, np.where(diff < 0, 1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'DI-_Falling', -1: 'DI-_Rising', 0: 'DI-_Stable'}
        mapping_explanation = {
            1: 'DI is falling, indicating that bearish momentum is decreasing (bullish signal).',
            -1: 'DI is rising, indicating that bearish momentum is increasing (bearish signal).',
            0: 'DI is stable, indicating no significant change in bearish momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'DI-_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'DI-_Period:{self.period}_TA_Indicator_Value'] = self.di_minus
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'DI-_Period:{self.period}_TA_Indicator_Value'] = self.di_minus
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  




class MinusDirectionalMovementStrategies:
    def __init__(self, period=14, baseline=0, upper_threshold=0.2, lower_threshold=0.05):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.minus_dm = None

    def compute_values(self, df):
        prev_high = df['High'].shift(1)
        prev_low = df['Low'].shift(1)
        down_move = prev_low - df['Low']
        up_move = df['High'] - prev_high
        minus_dm = np.where((down_move > up_move) & (down_move > 0), down_move, 0)
        self.minus_dm = pd.Series(minus_dm, index=df.index).rolling(window=self.period, min_periods=1).mean()
        return self.minus_dm

    def calculate_scores_zero_cross_strategy(self, df):
        if self.minus_dm is None:
            self.compute_values(df)
        prev_val = self.minus_dm.shift(1)
        cond_bear = (prev_val <= self.baseline) & (self.minus_dm > self.baseline)
        cond_bull = (prev_val > self.baseline) & (self.minus_dm <= self.baseline)
        signals = np.select([cond_bear, cond_bull], [-1, 1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {-1: 'MinusDM_Above_Baseline', 1: 'MinusDM_Below_Baseline', 0: 'MinusDM_Neutral'}
        mapping_explanation = {
            -1: f'MinusDirectionalMovement crossed above the baseline of {self.baseline}, indicating the initiation of bearish movement.',
            1: f'MinusDirectionalMovement crossed below the baseline of {self.baseline}, indicating the cessation of bearish movement and potential bullish reversal.',
            0: f'MinusDirectionalMovement remains near the baseline of {self.baseline}, indicating neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'MinusDM_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'MinusDM_Period:{self.period}_TA_Indicator_Value'] = self.minus_dm
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MinusDM_Period:{self.period}_TA_Indicator_Value'] = self.minus_dm
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.minus_dm is None:
            self.compute_values(df)
        cond_bear = self.minus_dm > self.upper_threshold
        cond_bull = self.minus_dm < self.lower_threshold
        signals = np.select([cond_bear, cond_bull], [-1, 1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {-1: 'MinusDM_High', 1: 'MinusDM_Low', 0: 'MinusDM_Neutral'}
        mapping_explanation = {
            -1: f'MinusDirectionalMovement is above the upper threshold of {self.upper_threshold}, indicating strong bearish momentum.',
            1: f'MinusDirectionalMovement is below the lower threshold of {self.lower_threshold}, indicating minimal bearish movement and potential bullish conditions.',
            0: f'MinusDirectionalMovement is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'MinusDM_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'MinusDM_Period:{self.period}_TA_Indicator_Value'] = self.minus_dm
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MinusDM_Period:{self.period}_TA_Indicator_Value'] = self.minus_dm
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.minus_dm is None:
            self.compute_values(df)
        diff = self.minus_dm.diff()
        signals = np.where(diff > 0, -1, np.where(diff < 0, 1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {-1: 'MinusDM_Rising', 1: 'MinusDM_Falling', 0: 'MinusDM_Unchanged'}
        mapping_explanation = {
            -1: 'MinusDirectionalMovement is rising, indicating increasing bearish movement.',
            1: 'MinusDirectionalMovement is falling, indicating decreasing bearish pressure and potential bullish reversal.',
            0: 'MinusDirectionalMovement remains unchanged, indicating steady market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'MinusDM_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'MinusDM_Period:{self.period}_TA_Indicator_Value'] = self.minus_dm
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MinusDM_Period:{self.period}_TA_Indicator_Value'] = self.minus_dm
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class MoneyFlowIndexStrategies:
    def __init__(self, period=14, baseline=50, upper_threshold=80, lower_threshold=20):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.mfi = None

    def compute_values(self, df):
        typical_price = (df['High'] + df['Low'] + df['Close']) / 3
        money_flow = typical_price * df['Volume']
        change = typical_price.diff()
        pos_flow = np.where(change > 0, money_flow, 0)
        neg_flow = np.where(change < 0, money_flow, 0)
        pos_mf = pd.Series(pos_flow).rolling(window=self.period, min_periods=1).sum()
        neg_mf = pd.Series(neg_flow).rolling(window=self.period, min_periods=1).sum()
        mf_ratio = np.where(neg_mf == 0, np.inf, pos_mf / neg_mf)
        mfi = 100 - (100 / (1 + mf_ratio))
        self.mfi = pd.Series(mfi, index=df.index)
        return self.mfi

    def calculate_scores_zero_cross_strategy(self, df):
        if self.mfi is None:
            self.compute_values(df)
        mfi_prev = self.mfi.shift(1)
        cond_bull = (mfi_prev <= self.baseline) & (self.mfi > self.baseline)
        cond_bear = (mfi_prev >= self.baseline) & (self.mfi < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'MFI_Above_Baseline', -1: 'MFI_Below_Baseline', 0: 'MFI_Neutral'}
        mapping_explanation = {
            1: f'MFI crossed above the baseline of {self.baseline}, indicating bullish conditions.',
            -1: f'MFI crossed below the baseline of {self.baseline}, indicating bearish conditions.',
            0: f'MFI remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'MFI_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'MFI_Period:{self.period}_TA_Indicator_Value'] = self.mfi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MFI_Period:{self.period}_TA_Indicator_Value'] = self.mfi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.mfi is None:
            self.compute_values(df)
        cond_bull = self.mfi < self.lower_threshold
        cond_bear = self.mfi > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'MFI_Oversold', -1: 'MFI_Overbought', 0: 'MFI_Neutral'}
        mapping_explanation = {
            1: f'MFI is below the lower threshold of {self.lower_threshold}, indicating oversold conditions and potential bullish reversal.',
            -1: f'MFI is above the upper threshold of {self.upper_threshold}, indicating overbought conditions and potential bearish reversal.',
            0: 'MFI is within the normal range, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'MFI_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'MFI_Period:{self.period}_TA_Indicator_Value'] = self.mfi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MFI_Period:{self.period}_TA_Indicator_Value'] = self.mfi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.mfi is None:
            self.compute_values(df)
        diff = self.mfi.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'MFI_Rising', -1: 'MFI_Falling', 0: 'MFI_Unchanged'}
        mapping_explanation = {
            1: 'MFI is rising, indicating increasing bullish momentum.',
            -1: 'MFI is falling, indicating increasing bearish momentum.',
            0: 'MFI remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'MFI_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'MFI_Period:{self.period}_TA_Indicator_Value'] = self.mfi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MFI_Period:{self.period}_TA_Indicator_Value'] = self.mfi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class MomentumStrategies:
    def __init__(self, period=10, baseline=0, upper_threshold=1, lower_threshold=-1):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.momentum = None

    def compute_values(self, df):
        momentum = df['Close'] - df['Close'].shift(self.period)
        self.momentum = pd.Series(momentum, index=df.index)
        return self.momentum

    def calculate_scores_zero_cross_strategy(self, df):
        if self.momentum is None:
            self.compute_values(df)
        prev_val = self.momentum.shift(1)
        cond_bull = (prev_val <= self.baseline) & (self.momentum > self.baseline)
        cond_bear = (prev_val >= self.baseline) & (self.momentum < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Momentum_Above_Baseline', -1: 'Momentum_Below_Baseline', 0: 'Momentum_Neutral'}
        mapping_explanation = {
            1: f'Momentum crossed above the baseline of {self.baseline}, indicating emerging bullish momentum.',
            -1: f'Momentum crossed below the baseline of {self.baseline}, indicating emerging bearish momentum.',
            0: f'Momentum remains around the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'Momentum_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'Momentum_Period:{self.period}_TA_Indicator_Value'] = self.momentum
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Momentum_Period:{self.period}_TA_Indicator_Value'] = self.momentum
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.momentum is None:
            self.compute_values(df)
        cond_bull = self.momentum > self.upper_threshold
        cond_bear = self.momentum < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Momentum_Strong_Bullish', -1: 'Momentum_Strong_Bearish', 0: 'Momentum_Neutral'}
        mapping_explanation = {
            1: f'Momentum is above the upper threshold of {self.upper_threshold}, indicating strong bullish momentum.',
            -1: f'Momentum is below the lower threshold of {self.lower_threshold}, indicating strong bearish momentum.',
            0: f'Momentum is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'Momentum_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'Momentum_Period:{self.period}_TA_Indicator_Value'] = self.momentum
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Momentum_Period:{self.period}_TA_Indicator_Value'] = self.momentum
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.momentum is None:
            self.compute_values(df)
        diff = self.momentum.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Momentum_Rising', -1: 'Momentum_Falling', 0: 'Momentum_Unchanged'}
        mapping_explanation = {
            1: 'Momentum is rising, indicating increasing bullish strength.',
            -1: 'Momentum is falling, indicating increasing bearish pressure.',
            0: 'Momentum remains unchanged, indicating a stable trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'Momentum_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'Momentum_Period:{self.period}_TA_Indicator_Value'] = self.momentum
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Momentum_Period:{self.period}_TA_Indicator_Value'] = self.momentum
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class MomentumBreakoutBandsStrategies:
    def __init__(self, period=10, multiplier=2, baseline=0, upper_threshold=None, lower_threshold=None):
        self.period = period
        self.multiplier = multiplier
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.mbb = None
        self.momentum = None
        self.middle = None
        self.upper = None
        self.lower = None

    def compute_values(self, df):
        momentum = df['Close'] - df['Close'].shift(self.period)
        middle = pd.Series(momentum).rolling(window=self.period, min_periods=1).mean()
        std = pd.Series(momentum).rolling(window=self.period, min_periods=1).std()
        upper = middle + self.multiplier * std
        lower = middle - self.multiplier * std
        self.momentum = pd.Series(momentum, index=df.index)
        self.middle = pd.Series(middle, index=df.index)
        self.upper = pd.Series(upper, index=df.index)
        self.lower = pd.Series(lower, index=df.index)
        self.mbb = pd.DataFrame({'Momentum': self.momentum, 'Middle': self.middle, 'Upper': self.upper, 'Lower': self.lower}, index=df.index)
        return self.mbb

    def calculate_scores_zero_cross_strategy(self, df):
        if self.mbb is None:
            self.compute_values(df)
        prev_mom = self.momentum.shift(1)
        prev_middle = self.middle.shift(1)
        cond_bull = (prev_mom <= prev_middle) & (self.momentum > self.middle)
        cond_bear = (prev_mom >= prev_middle) & (self.momentum < self.middle)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'MomentumAboveMiddle', -1: 'MomentumBelowMiddle', 0: 'MomentumNeutral'}
        mapping_explanation = {
            1: 'Momentum has crossed above the middle band, indicating a potential bullish breakout.',
            -1: 'Momentum has crossed below the middle band, indicating a potential bearish breakout.',
            0: 'Momentum remains near the middle band, indicating no clear breakout.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'MBB_Period:{self.period}_Multiplier:{self.multiplier}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'MBB_Period:{self.period}_TA_Indicator_Value'] = self.momentum
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MBB_Period:{self.period}_TA_Indicator_Value'] = self.momentum
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.mbb is None:
            self.compute_values(df)
        upper_threshold = self.upper_threshold if self.upper_threshold is not None else self.upper
        lower_threshold = self.lower_threshold if self.lower_threshold is not None else self.lower
        cond_bull = self.momentum > upper_threshold
        cond_bear = self.momentum < lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'MomentumAboveUpperBand', -1: 'MomentumBelowLowerBand', 0: 'MomentumWithinBands'}
        mapping_explanation = {
            1: 'Momentum is above the upper band, indicating a strong bullish breakout.',
            -1: 'Momentum is below the lower band, indicating a strong bearish breakout.',
            0: 'Momentum is within the breakout bands, indicating a lack of significant breakout.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'MBB_Period:{self.period}_Multiplier:{self.multiplier}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'MBB_Period:{self.period}_TA_Indicator_Value'] = self.momentum
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MBB_Period:{self.period}_TA_Indicator_Value'] = self.momentum
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.mbb is None:
            self.compute_values(df)
        diff = self.momentum.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'MomentumRising', -1: 'MomentumFalling', 0: 'MomentumStable'}
        mapping_explanation = {
            1: 'Momentum is increasing, suggesting strengthening bullish momentum.',
            -1: 'Momentum is decreasing, suggesting strengthening bearish momentum.',
            0: 'Momentum remains stable, indicating no significant change in trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'MBB_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'MBB_Period:{self.period}_TA_Indicator_Value'] = self.momentum
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MBB_Period:{self.period}_TA_Indicator_Value'] = self.momentum
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


class MACDStrategies:
    def __init__(self, short_period=12, long_period=26, signal_period=9):
        self.short_period = short_period
        self.long_period = long_period
        self.signal_period = signal_period
        self.macd = None
        self.signal = None
        self.histogram = None

    def _calculate_ema(self, series, period):
        ema = []
        multiplier = 2 / (period + 1)
        for i, price in enumerate(series):
            if i == 0:
                ema.append(price)
            else:
                ema.append((price - ema[i - 1]) * multiplier + ema[i - 1])
        return ema

    def compute_values(self, df):
        close = df['Close']
        short_ema = self._calculate_ema(close, self.short_period)
        long_ema = self._calculate_ema(close, self.long_period)
        macd_line = pd.Series(short_ema, index=close.index) - pd.Series(long_ema, index=close.index)
        signal_line = self._calculate_ema(macd_line, self.signal_period)
        self.macd = macd_line
        self.signal = pd.Series(signal_line, index=close.index)
        self.histogram = self.macd - self.signal
        return pd.DataFrame({'MACD': self.macd, 'Signal': self.signal, 'Histogram': self.histogram}, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if self.macd is None or self.signal is None:
            self.compute_values(df)
        macd_prev = self.macd.shift(1)
        signal_prev = self.signal.shift(1)
        cond_bull = (macd_prev <= signal_prev) & (self.macd > self.signal)
        cond_bear = (macd_prev >= signal_prev) & (self.macd < self.signal)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'MACD_CrossAbove_Signal', -1: 'MACD_CrossBelow_Signal', 0: 'MACD_Neutral'}
        mapping_explanation = {
            1: 'MACD line crossed above the Signal line, indicating bullish momentum.',
            -1: 'MACD line crossed below the Signal line, indicating bearish momentum.',
            0: 'No cross detected between MACD and Signal lines, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'MACD_SP:{self.short_period}_LP:{self.long_period}_SigP:{self.signal_period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'MACD_SP:{self.short_period}_LP:{self.long_period}_TA_Indicator_Value'] = self.macd
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MACD_SP:{self.short_period}_LP:{self.long_period}_TA_Indicator_Value'] = self.macd
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.histogram is None:
            self.compute_values(df)
        cond_bull = self.histogram > 0
        cond_bear = self.histogram < 0
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Histogram_Positive', -1: 'Histogram_Negative', 0: 'Histogram_Neutral'}
        mapping_explanation = {
            1: 'The MACD Histogram is positive, suggesting bullish momentum as MACD is above the Signal line.',
            -1: 'The MACD Histogram is negative, suggesting bearish momentum as MACD is below the Signal line.',
            0: 'The MACD Histogram is neutral, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'MACD_SP:{self.short_period}_LP:{self.long_period}_SigP:{self.signal_period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'MACD_SP:{self.short_period}_LP:{self.long_period}_TA_Indicator_Value'] = self.macd
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MACD_SP:{self.short_period}_LP:{self.long_period}_TA_Indicator_Value'] = self.macd
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.macd is None:
            self.compute_values(df)
        diff = self.macd.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'MACD_Rising', -1: 'MACD_Falling', 0: 'MACD_Unchanged'}
        mapping_explanation = {
            1: 'The MACD line is rising, indicating increasing bullish momentum.',
            -1: 'The MACD line is falling, indicating increasing bearish momentum.',
            0: 'The MACD line remains unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'MACD_SP:{self.short_period}_LP:{self.long_period}_SigP:{self.signal_period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'MACD_SP:{self.short_period}_LP:{self.long_period}_TA_Indicator_Value'] = self.macd
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'MACD_SP:{self.short_period}_LP:{self.long_period}_TA_Indicator_Value'] = self.macd
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class MovingStandardDeviationStrategies:
    def __init__(self, period=20, baseline=1.0, upper_threshold=2.0, lower_threshold=0.5):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.std_series = None

    def compute_values(self, df):
        prices = df['Close'].tolist()
        std_values = []
        for i in range(len(prices)):
            if i < self.period - 1:
                window = prices[:i + 1]
            else:
                window = prices[i - self.period + 1:i + 1]
            mean_val = sum(window) / len(window)
            variance = sum((x - mean_val) ** 2 for x in window) / len(window)
            std_values.append(variance ** 0.5)
        self.std_series = pd.Series(std_values, index=df.index)
        return self.std_series

    def calculate_scores_zero_cross_strategy(self, df):
        if self.std_series is None:
            self.compute_values(df)
        std_prev = self.std_series.shift(1)
        cond_bull = (std_prev <= self.baseline) & (self.std_series > self.baseline)
        cond_bear = (std_prev >= self.baseline) & (self.std_series < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'StdDev_Above_Baseline', -1: 'StdDev_Below_Baseline', 0: 'StdDev_Neutral'}
        mapping_explanation = {
            1: f'Moving Standard Deviation crossed above the baseline of {self.baseline}, indicating increasing volatility.',
            -1: f'Moving Standard Deviation crossed below the baseline of {self.baseline}, indicating decreasing volatility.',
            0: f'Moving Standard Deviation remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'StdDev_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'StdDev_Period:{self.period}_TA_Indicator_Value'] = self.std_series
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StdDev_Period:{self.period}_TA_Indicator_Value'] = self.std_series
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.std_series is None:
            self.compute_values(df)
        cond_bull = self.std_series < self.lower_threshold
        cond_bear = self.std_series > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Low_Volatility', -1: 'High_Volatility', 0: 'Volatility_Neutral'}
        mapping_explanation = {
            1: f'Moving Standard Deviation is below the lower threshold of {self.lower_threshold}, indicating calm market conditions.',
            -1: f'Moving Standard Deviation is above the upper threshold of {self.upper_threshold}, indicating high volatility.',
            0: f'Moving Standard Deviation is between {self.lower_threshold} and {self.upper_threshold}, indicating normal volatility.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'StdDev_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'StdDev_Period:{self.period}_TA_Indicator_Value'] = self.std_series
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StdDev_Period:{self.period}_TA_Indicator_Value'] = self.std_series
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.std_series is None:
            self.compute_values(df)
        diff = self.std_series.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Volatility_Increasing', -1: 'Volatility_Decreasing', 0: 'Volatility_Unchanged'}
        mapping_explanation = {
            1: 'Moving Standard Deviation is rising, indicating increasing volatility and potential upcoming price movements.',
            -1: 'Moving Standard Deviation is falling, indicating decreasing volatility and potential market consolidation.',
            0: 'Moving Standard Deviation remains unchanged, indicating stable volatility conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'StdDev_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'StdDev_Period:{self.period}_TA_Indicator_Value'] = self.std_series
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StdDev_Period:{self.period}_TA_Indicator_Value'] = self.std_series
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)




  
class NegativeVolumeIndexStrategies:
    def __init__(self, baseline=1000, lower_threshold=980, upper_threshold=1020):
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.nvi = None

    def compute_values(self, df):
        nvi_values = []
        nvi = self.baseline
        nvi_values.append(nvi)
        for i in range(1, len(df)):
            if df['Volume'].iloc[i] < df['Volume'].iloc[i-1]:
                ret = (df['Close'].iloc[i] - df['Close'].iloc[i-1]) / df['Close'].iloc[i-1]
                nvi = nvi * (1 + ret)
            nvi_values.append(nvi)
        self.nvi = pd.Series(nvi_values, index=df.index)
        return self.nvi

    def calculate_scores_zero_cross_strategy(self, df):
        if self.nvi is None:
            self.compute_values(df)
        nvi_prev = self.nvi.shift(1)
        cond_bull = (nvi_prev <= self.baseline) & (self.nvi > self.baseline)
        cond_bear = (nvi_prev >= self.baseline) & (self.nvi < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'NVI_Above_Baseline', -1: 'NVI_Below_Baseline', 0: 'NVI_Neutral'}
        mapping_explanation = {
            1: f'NVI crossed above the baseline of {self.baseline}, suggesting potential bullish conditions.',
            -1: f'NVI crossed below the baseline of {self.baseline}, suggesting potential bearish conditions.',
            0: f'NVI remains around the baseline of {self.baseline}, indicating neutral market sentiment.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'NVI_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'NVI_TA_Indicator_Value'] = self.nvi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'NVI_TA_Indicator_Value'] = self.nvi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.nvi is None:
            self.compute_values(df)
        cond_bull = self.nvi > self.upper_threshold
        cond_bear = self.nvi < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'NVI_Over_Upper_Threshold', -1: 'NVI_Under_Lower_Threshold', 0: 'NVI_Within_Thresholds'}
        mapping_explanation = {
            1: f'NVI is above the upper threshold of {self.upper_threshold}, indicating strong bullish sentiment.',
            -1: f'NVI is below the lower threshold of {self.lower_threshold}, indicating strong bearish sentiment.',
            0: f'NVI is between the thresholds of {self.lower_threshold} and {self.upper_threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'NVI_LowerThreshold:{self.lower_threshold}_UpperThreshold:{self.upper_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'NVI_TA_Indicator_Value'] = self.nvi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'NVI_TA_Indicator_Value'] = self.nvi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.nvi is None:
            self.compute_values(df)
        diff = self.nvi.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'NVI_Rising', -1: 'NVI_Falling', 0: 'NVI_Unchanged'}
        mapping_explanation = {
            1: 'NVI is rising, suggesting accumulating bullish momentum during low volume periods.',
            -1: 'NVI is falling, suggesting accumulating bearish momentum during low volume periods.',
            0: 'NVI remains unchanged, indicating a lack of significant movement in low volume conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'NVI_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'NVI_TA_Indicator_Value'] = self.nvi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'NVI_TA_Indicator_Value'] = self.nvi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class NormalizedAverageTrueRangeStrategies:
    def __init__(self, period=14, baseline=1.0, lower_threshold=0.5, upper_threshold=2.0):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold

    def compute_values(self, df):
        prev_close = df['Close'].shift(1)
        tr = np.maximum(np.maximum(df['High'] - df['Low'], (df['High'] - prev_close).abs()), (df['Low'] - prev_close).abs())
        atr = pd.Series(tr).rolling(window=self.period, min_periods=self.period).mean()
        natr = (atr / df['Close']) * 100
        self.natr = pd.Series(natr, index=df.index)
        return self.natr

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'natr') or self.natr is None:
            self.natr = self.compute_values(df)
        natr_prev = self.natr.shift(1)
        cond_bull = (natr_prev <= self.baseline) & (self.natr > self.baseline)
        cond_bear = (natr_prev >= self.baseline) & (self.natr < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'NATR_Volatility_Surge', -1: 'NATR_Volatility_Fade', 0: 'NATR_Neutral'}
        mapping_explanation = {
            1: f'Normalized ATR crossed above the baseline of {self.baseline}, indicating a surge in volatility that may precede a breakout.',
            -1: f'Normalized ATR crossed below the baseline of {self.baseline}, indicating a fade in volatility and potential consolidation.',
            0: f'Normalized ATR remains around the baseline of {self.baseline}, indicating stable volatility conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'NATR_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'NATR_Period:{self.period}_TA_Indicator_Value'] = self.natr
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'NATR_Period:{self.period}_TA_Indicator_Value'] = self.natr
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'natr') or self.natr is None:
            self.natr = self.compute_values(df)
        cond_bull = self.natr < self.lower_threshold
        cond_bear = self.natr > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'NATR_Low_Volatility', -1: 'NATR_High_Volatility', 0: 'NATR_Moderate'}
        mapping_explanation = {
            1: f'Normalized ATR is below the lower threshold of {self.lower_threshold}, indicating low volatility that may favor steady trends.',
            -1: f'Normalized ATR is above the upper threshold of {self.upper_threshold}, indicating high volatility that may precede reversals or whipsaws.',
            0: f'Normalized ATR is between {self.lower_threshold} and {self.upper_threshold}, indicating moderate volatility conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'NATR_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'NATR_Period:{self.period}_TA_Indicator_Value'] = self.natr
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'NATR_Period:{self.period}_TA_Indicator_Value'] = self.natr
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'natr') or self.natr is None:
            self.natr = self.compute_values(df)
        diff = self.natr.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'NATR_Rising', -1: 'NATR_Falling', 0: 'NATR_Unchanged'}
        mapping_explanation = {
            1: 'Normalized ATR is rising, indicating increasing volatility which may support breakout trades.',
            -1: 'Normalized ATR is falling, indicating decreasing volatility which may favor trend continuation.',
            0: 'Normalized ATR remains unchanged, indicating stable volatility conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'NATR_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'NATR_Period:{self.period}_TA_Indicator_Value'] = self.natr
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'NATR_Period:{self.period}_TA_Indicator_Value'] = self.natr
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)





  
class NormalizedBASPStrategies:
    def __init__(self, period=20, baseline=0, lower_threshold=-2.0, upper_threshold=2.0):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.nbasp = None

    def compute_values(self, df):
        sma = df['Close'].rolling(window=self.period, min_periods=1).mean()
        self.nbasp = ((df['Close'] - sma) / sma) * 100
        return self.nbasp

    def calculate_scores_zero_cross_strategy(self, df):
        if self.nbasp is None:
            self.compute_values(df)
        nbasp_prev = self.nbasp.shift(1)
        cond_bull = (nbasp_prev <= self.baseline) & (self.nbasp > self.baseline)
        cond_bear = (nbasp_prev >= self.baseline) & (self.nbasp < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'NBASP_Above_Baseline', -1: 'NBASP_Below_Baseline', 0: 'NBASP_Neutral'}
        mapping_explanation = {
            1: f'NormalizedBASP crossed above the baseline of {self.baseline}, indicating the price has moved above its moving average.',
            -1: f'NormalizedBASP crossed below the baseline of {self.baseline}, indicating the price has moved below its moving average.',
            0: f'NormalizedBASP remains around the baseline of {self.baseline}, indicating no clear directional shift.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'NBASP_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'NBASP_Period:{self.period}_TA_Indicator_Value'] = self.nbasp
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'NBASP_Period:{self.period}_TA_Indicator_Value'] = self.nbasp
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.nbasp is None:
            self.compute_values(df)
        cond_bull = self.nbasp < self.lower_threshold
        cond_bear = self.nbasp > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'NBASP_Undersold', -1: 'NBASP_Overbought', 0: 'NBASP_Normal'}
        mapping_explanation = {
            1: f'NormalizedBASP is below the lower threshold of {self.lower_threshold}, suggesting the price is significantly under its moving average (potential bullish reversal).',
            -1: f'NormalizedBASP is above the upper threshold of {self.upper_threshold}, suggesting the price is significantly over its moving average (potential bearish reversal).',
            0: f'NormalizedBASP is between {self.lower_threshold} and {self.upper_threshold}, indicating normal deviation levels.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'NBASP_Period:{self.period}_LowerThreshold:{self.lower_threshold}_UpperThreshold:{self.upper_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'NBASP_Period:{self.period}_TA_Indicator_Value'] = self.nbasp
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'NBASP_Period:{self.period}_TA_Indicator_Value'] = self.nbasp
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.nbasp is None:
            self.compute_values(df)
        diff = self.nbasp.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'NBASP_Rising', -1: 'NBASP_Falling', 0: 'NBASP_Unchanged'}
        mapping_explanation = {
            1: 'NormalizedBASP is rising, indicating the price is moving further above its moving average.',
            -1: 'NormalizedBASP is falling, indicating the price is moving further below its moving average.',
            0: 'NormalizedBASP remains unchanged, indicating stable deviation from its moving average.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'NBASP_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'NBASP_Period:{self.period}_TA_Indicator_Value'] = self.nbasp
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'NBASP_Period:{self.period}_TA_Indicator_Value'] = self.nbasp
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class OnBalanceVolumeStrategies:
    def __init__(self, baseline=0, lower_threshold=-100000, upper_threshold=100000):
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.obv = None

    def compute_values(self, df):
        obv_values = []
        obv = 0
        obv_values.append(obv)
        for i in range(1, len(df)):
            if df['Close'].iloc[i] > df['Close'].iloc[i-1]:
                obv += df['Volume'].iloc[i]
            elif df['Close'].iloc[i] < df['Close'].iloc[i-1]:
                obv -= df['Volume'].iloc[i]
            obv_values.append(obv)
        self.obv = pd.Series(obv_values, index=df.index)
        return self.obv

    def calculate_scores_zero_cross_strategy(self, df):
        if self.obv is None:
            self.compute_values(df)
        obv_prev = self.obv.shift(1)
        cond_bull = (obv_prev <= self.baseline) & (self.obv > self.baseline)
        cond_bear = (obv_prev >= self.baseline) & (self.obv < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'OBV_Above_Baseline', -1: 'OBV_Below_Baseline', 0: 'OBV_Neutral'}
        mapping_explanation = {
            1: f'OBV crossed above the baseline of {self.baseline}, indicating accumulation and bullish pressure.',
            -1: f'OBV crossed below the baseline of {self.baseline}, indicating distribution and bearish pressure.',
            0: f'OBV remains near the baseline of {self.baseline}, indicating neutral volume flow.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'OBV_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'OBV_TA_Indicator_Value'] = self.obv
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'OBV_TA_Indicator_Value'] = self.obv
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.obv is None:
            self.compute_values(df)
        cond_bull = self.obv > self.upper_threshold
        cond_bear = self.obv < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'OBV_Over_Upper_Threshold', -1: 'OBV_Under_Lower_Threshold', 0: 'OBV_Neutral'}
        mapping_explanation = {
            1: f'OBV is above the upper threshold of {self.upper_threshold}, indicating strong accumulation and bullish sentiment.',
            -1: f'OBV is below the lower threshold of {self.lower_threshold}, indicating strong distribution and bearish sentiment.',
            0: f'OBV is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced volume flow.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'OBV_LowerThreshold:{self.lower_threshold}_UpperThreshold:{self.upper_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'OBV_TA_Indicator_Value'] = self.obv
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'OBV_TA_Indicator_Value'] = self.obv
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.obv is None:
            self.compute_values(df)
        diff = self.obv.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'OBV_Rising', -1: 'OBV_Falling', 0: 'OBV_Unchanged'}
        mapping_explanation = {
            1: 'OBV is rising, indicating increasing buying pressure and accumulation.',
            -1: 'OBV is falling, indicating increasing selling pressure and distribution.',
            0: 'OBV remains unchanged, indicating a lack of clear volume-driven trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'OBV_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'OBV_TA_Indicator_Value'] = self.obv
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'OBV_TA_Indicator_Value'] = self.obv
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class OHLC_AverageStrategies:
    def __init__(self, baseline=100, lower_threshold=95, upper_threshold=105):
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.ohlc_avg = None

    def compute_values(self, df):
        self.ohlc_avg = (df['Open'] + df['High'] + df['Low'] + df['Close']) / 4
        return self.ohlc_avg

    def calculate_scores_zero_cross_strategy(self, df):
        if self.ohlc_avg is None:
            self.compute_values(df)
        ohlc_prev = self.ohlc_avg.shift(1)
        cond_bull = (ohlc_prev <= self.baseline) & (self.ohlc_avg > self.baseline)
        cond_bear = (ohlc_prev >= self.baseline) & (self.ohlc_avg < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'OHLC_Avg_Above_Baseline', -1: 'OHLC_Avg_Below_Baseline', 0: 'OHLC_Avg_Neutral'}
        mapping_explanation = {
            1: f'OHLC Average crossed above the baseline of {self.baseline}, suggesting bullish momentum.',
            -1: f'OHLC Average crossed below the baseline of {self.baseline}, suggesting bearish momentum.',
            0: f'OHLC Average remains near the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'OHLCAvg_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'OHLCAvg_TA_Indicator_Value'] = self.ohlc_avg
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'OHLCAvg_TA_Indicator_Value'] = self.ohlc_avg
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.ohlc_avg is None:
            self.compute_values(df)
        cond_bull = self.ohlc_avg < self.lower_threshold
        cond_bear = self.ohlc_avg > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'OHLC_Avg_Undersold', -1: 'OHLC_Avg_Overbought', 0: 'OHLC_Avg_Normal'}
        mapping_explanation = {
            1: f'OHLC Average is below the lower threshold of {self.lower_threshold}, suggesting the price is undervalued (potential bullish reversal).',
            -1: f'OHLC Average is above the upper threshold of {self.upper_threshold}, suggesting the price is overvalued (potential bearish reversal).',
            0: f'OHLC Average is between {self.lower_threshold} and {self.upper_threshold}, indicating normal price levels.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'OHLCAvg_LowerThreshold:{self.lower_threshold}_UpperThreshold:{self.upper_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'OHLCAvg_TA_Indicator_Value'] = self.ohlc_avg
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'OHLCAvg_TA_Indicator_Value'] = self.ohlc_avg
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.ohlc_avg is None:
            self.compute_values(df)
        diff = self.ohlc_avg.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'OHLC_Avg_Rising', -1: 'OHLC_Avg_Falling', 0: 'OHLC_Avg_Unchanged'}
        mapping_explanation = {
            1: 'OHLC Average is rising, indicating upward price momentum.',
            -1: 'OHLC Average is falling, indicating downward price momentum.',
            0: 'OHLC Average remains unchanged, indicating no clear trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'OHLCAvg_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'OHLCAvg_TA_Indicator_Value'] = self.ohlc_avg
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'OHLCAvg_TA_Indicator_Value'] = self.ohlc_avg
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class ParabolicStopAndReverseStrategies:
    def __init__(self, initial_af=0.02, max_af=0.2, baseline=0, lower_threshold=-0.5, upper_threshold=0.5):
        self.initial_af = initial_af
        self.max_af = max_af
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.psar = None

    def compute_values(self, df):
        psar_list = []
        if len(df) < 2:
            self.psar = pd.Series([None] * len(df), index=df.index)
            return self.psar
        if df['Close'].iloc[1] > df['Close'].iloc[0]:
            trend = 'up'
            psar = df['Low'].iloc[0]
            ep = df['High'].iloc[0]
        else:
            trend = 'down'
            psar = df['High'].iloc[0]
            ep = df['Low'].iloc[0]
        af = self.initial_af
        psar_list.append(psar)
        if trend == 'up':
            psar = df['Low'].iloc[0]
            ep = max(df['High'].iloc[0], df['High'].iloc[1])
        else:
            psar = df['High'].iloc[0]
            ep = min(df['Low'].iloc[0], df['Low'].iloc[1])
        psar_list.append(psar)
        for i in range(2, len(df)):
            prev_psar = psar
            if trend == 'up':
                psar = prev_psar + af * (ep - prev_psar)
                psar = min(psar, df['Low'].iloc[i - 1], df['Low'].iloc[i - 2])
                if df['High'].iloc[i] > ep:
                    ep = df['High'].iloc[i]
                    af = min(af + self.initial_af, self.max_af)
                if df['Low'].iloc[i] < psar:
                    trend = 'down'
                    psar = ep
                    ep = df['Low'].iloc[i]
                    af = self.initial_af
            else:
                psar = prev_psar - af * (prev_psar - ep)
                psar = max(psar, df['High'].iloc[i - 1], df['High'].iloc[i - 2])
                if df['Low'].iloc[i] < ep:
                    ep = df['Low'].iloc[i]
                    af = min(af + self.initial_af, self.max_af)
                if df['High'].iloc[i] > psar:
                    trend = 'up'
                    psar = ep
                    ep = df['High'].iloc[i]
                    af = self.initial_af
            psar_list.append(psar)
        self.psar = pd.Series(psar_list, index=df.index)
        return self.psar

    def calculate_scores_zero_cross_strategy(self, df):
        if self.psar is None:
            self.compute_values(df)
        diff_prev = (df['Close'] - self.psar).shift(1)
        diff_current = df['Close'] - self.psar
        cond_bull = (diff_prev <= self.baseline) & (diff_current > self.baseline)
        cond_bear = (diff_prev >= self.baseline) & (diff_current < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'PSAR_Bullish_Cross', -1: 'PSAR_Bearish_Cross', 0: 'PSAR_Neutral'}
        mapping_explanation = {
            1: f'Close price crossed above the PSAR, indicating a potential bullish reversal.',
            -1: f'Close price crossed below the PSAR, indicating a potential bearish reversal.',
            0: 'No significant PSAR crossover detected.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'PSAR_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df['PSAR_TA_Indicator_Value'] = self.psar
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['PSAR_TA_Indicator_Value'] = self.psar
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.psar is None:
            self.compute_values(df)
        diff = df['Close'] - self.psar
        cond_bull = diff > self.upper_threshold
        cond_bear = diff < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'PSAR_Strong_Bullish', -1: 'PSAR_Strong_Bearish', 0: 'PSAR_Normal'}
        mapping_explanation = {
            1: f'Close is significantly above PSAR (by more than {self.upper_threshold}), indicating strong bullish momentum.',
            -1: f'Close is significantly below PSAR (by more than {abs(self.lower_threshold)}), indicating strong bearish momentum.',
            0: 'Close is near PSAR, indicating balanced market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'PSAR_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df['PSAR_TA_Indicator_Value'] = self.psar
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['PSAR_TA_Indicator_Value'] = self.psar
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.psar is None:
            self.compute_values(df)
        diff = self.psar.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'PSAR_Rising', -1: 'PSAR_Falling', 0: 'PSAR_Unchanged'}
        mapping_explanation = {
            1: 'PSAR is rising, indicating an uptrend continuation.',
            -1: 'PSAR is falling, indicating a downtrend continuation.',
            0: 'PSAR remains unchanged, indicating potential consolidation.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'PSAR_Slope_Signal'
        if append:
            if ta_indicator_value:
                df['PSAR_TA_Indicator_Value'] = self.psar
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['PSAR_TA_Indicator_Value'] = self.psar
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class PascalsWeightedMovingAverageStrategies:
    def __init__(self, period=10, lower_threshold=-1, upper_threshold=1):
        self.period = period
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.pwma = None

    def compute_values(self, df):
        values = []
        for i in range(len(df)):
            if i < self.period - 1:
                window = df['Close'].iloc[:i+1]
                n = len(window)
                weights = [math.comb(n-1, k) for k in range(n)]
                weighted_sum = sum(w * p for w, p in zip(weights, window))
                total_weight = sum(weights)
                values.append(weighted_sum / total_weight)
            else:
                window = df['Close'].iloc[i-self.period+1:i+1]
                n = self.period
                weights = [math.comb(n-1, k) for k in range(n)]
                weighted_sum = sum(w * p for w, p in zip(weights, window))
                total_weight = sum(weights)
                values.append(weighted_sum / total_weight)
        self.pwma = pd.Series(values, index=df.index)
        return self.pwma

    def calculate_scores_zero_cross_strategy(self, df):
        if self.pwma is None:
            self.compute_values(df)
        close_prev = df['Close'].shift(1)
        indicator_prev = self.pwma.shift(1)
        close_current = df['Close']
        indicator_current = self.pwma
        cond_bull = (close_prev - indicator_prev <= 0) & (close_current - indicator_current > 0)
        cond_bear = (close_prev - indicator_prev >= 0) & (close_current - indicator_current < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Price_Above_PWMA', -1: 'Price_Below_PWMA', 0: 'Price_Near_PWMA'}
        mapping_explanation = {
            1: 'The close price has crossed above the Pascals Weighted Moving Average, indicating bullish momentum.',
            -1: 'The close price has crossed below the Pascals Weighted Moving Average, indicating bearish momentum.',
            0: 'The close price remains near the Pascals Weighted Moving Average, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'PWMA_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'PWMA_Period:{self.period}_TA_Indicator_Value'] = self.pwma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PWMA_Period:{self.period}_TA_Indicator_Value'] = self.pwma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.pwma is None:
            self.compute_values(df)
        diff = (df['Close'] - self.pwma) / self.pwma * 100
        cond_bull = diff > self.upper_threshold
        cond_bear = diff < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Price_Above_Upper_Threshold', -1: 'Price_Below_Lower_Threshold', 0: 'Price_Near_PWMA'}
        mapping_explanation = {
            1: f'The close price is more than {self.upper_threshold}% above the Pascals Weighted Moving Average, indicating strong bullish momentum.',
            -1: f'The close price is more than {abs(self.lower_threshold)}% below the Pascals Weighted Moving Average, indicating strong bearish momentum.',
            0: f'The close price is within the thresholds, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'PWMA_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'PWMA_Period:{self.period}_TA_Indicator_Value'] = self.pwma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PWMA_Period:{self.period}_TA_Indicator_Value'] = self.pwma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.pwma is None:
            self.compute_values(df)
        diff = self.pwma.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'PWMA_Rising', -1: 'PWMA_Falling', 0: 'PWMA_Unchanged'}
        mapping_explanation = {
            1: 'The Pascals Weighted Moving Average is rising, indicating upward momentum.',
            -1: 'The Pascals Weighted Moving Average is falling, indicating downward momentum.',
            0: 'The Pascals Weighted Moving Average remains unchanged, indicating a lack of clear trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'PWMA_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'PWMA_Period:{self.period}_TA_Indicator_Value'] = self.pwma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PWMA_Period:{self.period}_TA_Indicator_Value'] = self.pwma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class PearsonsCorrelationCoefficientStrategies:
    def __init__(self, period=20, col1='Close', col2='Benchmark', baseline=0, lower_threshold=-0.5, upper_threshold=0.5):
        self.period = period
        self.col1 = col1
        self.col2 = col2
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.pcc = None

    def compute_values(self, df):
        self.pcc = df[self.col1].rolling(window=self.period, min_periods=1).corr(df[self.col2])
        return self.pcc

    def calculate_scores_zero_cross_strategy(self, df):
        if self.pcc is None:
            self.compute_values(df)
        pcc_prev = self.pcc.shift(1)
        cond_bull = (pcc_prev <= self.baseline) & (self.pcc > self.baseline)
        cond_bear = (pcc_prev >= self.baseline) & (self.pcc < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'PCC_Above_Baseline', -1: 'PCC_Below_Baseline', 0: 'PCC_Neutral'}
        mapping_explanation = {
            1: f'PCC crossed above the baseline of {self.baseline}, indicating a shift towards a positive correlation.',
            -1: f'PCC crossed below the baseline of {self.baseline}, indicating a shift towards a negative correlation.',
            0: f'PCC remains around the baseline of {self.baseline}, indicating neutral correlation.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'PCC_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'PCC_Period:{self.period}_TA_Indicator_Value'] = self.pcc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PCC_Period:{self.period}_TA_Indicator_Value'] = self.pcc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.pcc is None:
            self.compute_values(df)
        cond_bull = self.pcc > self.upper_threshold
        cond_bear = self.pcc < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Strong_Positive_Correlation', -1: 'Strong_Negative_Correlation', 0: 'Moderate_Correlation'}
        mapping_explanation = {
            1: f'PCC is above the upper threshold of {self.upper_threshold}, indicating strong positive correlation between {self.col1} and {self.col2}.',
            -1: f'PCC is below the lower threshold of {self.lower_threshold}, indicating strong negative correlation between {self.col1} and {self.col2}.',
            0: f'PCC is between {self.lower_threshold} and {self.upper_threshold}, indicating moderate or neutral correlation.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'PCC_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'PCC_Period:{self.period}_TA_Indicator_Value'] = self.pcc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PCC_Period:{self.period}_TA_Indicator_Value'] = self.pcc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.pcc is None:
            self.compute_values(df)
        diff = self.pcc.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'PCC_Rising', -1: 'PCC_Falling', 0: 'PCC_Unchanged'}
        mapping_explanation = {
            1: 'PCC is rising, indicating a strengthening positive correlation.',
            -1: 'PCC is falling, indicating a weakening positive correlation or strengthening negative correlation.',
            0: 'PCC remains unchanged, indicating stable correlation levels.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'PCC_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'PCC_Period:{self.period}_TA_Indicator_Value'] = self.pcc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PCC_Period:{self.period}_TA_Indicator_Value'] = self.pcc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class PercentBStrategies:
    def __init__(self, period=20, multiplier=2, baseline=0.5, lower_threshold=0.0, upper_threshold=1.0):
        self.period = period
        self.multiplier = multiplier
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.percentb = None

    def compute_values(self, df):
        sma = df['Close'].rolling(window=self.period, min_periods=1).mean()
        std = df['Close'].rolling(window=self.period, min_periods=1).std()
        upper_band = sma + self.multiplier * std
        lower_band = sma - self.multiplier * std
        self.percentb = (df['Close'] - lower_band) / (upper_band - lower_band)
        return self.percentb

    def calculate_scores_zero_cross_strategy(self, df):
        if self.percentb is None:
            self.compute_values(df)
        percentb_prev = self.percentb.shift(1)
        cond_bull = (percentb_prev <= self.baseline) & (self.percentb > self.baseline)
        cond_bear = (percentb_prev >= self.baseline) & (self.percentb < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'PercentB_Above_Baseline', -1: 'PercentB_Below_Baseline', 0: 'PercentB_Neutral'}
        mapping_explanation = {
            1: f'PercentB crossed above the baseline of {self.baseline}, indicating a shift toward bullish momentum.',
            -1: f'PercentB crossed below the baseline of {self.baseline}, indicating a shift toward bearish momentum.',
            0: f'PercentB remains around the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'PercentB_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'PercentB_Period:{self.period}_TA_Indicator_Value'] = self.percentb
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PercentB_Period:{self.period}_TA_Indicator_Value'] = self.percentb
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.percentb is None:
            self.compute_values(df)
        cond_bull = self.percentb < self.lower_threshold
        cond_bear = self.percentb > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Oversold', -1: 'Overbought', 0: 'Normal'}
        mapping_explanation = {
            1: f'PercentB is below the lower threshold of {self.lower_threshold}, indicating oversold conditions and potential bullish reversal.',
            -1: f'PercentB is above the upper threshold of {self.upper_threshold}, indicating overbought conditions and potential bearish reversal.',
            0: f'PercentB is between {self.lower_threshold} and {self.upper_threshold}, indicating normal market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'PercentB_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'PercentB_Period:{self.period}_TA_Indicator_Value'] = self.percentb
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PercentB_Period:{self.period}_TA_Indicator_Value'] = self.percentb
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.percentb is None:
            self.compute_values(df)
        diff = self.percentb.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'PercentB_Rising', -1: 'PercentB_Falling', 0: 'PercentB_Unchanged'}
        mapping_explanation = {
            1: 'PercentB is rising, indicating the price is moving upward from oversold levels.',
            -1: 'PercentB is falling, indicating the price is moving downward from overbought levels.',
            0: 'PercentB remains unchanged, indicating a lack of directional movement.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'PercentB_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'PercentB_Period:{self.period}_TA_Indicator_Value'] = self.percentb
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PercentB_Period:{self.period}_TA_Indicator_Value'] = self.percentb
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class PercentagePriceOscillatorStrategies:
    def __init__(self, fast_period=12, slow_period=26, signal_period=9, baseline=0, lower_threshold=-5, upper_threshold=5):
        self.fast_period = fast_period
        self.slow_period = slow_period
        self.signal_period = signal_period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.ppo = None

    def compute_values(self, df):
        fast_ma = df['Close'].rolling(window=self.fast_period, min_periods=1).mean()
        slow_ma = df['Close'].rolling(window=self.slow_period, min_periods=1).mean()
        self.ppo = ((fast_ma - slow_ma) / slow_ma) * 100
        return self.ppo

    def calculate_scores_zero_cross_strategy(self, df):
        if self.ppo is None:
            self.compute_values(df)
        ppo_prev = self.ppo.shift(1)
        cond_bull = (ppo_prev <= self.baseline) & (self.ppo > self.baseline)
        cond_bear = (ppo_prev >= self.baseline) & (self.ppo < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'PPO_Above_Baseline', -1: 'PPO_Below_Baseline', 0: 'PPO_Neutral'}
        mapping_explanation = {
            1: f'PPO crossed above the baseline of {self.baseline}, indicating bullish momentum as the fast MA rises above the slow MA.',
            -1: f'PPO crossed below the baseline of {self.baseline}, indicating bearish momentum as the fast MA falls below the slow MA.',
            0: f'PPO remains near the baseline of {self.baseline}, indicating a neutral trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'PPO_FP:{self.fast_period}_SP:{self.slow_period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'PPO_FP:{self.fast_period}_SP:{self.slow_period}_TA_Indicator_Value'] = self.ppo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PPO_FP:{self.fast_period}_SP:{self.slow_period}_TA_Indicator_Value'] = self.ppo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.ppo is None:
            self.compute_values(df)
        cond_bull = self.ppo < self.lower_threshold
        cond_bear = self.ppo > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'PPO_Oversold', -1: 'PPO_Overbought', 0: 'PPO_Normal'}
        mapping_explanation = {
            1: f'PPO is below the lower threshold of {self.lower_threshold}, suggesting oversold conditions and a potential bullish reversal.',
            -1: f'PPO is above the upper threshold of {self.upper_threshold}, suggesting overbought conditions and a potential bearish reversal.',
            0: f'PPO is between {self.lower_threshold} and {self.upper_threshold}, indicating normal market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'PPO_FP:{self.fast_period}_SP:{self.slow_period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'PPO_FP:{self.fast_period}_SP:{self.slow_period}_TA_Indicator_Value'] = self.ppo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PPO_FP:{self.fast_period}_SP:{self.slow_period}_TA_Indicator_Value'] = self.ppo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.ppo is None:
            self.compute_values(df)
        diff = self.ppo.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'PPO_Rising', -1: 'PPO_Falling', 0: 'PPO_Unchanged'}
        mapping_explanation = {
            1: 'PPO is rising, indicating strengthening bullish momentum as the fast MA outpaces the slow MA.',
            -1: 'PPO is falling, indicating strengthening bearish momentum as the fast MA lags further behind the slow MA.',
            0: 'PPO remains unchanged, indicating a lack of clear momentum shift.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'PPO_FP:{self.fast_period}_SP:{self.slow_period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'PPO_FP:{self.fast_period}_SP:{self.slow_period}_TA_Indicator_Value'] = self.ppo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PPO_FP:{self.fast_period}_SP:{self.slow_period}_TA_Indicator_Value'] = self.ppo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class PercentageVolumeOscillatorStrategies:
    def __init__(self, fast_period=12, slow_period=26, baseline=0, lower_threshold=-5, upper_threshold=5):
        self.fast_period = fast_period
        self.slow_period = slow_period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.pvo = None

    def compute_values(self, df):
        fast_vol = df['Volume'].rolling(window=self.fast_period, min_periods=1).mean()
        slow_vol = df['Volume'].rolling(window=self.slow_period, min_periods=1).mean()
        self.pvo = ((fast_vol - slow_vol) / slow_vol) * 100
        return self.pvo

    def calculate_scores_zero_cross_strategy(self, df):
        if self.pvo is None:
            self.compute_values(df)
        pvo_prev = self.pvo.shift(1)
        cond_bull = (pvo_prev <= self.baseline) & (self.pvo > self.baseline)
        cond_bear = (pvo_prev >= self.baseline) & (self.pvo < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'PVO_Above_Baseline', -1: 'PVO_Below_Baseline', 0: 'PVO_Neutral'}
        mapping_explanation = {
            1: f'PVO crossed above the baseline of {self.baseline}, indicating rising short-term volume momentum compared to the long-term average.',
            -1: f'PVO crossed below the baseline of {self.baseline}, indicating falling short-term volume momentum relative to the long-term average.',
            0: f'PVO remains near the baseline of {self.baseline}, indicating neutral volume momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'PVO_FP:{self.fast_period}_SP:{self.slow_period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'PVO_FP:{self.fast_period}_SP:{self.slow_period}_TA_Indicator_Value'] = self.pvo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PVO_FP:{self.fast_period}_SP:{self.slow_period}_TA_Indicator_Value'] = self.pvo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.pvo is None:
            self.compute_values(df)
        cond_bull = self.pvo < self.lower_threshold
        cond_bear = self.pvo > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'PVO_Undersold', -1: 'PVO_Overbought', 0: 'PVO_Normal'}
        mapping_explanation = {
            1: f'PVO is below the lower threshold of {self.lower_threshold}, suggesting weak volume momentum and potential bullish reversal.',
            -1: f'PVO is above the upper threshold of {self.upper_threshold}, suggesting strong volume momentum and potential bearish conditions.',
            0: f'PVO is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced volume activity.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'PVO_FP:{self.fast_period}_SP:{self.slow_period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'PVO_FP:{self.fast_period}_SP:{self.slow_period}_TA_Indicator_Value'] = self.pvo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PVO_FP:{self.fast_period}_SP:{self.slow_period}_TA_Indicator_Value'] = self.pvo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.pvo is None:
            self.compute_values(df)
        diff = self.pvo.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'PVO_Rising', -1: 'PVO_Falling', 0: 'PVO_Unchanged'}
        mapping_explanation = {
            1: 'PVO is rising, indicating increasing short-term volume momentum relative to the long-term average.',
            -1: 'PVO is falling, indicating decreasing short-term volume momentum relative to the long-term average.',
            0: 'PVO remains unchanged, indicating stable volume momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'PVO_FP:{self.fast_period}_SP:{self.slow_period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'PVO_FP:{self.fast_period}_SP:{self.slow_period}_TA_Indicator_Value'] = self.pvo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PVO_FP:{self.fast_period}_SP:{self.slow_period}_TA_Indicator_Value'] = self.pvo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class PivotPointsStrategies:
    def __init__(self):
        self.pivot = None
        self.r1 = None
        self.s1 = None
        self.r2 = None
        self.s2 = None
        self.r3 = None
        self.s3 = None

    def compute_values(self, df):
        self.pivot = (df['High'].shift(1) + df['Low'].shift(1) + df['Close'].shift(1)) / 3
        self.r1 = (2 * self.pivot) - df['Low'].shift(1)
        self.s1 = (2 * self.pivot) - df['High'].shift(1)
        self.r2 = self.pivot + (df['High'].shift(1) - df['Low'].shift(1))
        self.s2 = self.pivot - (df['High'].shift(1) - df['Low'].shift(1))
        self.r3 = df['High'].shift(1) + 2 * (self.pivot - df['Low'].shift(1))
        self.s3 = df['Low'].shift(1) - 2 * (df['High'].shift(1) - self.pivot)
        return pd.DataFrame({'Pivot': self.pivot, 'R1': self.r1, 'S1': self.s1, 'R2': self.r2, 'S2': self.s2, 'R3': self.r3, 'S3': self.s3}, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if self.pivot is None:
            self.compute_values(df)
        close_prev = df['Close'].shift(1)
        close_current = df['Close']
        cond_bull = (close_prev <= self.pivot) & (close_current > self.pivot)
        cond_bear = (close_prev >= self.pivot) & (close_current < self.pivot)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Price_Above_Pivot', -1: 'Price_Below_Pivot', 0: 'Price_Near_Pivot'}
        mapping_explanation = {
            1: 'The price has crossed above the Pivot point, suggesting bullish sentiment.',
            -1: 'The price has crossed below the Pivot point, suggesting bearish sentiment.',
            0: 'The price remains near the Pivot point, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = 'Pivot_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df['Pivot_TA_Indicator_Value'] = self.pivot
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['Pivot_TA_Indicator_Value'] = self.pivot
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.pivot is None:
            self.compute_values(df)
        cond_bull = df['Close'] > self.r1
        cond_bear = df['Close'] < self.s1
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Price_Above_R1', -1: 'Price_Below_S1', 0: 'Within_R1_S1'}
        mapping_explanation = {
            1: 'The price is above the first resistance level (R1), suggesting strong bullish momentum.',
            -1: 'The price is below the first support level (S1), suggesting strong bearish momentum.',
            0: 'The price is between the first support and resistance levels, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = 'Pivot_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df['Pivot_TA_Indicator_Value'] = self.pivot
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['Pivot_TA_Indicator_Value'] = self.pivot
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.pivot is None:
            self.compute_values(df)
        diff = self.pivot.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Pivot_Rising', -1: 'Pivot_Falling', 0: 'Pivot_Unchanged'}
        mapping_explanation = {
            1: 'The Pivot point is rising, suggesting a bullish shift in market sentiment.',
            -1: 'The Pivot point is falling, suggesting a bearish shift in market sentiment.',
            0: 'The Pivot point remains unchanged, indicating neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'Pivot_Slope_Signal'
        if append:
            if ta_indicator_value:
                df['Pivot_TA_Indicator_Value'] = self.pivot
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['Pivot_TA_Indicator_Value'] = self.pivot
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class PlusDirectionalIndicatorStrategies:
    def __init__(self, period=14, baseline=20, lower_threshold=15, upper_threshold=40):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.plus_di = None

    def compute_values(self, df):
        high_diff = df['High'] - df['High'].shift(1)
        low_diff = df['Low'].shift(1) - df['Low']
        plus_dm = np.where((high_diff > low_diff) & (high_diff > 0), high_diff, 0)
        tr1 = df['High'] - df['Low']
        tr2 = (df['High'] - df['Close'].shift(1)).abs()
        tr3 = (df['Low'] - df['Close'].shift(1)).abs()
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
        sum_plus_dm = pd.Series(plus_dm, index=df.index).rolling(window=self.period, min_periods=1).sum()
        sum_tr = tr.rolling(window=self.period, min_periods=1).sum()
        self.plus_di = 100 * (sum_plus_dm / sum_tr)
        return self.plus_di

    def calculate_scores_zero_cross_strategy(self, df):
        if self.plus_di is None:
            self.compute_values(df)
        pdi_prev = self.plus_di.shift(1)
        cond_bull = (pdi_prev <= self.baseline) & (self.plus_di > self.baseline)
        cond_bear = (pdi_prev >= self.baseline) & (self.plus_di < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'PlusDI_Above_Baseline', -1: 'PlusDI_Below_Baseline', 0: 'PlusDI_Neutral'}
        mapping_explanation = {
            1: f'PlusDI crossed above the baseline of {self.baseline}, suggesting increasing bullish strength.',
            -1: f'PlusDI crossed below the baseline of {self.baseline}, suggesting weakening bullish strength or potential bearish shift.',
            0: f'PlusDI remains around the baseline of {self.baseline}, indicating neutral directional strength.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'PlusDI_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'PlusDI_Period:{self.period}_TA_Indicator_Value'] = self.plus_di
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PlusDI_Period:{self.period}_TA_Indicator_Value'] = self.plus_di
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.plus_di is None:
            self.compute_values(df)
        cond_bull = self.plus_di > self.upper_threshold
        cond_bear = self.plus_di < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Strong_Bullish', -1: 'Weak_Bullish', 0: 'Neutral'}
        mapping_explanation = {
            1: f'PlusDI is above the upper threshold of {self.upper_threshold}, indicating strong bullish momentum.',
            -1: f'PlusDI is below the lower threshold of {self.lower_threshold}, indicating weak bullish signals or potential bearish pressure.',
            0: f'PlusDI is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced directional strength.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'PlusDI_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'PlusDI_Period:{self.period}_TA_Indicator_Value'] = self.plus_di
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PlusDI_Period:{self.period}_TA_Indicator_Value'] = self.plus_di
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.plus_di is None:
            self.compute_values(df)
        diff = self.plus_di.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'PlusDI_Rising', -1: 'PlusDI_Falling', 0: 'PlusDI_Unchanged'}
        mapping_explanation = {
            1: 'PlusDI is rising, indicating a strengthening bullish trend.',
            -1: 'PlusDI is falling, indicating a weakening bullish trend or emerging bearish sentiment.',
            0: 'PlusDI remains unchanged, indicating stable directional strength.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'PlusDI_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'PlusDI_Period:{self.period}_TA_Indicator_Value'] = self.plus_di
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PlusDI_Period:{self.period}_TA_Indicator_Value'] = self.plus_di
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class PlusDirectionalMovementStrategies:
    def __init__(self, period=14, baseline=0, lower_threshold=0.01, upper_threshold=0.5):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.plus_dm = None

    def compute_values(self, df):
        high_diff = df['High'] - df['High'].shift(1)
        low_diff = df['Low'].shift(1) - df['Low']
        self.plus_dm = pd.Series(np.where((high_diff > low_diff) & (high_diff > 0), high_diff, 0), index=df.index)
        return self.plus_dm

    def calculate_scores_zero_cross_strategy(self, df):
        if self.plus_dm is None:
            self.compute_values(df)
        pdm_prev = self.plus_dm.shift(1)
        cond_bull = (pdm_prev <= self.baseline) & (self.plus_dm > self.baseline)
        cond_bear = (pdm_prev > self.baseline) & (self.plus_dm <= self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'PlusDM_Crossed_Above_Baseline', -1: 'PlusDM_Crossed_Below_Baseline', 0: 'PlusDM_Neutral'}
        mapping_explanation = {
            1: f'PlusDirectionalMovement moved from zero to positive, indicating the start of upward movement.',
            -1: f'PlusDirectionalMovement dropped to zero from a positive value, suggesting a loss of upward momentum.',
            0: 'No significant change in PlusDirectionalMovement was observed.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = 'PlusDM_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df['PlusDM_TA_Indicator_Value'] = self.plus_dm
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['PlusDM_TA_Indicator_Value'] = self.plus_dm
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.plus_dm is None:
            self.compute_values(df)
        cond_bull = self.plus_dm > self.upper_threshold
        cond_bear = self.plus_dm < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Strong_Upward_Movement', -1: 'Weak_Upward_Movement', 0: 'Moderate_Movement'}
        mapping_explanation = {
            1: f'PlusDirectionalMovement is above the upper threshold of {self.upper_threshold}, indicating strong upward momentum.',
            -1: f'PlusDirectionalMovement is below the lower threshold of {self.lower_threshold}, suggesting little to no upward movement.',
            0: f'PlusDirectionalMovement is between {self.lower_threshold} and {self.upper_threshold}, indicating moderate movement.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = 'PlusDM_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df['PlusDM_TA_Indicator_Value'] = self.plus_dm
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['PlusDM_TA_Indicator_Value'] = self.plus_dm
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.plus_dm is None:
            self.compute_values(df)
        diff = self.plus_dm.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'PlusDM_Rising', -1: 'PlusDM_Falling', 0: 'PlusDM_Unchanged'}
        mapping_explanation = {
            1: 'PlusDirectionalMovement is rising, indicating strengthening upward momentum.',
            -1: 'PlusDirectionalMovement is falling, indicating a reduction in upward movement.',
            0: 'PlusDirectionalMovement remains unchanged, indicating stable conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'PlusDM_Slope_Signal'
        if append:
            if ta_indicator_value:
                df['PlusDM_TA_Indicator_Value'] = self.plus_dm
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['PlusDM_TA_Indicator_Value'] = self.plus_dm
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class PositiveVolumeIndexStrategies:
    def __init__(self, baseline=1000, lower_threshold=980, upper_threshold=1020):
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.pvi = None

    def compute_values(self, df):
        pvi_values = []
        pvi = self.baseline
        pvi_values.append(pvi)
        for i in range(1, len(df)):
            if df['Volume'].iloc[i] > df['Volume'].iloc[i-1]:
                ret = (df['Close'].iloc[i] - df['Close'].iloc[i-1]) / df['Close'].iloc[i-1]
                pvi = pvi * (1 + ret)
            pvi_values.append(pvi)
        self.pvi = pd.Series(pvi_values, index=df.index)
        return self.pvi

    def calculate_scores_zero_cross_strategy(self, df):
        if self.pvi is None:
            self.compute_values(df)
        pvi_prev = self.pvi.shift(1)
        cond_bull = (pvi_prev <= self.baseline) & (self.pvi > self.baseline)
        cond_bear = (pvi_prev >= self.baseline) & (self.pvi < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'PVI_Above_Baseline', -1: 'PVI_Below_Baseline', 0: 'PVI_Neutral'}
        mapping_explanation = {
            1: f'PVI crossed above the baseline of {self.baseline}, suggesting bullish conditions on high-volume days.',
            -1: f'PVI crossed below the baseline of {self.baseline}, suggesting bearish conditions on high-volume days.',
            0: f'PVI remains around the baseline of {self.baseline}, indicating neutral market sentiment.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = 'PVI_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df['PVI_TA_Indicator_Value'] = self.pvi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['PVI_TA_Indicator_Value'] = self.pvi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.pvi is None:
            self.compute_values(df)
        cond_bull = self.pvi > self.upper_threshold
        cond_bear = self.pvi < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'PVI_Over_Upper_Threshold', -1: 'PVI_Under_Lower_Threshold', 0: 'PVI_Neutral'}
        mapping_explanation = {
            1: f'PVI is above the upper threshold of {self.upper_threshold}, indicating strong bullish volume activity.',
            -1: f'PVI is below the lower threshold of {self.lower_threshold}, indicating weak bullish volume activity or bearish sentiment.',
            0: f'PVI is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = 'PVI_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df['PVI_TA_Indicator_Value'] = self.pvi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['PVI_TA_Indicator_Value'] = self.pvi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.pvi is None:
            self.compute_values(df)
        diff = self.pvi.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'PVI_Rising', -1: 'PVI_Falling', 0: 'PVI_Unchanged'}
        mapping_explanation = {
            1: 'PVI is rising, indicating increasing bullish momentum on high-volume days.',
            -1: 'PVI is falling, indicating decreasing bullish momentum or emerging bearish conditions on high-volume days.',
            0: 'PVI remains unchanged, indicating stable market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'PVI_Slope_Signal'
        if append:
            if ta_indicator_value:
                df['PVI_TA_Indicator_Value'] = self.pvi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['PVI_TA_Indicator_Value'] = self.pvi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class PrettyGoodOscillatorStrategies:
    def __init__(self, period=14, baseline=0, lower_threshold=-20, upper_threshold=20):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.pgo = None

    def compute_values(self, df):
        sma = df['Close'].rolling(window=self.period, min_periods=1).mean()
        highest = df['High'].rolling(window=self.period, min_periods=1).max()
        lowest = df['Low'].rolling(window=self.period, min_periods=1).min()
        rng = highest - lowest
        self.pgo = 100 * (df['Close'] - sma) / rng
        return self.pgo

    def calculate_scores_zero_cross_strategy(self, df):
        if self.pgo is None:
            self.compute_values(df)
        pgo_prev = self.pgo.shift(1)
        cond_bull = (pgo_prev <= self.baseline) & (self.pgo > self.baseline)
        cond_bear = (pgo_prev >= self.baseline) & (self.pgo < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'PGO_Above_Baseline', -1: 'PGO_Below_Baseline', 0: 'PGO_Neutral'}
        mapping_explanation = {
            1: f'PrettyGoodOscillator crossed above the baseline of {self.baseline}, indicating bullish momentum.',
            -1: f'PrettyGoodOscillator crossed below the baseline of {self.baseline}, indicating bearish momentum.',
            0: f'PrettyGoodOscillator remains near the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'PGO_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'PGO_Period:{self.period}_TA_Indicator_Value'] = self.pgo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PGO_Period:{self.period}_TA_Indicator_Value'] = self.pgo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.pgo is None:
            self.compute_values(df)
        cond_bull = self.pgo < self.lower_threshold
        cond_bear = self.pgo > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Oversold', -1: 'Overbought', 0: 'Normal'}
        mapping_explanation = {
            1: f'PrettyGoodOscillator is below the lower threshold of {self.lower_threshold}, suggesting oversold conditions and potential bullish reversal.',
            -1: f'PrettyGoodOscillator is above the upper threshold of {self.upper_threshold}, suggesting overbought conditions and potential bearish reversal.',
            0: f'PrettyGoodOscillator is between {self.lower_threshold} and {self.upper_threshold}, indicating normal market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'PGO_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'PGO_Period:{self.period}_TA_Indicator_Value'] = self.pgo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PGO_Period:{self.period}_TA_Indicator_Value'] = self.pgo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.pgo is None:
            self.compute_values(df)
        diff = self.pgo.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'PGO_Rising', -1: 'PGO_Falling', 0: 'PGO_Unchanged'}
        mapping_explanation = {
            1: 'PrettyGoodOscillator is rising, indicating strengthening bullish momentum.',
            -1: 'PrettyGoodOscillator is falling, indicating increasing bearish momentum.',
            0: 'PrettyGoodOscillator remains unchanged, indicating stable conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'PGO_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'PGO_Period:{self.period}_TA_Indicator_Value'] = self.pgo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PGO_Period:{self.period}_TA_Indicator_Value'] = self.pgo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class PriceDistanceStrategies:
    def __init__(self, period=20, baseline=0, lower_threshold=-5, upper_threshold=5):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.price_distance = None

    def compute_values(self, df):
        sma = df['Close'].rolling(window=self.period, min_periods=1).mean()
        self.price_distance = ((df['Close'] - sma) / sma) * 100
        return self.price_distance

    def calculate_scores_zero_cross_strategy(self, df):
        if self.price_distance is None:
            self.compute_values(df)
        pd_prev = self.price_distance.shift(1)
        cond_bull = (pd_prev <= self.baseline) & (self.price_distance > self.baseline)
        cond_bear = (pd_prev >= self.baseline) & (self.price_distance < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'PriceDist_Above_Baseline', -1: 'PriceDist_Below_Baseline', 0: 'PriceDist_Neutral'}
        mapping_explanation = {
            1: f'PriceDistance crossed above the baseline of {self.baseline}, indicating the price is significantly above its moving average.',
            -1: f'PriceDistance crossed below the baseline of {self.baseline}, indicating the price is significantly below its moving average.',
            0: f'PriceDistance remains near the baseline of {self.baseline}, suggesting stable price behavior relative to its average.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'PriceDist_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'PriceDist_Period:{self.period}_TA_Indicator_Value'] = self.price_distance
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PriceDist_Period:{self.period}_TA_Indicator_Value'] = self.price_distance
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.price_distance is None:
            self.compute_values(df)
        cond_bull = self.price_distance > self.upper_threshold
        cond_bear = self.price_distance < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'PriceDist_Overbought', -1: 'PriceDist_Oversold', 0: 'PriceDist_Normal'}
        mapping_explanation = {
            1: f'PriceDistance is above the upper threshold of {self.upper_threshold}, suggesting the price is significantly above its moving average (overbought).',
            -1: f'PriceDistance is below the lower threshold of {self.lower_threshold}, suggesting the price is significantly below its moving average (oversold).',
            0: f'PriceDistance is between {self.lower_threshold} and {self.upper_threshold}, indicating normal conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'PriceDist_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'PriceDist_Period:{self.period}_TA_Indicator_Value'] = self.price_distance
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PriceDist_Period:{self.period}_TA_Indicator_Value'] = self.price_distance
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.price_distance is None:
            self.compute_values(df)
        diff = self.price_distance.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'PriceDist_Rising', -1: 'PriceDist_Falling', 0: 'PriceDist_Unchanged'}
        mapping_explanation = {
            1: 'PriceDistance is rising, indicating that the price is moving further above its moving average.',
            -1: 'PriceDistance is falling, indicating that the price is moving further below its moving average.',
            0: 'PriceDistance remains unchanged, suggesting stable relative pricing.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'PriceDist_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'PriceDist_Period:{self.period}_TA_Indicator_Value'] = self.price_distance
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PriceDist_Period:{self.period}_TA_Indicator_Value'] = self.price_distance
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class PriceVolumeRankStrategies:
    def __init__(self, period=20, baseline=0, lower_threshold=-20, upper_threshold=20):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.pvr = None

    def compute_values(self, df):
        pv = df['Close'] * df['Volume']
        rolling_min = pv.rolling(window=self.period, min_periods=1).min()
        rolling_max = pv.rolling(window=self.period, min_periods=1).max()
        self.pvr = ((pv - rolling_min) / (rolling_max - rolling_min)) * 100 - 50
        return self.pvr

    def calculate_scores_zero_cross_strategy(self, df):
        if self.pvr is None:
            self.compute_values(df)
        pvr_prev = self.pvr.shift(1)
        cond_bull = (pvr_prev <= self.baseline) & (self.pvr > self.baseline)
        cond_bear = (pvr_prev >= self.baseline) & (self.pvr < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'PVR_Above_Baseline', -1: 'PVR_Below_Baseline', 0: 'PVR_Neutral'}
        mapping_explanation = {
            1: f'PriceVolumeRank crossed above the baseline of {self.baseline}, indicating strengthening price-volume performance.',
            -1: f'PriceVolumeRank crossed below the baseline of {self.baseline}, indicating weakening price-volume performance.',
            0: f'PriceVolumeRank remains near the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'PVR_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'PVR_Period:{self.period}_TA_Indicator_Value'] = self.pvr
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PVR_Period:{self.period}_TA_Indicator_Value'] = self.pvr
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.pvr is None:
            self.compute_values(df)
        cond_bull = self.pvr > self.upper_threshold
        cond_bear = self.pvr < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'PVR_High', -1: 'PVR_Low', 0: 'PVR_Normal'}
        mapping_explanation = {
            1: f'PriceVolumeRank is above the upper threshold of {self.upper_threshold}, indicating exceptionally strong price-volume performance.',
            -1: f'PriceVolumeRank is below the lower threshold of {self.lower_threshold}, indicating exceptionally weak price-volume performance.',
            0: f'PriceVolumeRank is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'PVR_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'PVR_Period:{self.period}_TA_Indicator_Value'] = self.pvr
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PVR_Period:{self.period}_TA_Indicator_Value'] = self.pvr
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.pvr is None:
            self.compute_values(df)
        diff = self.pvr.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'PVR_Rising', -1: 'PVR_Falling', 0: 'PVR_Unchanged'}
        mapping_explanation = {
            1: 'PriceVolumeRank is rising, indicating increasing bullish momentum in the price-volume relationship.',
            -1: 'PriceVolumeRank is falling, indicating increasing bearish momentum in the price-volume relationship.',
            0: 'PriceVolumeRank remains unchanged, indicating stable price-volume conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'PVR_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'PVR_Period:{self.period}_TA_Indicator_Value'] = self.pvr
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PVR_Period:{self.period}_TA_Indicator_Value'] = self.pvr
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class PriceVolumeTrendStrategies:
    def __init__(self, baseline=0, lower_threshold=-100, upper_threshold=100):
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.pvt = None

    def compute_values(self, df):
        delta = df['Close'] - df['Close'].shift(1)
        pct_change = delta / df['Close'].shift(1)
        pvt_values = (df['Volume'] * pct_change).fillna(0).cumsum()
        self.pvt = pd.Series(pvt_values, index=df.index)
        return self.pvt

    def calculate_scores_zero_cross_strategy(self, df):
        if self.pvt is None:
            self.compute_values(df)
        pvt_prev = self.pvt.shift(1)
        cond_bull = (pvt_prev <= self.baseline) & (self.pvt > self.baseline)
        cond_bear = (pvt_prev >= self.baseline) & (self.pvt < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'PVT_Above_Baseline', -1: 'PVT_Below_Baseline', 0: 'PVT_Neutral'}
        mapping_explanation = {
            1: f'PriceVolumeTrend crossed above the baseline of {self.baseline}, suggesting bullish momentum.',
            -1: f'PriceVolumeTrend crossed below the baseline of {self.baseline}, suggesting bearish momentum.',
            0: f'PriceVolumeTrend remains around the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = 'PVT_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df['PVT_TA_Indicator_Value'] = self.pvt
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['PVT_TA_Indicator_Value'] = self.pvt
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.pvt is None:
            self.compute_values(df)
        cond_bull = self.pvt > self.upper_threshold
        cond_bear = self.pvt < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'PVT_High', -1: 'PVT_Low', 0: 'PVT_Normal'}
        mapping_explanation = {
            1: f'PriceVolumeTrend is above the upper threshold of {self.upper_threshold}, indicating strong bullish volume-price momentum.',
            -1: f'PriceVolumeTrend is below the lower threshold of {self.lower_threshold}, indicating strong bearish volume-price momentum.',
            0: f'PriceVolumeTrend is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = 'PVT_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df['PVT_TA_Indicator_Value'] = self.pvt
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['PVT_TA_Indicator_Value'] = self.pvt
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.pvt is None:
            self.compute_values(df)
        diff = self.pvt.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'PVT_Rising', -1: 'PVT_Falling', 0: 'PVT_Unchanged'}
        mapping_explanation = {
            1: 'PriceVolumeTrend is rising, indicating increasing bullish momentum.',
            -1: 'PriceVolumeTrend is falling, indicating increasing bearish momentum.',
            0: 'PriceVolumeTrend remains unchanged, indicating stable market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'PVT_Slope_Signal'
        if append:
            if ta_indicator_value:
                df['PVT_TA_Indicator_Value'] = self.pvt
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['PVT_TA_Indicator_Value'] = self.pvt
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class PriceVolumeStrategies:
    def __init__(self, period=20, baseline=0, lower_threshold=-5, upper_threshold=5):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.price_volume = None

    def compute_values(self, df):
        pv = df['Close'] * df['Volume']
        sma_pv = pv.rolling(window=self.period, min_periods=1).mean()
        self.price_volume = ((pv - sma_pv) / sma_pv) * 100
        return self.price_volume

    def calculate_scores_zero_cross_strategy(self, df):
        if self.price_volume is None:
            self.compute_values(df)
        pv_prev = self.price_volume.shift(1)
        cond_bull = (pv_prev <= self.baseline) & (self.price_volume > self.baseline)
        cond_bear = (pv_prev >= self.baseline) & (self.price_volume < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'PV_Above_Baseline', -1: 'PV_Below_Baseline', 0: 'PV_Neutral'}
        mapping_explanation = {
            1: f'PriceVolume crossed above the baseline of {self.baseline}, suggesting that the current price-volume product is higher than its moving average.',
            -1: f'PriceVolume crossed below the baseline of {self.baseline}, suggesting that the current price-volume product is lower than its moving average.',
            0: f'PriceVolume remains near the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'PV_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'PV_Period:{self.period}_TA_Indicator_Value'] = self.price_volume
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PV_Period:{self.period}_TA_Indicator_Value'] = self.price_volume
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.price_volume is None:
            self.compute_values(df)
        cond_bull = self.price_volume > self.upper_threshold
        cond_bear = self.price_volume < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'PV_High', -1: 'PV_Low', 0: 'PV_Normal'}
        mapping_explanation = {
            1: f'PriceVolume is above the upper threshold of {self.upper_threshold}, suggesting exceptionally strong price-volume performance.',
            -1: f'PriceVolume is below the lower threshold of {self.lower_threshold}, suggesting exceptionally weak price-volume performance.',
            0: f'PriceVolume is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'PV_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'PV_Period:{self.period}_TA_Indicator_Value'] = self.price_volume
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PV_Period:{self.period}_TA_Indicator_Value'] = self.price_volume
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.price_volume is None:
            self.compute_values(df)
        diff = self.price_volume.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'PV_Rising', -1: 'PV_Falling', 0: 'PV_Unchanged'}
        mapping_explanation = {
            1: 'PriceVolume is rising, indicating that the current price-volume product is diverging positively from its average.',
            -1: 'PriceVolume is falling, indicating that the current price-volume product is diverging negatively from its average.',
            0: 'PriceVolume remains unchanged, suggesting stability in the price-volume relationship.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'PV_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'PV_Period:{self.period}_TA_Indicator_Value'] = self.price_volume
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PV_Period:{self.period}_TA_Indicator_Value'] = self.price_volume
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class PsychologicalLineStrategies:
    def __init__(self, period=14, baseline=50, lower_threshold=30, upper_threshold=70):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.psy = None

    def compute_values(self, df):
        up_days = df['Close'].gt(df['Close'].shift(1))
        self.psy = up_days.rolling(window=self.period, min_periods=1).sum() / self.period * 100
        return self.psy

    def calculate_scores_zero_cross_strategy(self, df):
        if self.psy is None:
            self.compute_values(df)
        psy_prev = self.psy.shift(1)
        cond_bull = (psy_prev <= self.baseline) & (self.psy > self.baseline)
        cond_bear = (psy_prev >= self.baseline) & (self.psy < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'PSY_Above_Baseline', -1: 'PSY_Below_Baseline', 0: 'PSY_Neutral'}
        mapping_explanation = {
            1: f'Psychological Line crossed above the baseline of {self.baseline}, suggesting potential bullish momentum.',
            -1: f'Psychological Line crossed below the baseline of {self.baseline}, suggesting potential bearish momentum.',
            0: f'Psychological Line remains around the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'PSY_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'PSY_Period:{self.period}_TA_Indicator_Value'] = self.psy
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PSY_Period:{self.period}_TA_Indicator_Value'] = self.psy
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.psy is None:
            self.compute_values(df)
        cond_bull = self.psy < self.lower_threshold
        cond_bear = self.psy > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Oversold', -1: 'Overbought', 0: 'Neutral'}
        mapping_explanation = {
            1: f'Psychological Line is below the lower threshold of {self.lower_threshold}, indicating oversold conditions and a potential bullish reversal.',
            -1: f'Psychological Line is above the upper threshold of {self.upper_threshold}, indicating overbought conditions and a potential bearish reversal.',
            0: f'Psychological Line is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'PSY_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'PSY_Period:{self.period}_TA_Indicator_Value'] = self.psy
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PSY_Period:{self.period}_TA_Indicator_Value'] = self.psy
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.psy is None:
            self.compute_values(df)
        diff = self.psy.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'PSY_Rising', -1: 'PSY_Falling', 0: 'PSY_Unchanged'}
        mapping_explanation = {
            1: 'Psychological Line is rising, indicating increasing bullish momentum.',
            -1: 'Psychological Line is falling, indicating increasing bearish momentum.',
            0: 'Psychological Line remains unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'PSY_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'PSY_Period:{self.period}_TA_Indicator_Value'] = self.psy
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PSY_Period:{self.period}_TA_Indicator_Value'] = self.psy
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


class PriceVolumeStrategies:
    def __init__(self, period=20, baseline=0, lower_threshold=-5, upper_threshold=5):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.price_volume = None

    def compute_values(self, df):
        pv = df['Close'] * df['Volume']
        sma_pv = pv.rolling(window=self.period, min_periods=1).mean()
        self.price_volume = ((pv - sma_pv) / sma_pv) * 100
        return self.price_volume

    def calculate_scores_zero_cross_strategy(self, df):
        if self.price_volume is None:
            self.compute_values(df)
        pv_prev = self.price_volume.shift(1)
        cond_bull = (pv_prev <= self.baseline) & (self.price_volume > self.baseline)
        cond_bear = (pv_prev >= self.baseline) & (self.price_volume < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'PV_Above_Baseline', -1: 'PV_Below_Baseline', 0: 'PV_Neutral'}
        mapping_explanation = {
            1: f'PriceVolume crossed above the baseline of {self.baseline}, suggesting the current price-volume product is stronger than its average.',
            -1: f'PriceVolume crossed below the baseline of {self.baseline}, suggesting the current price-volume product is weaker than its average.',
            0: f'PriceVolume remains near the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'PV_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'PV_Period:{self.period}_TA_Indicator_Value'] = self.price_volume
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PV_Period:{self.period}_TA_Indicator_Value'] = self.price_volume
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.price_volume is None:
            self.compute_values(df)
        cond_bull = self.price_volume > self.upper_threshold
        cond_bear = self.price_volume < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'PV_High', -1: 'PV_Low', 0: 'PV_Normal'}
        mapping_explanation = {
            1: f'PriceVolume is above the upper threshold of {self.upper_threshold}, indicating exceptionally strong price-volume performance.',
            -1: f'PriceVolume is below the lower threshold of {self.lower_threshold}, indicating exceptionally weak price-volume performance.',
            0: f'PriceVolume is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'PV_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'PV_Period:{self.period}_TA_Indicator_Value'] = self.price_volume
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PV_Period:{self.period}_TA_Indicator_Value'] = self.price_volume
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.price_volume is None:
            self.compute_values(df)
        diff = self.price_volume.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'PV_Rising', -1: 'PV_Falling', 0: 'PV_Unchanged'}
        mapping_explanation = {
            1: 'PriceVolume is rising, indicating that the price-volume product is diverging positively from its average.',
            -1: 'PriceVolume is falling, indicating that the price-volume product is diverging negatively from its average.',
            0: 'PriceVolume remains unchanged, suggesting stable price-volume dynamics.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'PV_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'PV_Period:{self.period}_TA_Indicator_Value'] = self.price_volume
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'PV_Period:{self.period}_TA_Indicator_Value'] = self.price_volume
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


class QStickStrategies:
    def __init__(self, period=10, baseline=0, upper_threshold=0.2, lower_threshold=-0.2):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.qstick = None

    def compute_values(self, df):
        diff = df['Close'] - df['Open']
        alpha = 2 / (self.period + 1)
        ema = [diff.iloc[0]]
        for i in range(1, len(diff)):
            ema.append(alpha * diff.iloc[i] + (1 - alpha) * ema[i - 1])
        return pd.Series(ema, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if self.qstick is None:
            self.qstick = self.compute_values(df)
        qstick_prev = self.qstick.shift(1)
        cond_bull = (qstick_prev <= self.baseline) & (self.qstick > self.baseline)
        cond_bear = (qstick_prev >= self.baseline) & (self.qstick < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'QStick_Above_Zero', -1: 'QStick_Below_Zero', 0: 'QStick_Neutral'}
        mapping_explanation = {
            1: 'QStick crossed above zero, indicating bullish market sentiment.',
            -1: 'QStick crossed below zero, indicating bearish market sentiment.',
            0: 'QStick remains neutral around zero, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'QStick_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'QStick_Period:{self.period}_TA_Indicator_Value'] = self.qstick
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'QStick_Period:{self.period}_TA_Indicator_Value'] = self.qstick
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.qstick is None:
            self.qstick = self.compute_values(df)
        cond_bull = self.qstick > self.upper_threshold
        cond_bear = self.qstick < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'QStick_Strong_Bullish', -1: 'QStick_Strong_Bearish', 0: 'QStick_Neutral'}
        mapping_explanation = {
            1: f'QStick is above the upper threshold of {self.upper_threshold}, indicating strong bullish momentum.',
            -1: f'QStick is below the lower threshold of {self.lower_threshold}, indicating strong bearish momentum.',
            0: 'QStick is within the threshold range, indicating no strong directional bias.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'QStick_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'QStick_Period:{self.period}_TA_Indicator_Value'] = self.qstick
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'QStick_Period:{self.period}_TA_Indicator_Value'] = self.qstick
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.qstick is None:
            self.qstick = self.compute_values(df)
        diff = self.qstick.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'QStick_Rising', -1: 'QStick_Falling', 0: 'QStick_Unchanged'}
        mapping_explanation = {
            1: 'QStick is rising, indicating strengthening bullish momentum.',
            -1: 'QStick is falling, indicating strengthening bearish momentum.',
            0: 'QStick remains unchanged, indicating a lack of clear directional movement.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'QStick_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'QStick_Period:{self.period}_TA_Indicator_Value'] = self.qstick
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'QStick_Period:{self.period}_TA_Indicator_Value'] = self.qstick
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


class QuantitativeQualitativeEstimationStrategies:
    def __init__(self, period=14, baseline=0, lower_threshold=-10, upper_threshold=10):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.qqe = None

    def compute_values(self, df):
        price_sma = df['Close'].rolling(window=self.period, min_periods=1).mean()
        vol_sma = df['Volume'].rolling(window=self.period, min_periods=1).mean()
        price_dev = ((df['Close'] - price_sma) / price_sma) * 100
        vol_dev = ((df['Volume'] - vol_sma) / vol_sma) * 100
        self.qqe = (price_dev + vol_dev) / 2
        return self.qqe

    def calculate_scores_zero_cross_strategy(self, df):
        if self.qqe is None:
            self.compute_values(df)
        qqe_prev = self.qqe.shift(1)
        cond_bull = (qqe_prev <= self.baseline) & (self.qqe > self.baseline)
        cond_bear = (qqe_prev >= self.baseline) & (self.qqe < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'QQE_Above_Baseline', -1: 'QQE_Below_Baseline', 0: 'QQE_Neutral'}
        mapping_explanation = {
            1: f'QQE crossed above the baseline of {self.baseline}, suggesting bullish conditions.',
            -1: f'QQE crossed below the baseline of {self.baseline}, suggesting bearish conditions.',
            0: f'QQE remains near the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'QQE_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'QQE_Period:{self.period}_TA_Indicator_Value'] = self.qqe
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'QQE_Period:{self.period}_TA_Indicator_Value'] = self.qqe
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.qqe is None:
            self.compute_values(df)
        cond_bull = self.qqe > self.upper_threshold
        cond_bear = self.qqe < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'QQE_High', -1: 'QQE_Low', 0: 'QQE_Normal'}
        mapping_explanation = {
            1: f'QQE is above the upper threshold of {self.upper_threshold}, indicating strong bullish sentiment.',
            -1: f'QQE is below the lower threshold of {self.lower_threshold}, indicating strong bearish sentiment.',
            0: f'QQE is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'QQE_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'QQE_Period:{self.period}_TA_Indicator_Value'] = self.qqe
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'QQE_Period:{self.period}_TA_Indicator_Value'] = self.qqe
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.qqe is None:
            self.compute_values(df)
        diff = self.qqe.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'QQE_Rising', -1: 'QQE_Falling', 0: 'QQE_Unchanged'}
        mapping_explanation = {
            1: 'QQE is rising, indicating increasing bullish momentum.',
            -1: 'QQE is falling, indicating increasing bearish momentum.',
            0: 'QQE remains unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'QQE_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'QQE_Period:{self.period}_TA_Indicator_Value'] = self.qqe
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'QQE_Period:{self.period}_TA_Indicator_Value'] = self.qqe
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



  
class RateOfChangeStrategies:
    def __init__(self, period=14, upper_threshold=5, lower_threshold=-5):
        self.period = period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold

    def compute_values(self, df):
        roc = ((df['Close'] - df['Close'].shift(self.period)) / df['Close'].shift(self.period)) * 100
        return pd.Series(roc, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'roc') or self.roc is None:
            self.roc = self.compute_values(df)
        roc_prev = self.roc.shift(1)
        cond_bull = (roc_prev <= 0) & (self.roc > 0)
        cond_bear = (roc_prev >= 0) & (self.roc < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'ROC_Above_Zero', -1: 'ROC_Below_Zero', 0: 'ROC_Neutral'}
        mapping_explanation = {
            1: 'ROC crossed above zero, indicating bullish momentum.',
            -1: 'ROC crossed below zero, indicating bearish momentum.',
            0: 'ROC remains neutral around zero.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'ROC_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'ROC_Period:{self.period}_TA_Indicator_Value'] = self.roc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ROC_Period:{self.period}_TA_Indicator_Value'] = self.roc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'roc') or self.roc is None:
            self.roc = self.compute_values(df)
        cond_bull = self.roc > self.upper_threshold
        cond_bear = self.roc < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'ROC_High', -1: 'ROC_Low', 0: 'ROC_Midrange'}
        mapping_explanation = {
            1: f'ROC is above the upper threshold of {self.upper_threshold}, indicating strong bullish momentum.',
            -1: f'ROC is below the lower threshold of {self.lower_threshold}, indicating strong bearish momentum.',
            0: 'ROC is within the defined thresholds, indicating moderate momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'ROC_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'ROC_Period:{self.period}_TA_Indicator_Value'] = self.roc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ROC_Period:{self.period}_TA_Indicator_Value'] = self.roc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'roc') or self.roc is None:
            self.roc = self.compute_values(df)
        diff = self.roc.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'ROC_Rising', -1: 'ROC_Falling', 0: 'ROC_Unchanged'}
        mapping_explanation = {
            1: 'ROC is increasing, indicating strengthening bullish momentum.',
            -1: 'ROC is decreasing, indicating strengthening bearish momentum.',
            0: 'ROC remains unchanged, indicating stable momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'ROC_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'ROC_Period:{self.period}_TA_Indicator_Value'] = self.roc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ROC_Period:{self.period}_TA_Indicator_Value'] = self.roc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
  
class RelativeStrengthIndexStrategies:
    def __init__(self, period=14, baseline=50, lower_threshold=30, upper_threshold=70):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold

    def compute_values(self, df):
        delta = df['Close'].diff()
        gain = delta.clip(lower=0)
        loss = -delta.clip(upper=0)
        avg_gain = gain.rolling(window=self.period, min_periods=1).mean()
        avg_loss = loss.rolling(window=self.period, min_periods=1).mean()
        rs = avg_gain / avg_loss.replace(0, 1e-10)
        rsi = 100 - (100 / (1 + rs))
        return pd.Series(rsi, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'rsi') or self.rsi is None:
            self.rsi = self.compute_values(df)
        rsi_prev = self.rsi.shift(1)
        cond_bull = (rsi_prev <= self.baseline) & (self.rsi > self.baseline)
        cond_bear = (rsi_prev >= self.baseline) & (self.rsi < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'RSI_Above_Baseline', -1: 'RSI_Below_Baseline', 0: 'RSI_Neutral'}
        mapping_explanation = {
            1: f'RSI crossed above the baseline of {self.baseline}, indicating bullish momentum.',
            -1: f'RSI crossed below the baseline of {self.baseline}, indicating bearish momentum.',
            0: f'RSI remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'RSI_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'RSI_Period:{self.period}_TA_Indicator_Value'] = self.rsi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'RSI_Period:{self.period}_TA_Indicator_Value'] = self.rsi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'rsi') or self.rsi is None:
            self.rsi = self.compute_values(df)
        cond_bull = self.rsi < self.lower_threshold
        cond_bear = self.rsi > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'RSI_Oversold', -1: 'RSI_Overbought', 0: 'RSI_Neutral'}
        mapping_explanation = {
            1: f'RSI is below the lower threshold of {self.lower_threshold}, indicating oversold conditions and potential bullish reversal.',
            -1: f'RSI is above the upper threshold of {self.upper_threshold}, indicating overbought conditions and potential bearish reversal.',
            0: 'RSI is within the normal range, indicating balanced market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'RSI_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'RSI_Period:{self.period}_TA_Indicator_Value'] = self.rsi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'RSI_Period:{self.period}_TA_Indicator_Value'] = self.rsi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'rsi') or self.rsi is None:
            self.rsi = self.compute_values(df)
        diff = self.rsi.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'RSI_Rising', -1: 'RSI_Falling', 0: 'RSI_Unchanged'}
        mapping_explanation = {
            1: 'RSI is rising, indicating increasing bullish momentum.',
            -1: 'RSI is falling, indicating increasing bearish momentum.',
            0: 'RSI remains unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'RSI_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'RSI_Period:{self.period}_TA_Indicator_Value'] = self.rsi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'RSI_Period:{self.period}_TA_Indicator_Value'] = self.rsi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)




  
  
class RelativeStrengthXtraStrategies:
    def __init__(self, period=14, baseline=50, lower_threshold=30, upper_threshold=70):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold

    def compute_values(self, df):
        delta = df['Close'].diff()
        gain = delta.clip(lower=0)
        loss = -delta.clip(upper=0)
        avg_gain = gain.rolling(window=self.period, min_periods=1).mean()
        avg_loss = loss.rolling(window=self.period, min_periods=1).mean()
        rs = avg_gain / avg_loss.replace(0, 1e-10)
        rsi = 100 - (100 / (1 + rs))
        intraday_pct = ((df['Close'] - df['Open']) / df['Open']) * 100
        intraday_avg = intraday_pct.rolling(window=self.period, min_periods=1).mean()
        self.rsxtra = (rsi + intraday_avg) / 2
        return pd.Series(self.rsxtra, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'rsxtra') or self.rsxtra is None:
            self.rsxtra = self.compute_values(df)
        rsxtra_prev = self.rsxtra.shift(1)
        cond_bull = (rsxtra_prev <= self.baseline) & (self.rsxtra > self.baseline)
        cond_bear = (rsxtra_prev >= self.baseline) & (self.rsxtra < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'RSXTRA_Above_Baseline', -1: 'RSXTRA_Below_Baseline', 0: 'RSXTRA_Neutral'}
        mapping_explanation = {
            1: f'RSXTRA crossed above the baseline of {self.baseline}, suggesting bullish momentum.',
            -1: f'RSXTRA crossed below the baseline of {self.baseline}, suggesting bearish momentum.',
            0: f'RSXTRA remains around the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'RSXTRA_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'RSXTRA_Period:{self.period}_TA_Indicator_Value'] = self.rsxtra
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'RSXTRA_Period:{self.period}_TA_Indicator_Value'] = self.rsxtra
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'rsxtra') or self.rsxtra is None:
            self.rsxtra = self.compute_values(df)
        cond_bull = self.rsxtra < self.lower_threshold
        cond_bear = self.rsxtra > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'RSXTRA_Oversold', -1: 'RSXTRA_Overbought', 0: 'RSXTRA_Neutral'}
        mapping_explanation = {
            1: f'RSXTRA is below the lower threshold of {self.lower_threshold}, indicating potential oversold conditions and a bullish reversal.',
            -1: f'RSXTRA is above the upper threshold of {self.upper_threshold}, indicating potential overbought conditions and a bearish reversal.',
            0: 'RSXTRA is within normal levels, suggesting neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'RSXTRA_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'RSXTRA_Period:{self.period}_TA_Indicator_Value'] = self.rsxtra
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'RSXTRA_Period:{self.period}_TA_Indicator_Value'] = self.rsxtra
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'rsxtra') or self.rsxtra is None:
            self.rsxtra = self.compute_values(df)
        diff = self.rsxtra.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'RSXTRA_Rising', -1: 'RSXTRA_Falling', 0: 'RSXTRA_Unchanged'}
        mapping_explanation = {
            1: 'RSXTRA is rising, indicating strengthening bullish momentum.',
            -1: 'RSXTRA is falling, indicating strengthening bearish momentum.',
            0: 'RSXTRA remains unchanged, indicating neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'RSXTRA_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'RSXTRA_Period:{self.period}_TA_Indicator_Value'] = self.rsxtra
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'RSXTRA_Period:{self.period}_TA_Indicator_Value'] = self.rsxtra
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)





  
  
class RelativeVigorIndexStrategies:
    def __init__(self, period=10, baseline=0, upper_threshold=0.2, lower_threshold=-0.2):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold

    def compute_values(self, df):
        num = df['Close'] - df['Open']
        den = df['High'] - df['Low']
        sma_num = pd.Series(num).rolling(window=self.period, min_periods=1).mean()
        sma_den = pd.Series(den).rolling(window=self.period, min_periods=1).mean()
        rvi = np.where(sma_den == 0, 0, sma_num / sma_den)
        return pd.Series(rvi, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'rvi') or self.rvi is None:
            self.rvi = self.compute_values(df)
        rvi_prev = self.rvi.shift(1)
        cond_bull = (rvi_prev <= self.baseline) & (self.rvi > self.baseline)
        cond_bear = (rvi_prev >= self.baseline) & (self.rvi < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'RVI_Above_Baseline', -1: 'RVI_Below_Baseline', 0: 'RVI_Neutral'}
        mapping_explanation = {
            1: f'RVI crossed above the baseline of {self.baseline}, indicating bullish momentum.',
            -1: f'RVI crossed below the baseline of {self.baseline}, indicating bearish momentum.',
            0: f'RVI remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'RVI_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'RVI_Period:{self.period}_TA_Indicator_Value'] = self.rvi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'RVI_Period:{self.period}_TA_Indicator_Value'] = self.rvi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'rvi') or self.rvi is None:
            self.rvi = self.compute_values(df)
        cond_bull = self.rvi < self.lower_threshold
        cond_bear = self.rvi > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'RVI_Oversold', -1: 'RVI_Overbought', 0: 'RVI_Neutral'}
        mapping_explanation = {
            1: f'RVI is below the lower threshold of {self.lower_threshold}, indicating oversold conditions and a potential bullish reversal.',
            -1: f'RVI is above the upper threshold of {self.upper_threshold}, indicating overbought conditions and a potential bearish reversal.',
            0: f'RVI is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'RVI_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'RVI_Period:{self.period}_TA_Indicator_Value'] = self.rvi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'RVI_Period:{self.period}_TA_Indicator_Value'] = self.rvi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'rvi') or self.rvi is None:
            self.rvi = self.compute_values(df)
        diff = self.rvi.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'RVI_Rising', -1: 'RVI_Falling', 0: 'RVI_Unchanged'}
        mapping_explanation = {
            1: 'RVI is rising, indicating strengthening bullish momentum.',
            -1: 'RVI is falling, indicating strengthening bearish momentum.',
            0: 'RVI remains unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'RVI_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'RVI_Period:{self.period}_TA_Indicator_Value'] = self.rvi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'RVI_Period:{self.period}_TA_Indicator_Value'] = self.rvi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
  
class RelativeVolatilityIndexStrategies:
    def __init__(self, period=10, baseline=50, upper_threshold=70, lower_threshold=30):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold

    def compute_values(self, df):
        delta = df['Close'].diff()
        up_vol = pd.Series(np.where(delta > 0, delta, 0)).rolling(window=self.period, min_periods=1).std()
        down_vol = pd.Series(np.where(delta < 0, -delta, 0)).rolling(window=self.period, min_periods=1).std()
        rs = np.where(down_vol == 0, np.inf, up_vol / down_vol)
        rvi = 100 - (100 / (1 + rs))
        return pd.Series(rvi, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'rvi') or self.rvi is None:
            self.rvi = self.compute_values(df)
        rvi_prev = self.rvi.shift(1)
        cond_bull = (rvi_prev <= self.baseline) & (self.rvi > self.baseline)
        cond_bear = (rvi_prev >= self.baseline) & (self.rvi < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'RVI_Above_Baseline', -1: 'RVI_Below_Baseline', 0: 'RVI_Neutral'}
        mapping_explanation = {
            1: f'RVI crossed above the baseline of {self.baseline}, indicating bullish volatility dominance.',
            -1: f'RVI crossed below the baseline of {self.baseline}, indicating bearish volatility dominance.',
            0: f'RVI remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'RVI_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'RVI_Period:{self.period}_TA_Indicator_Value'] = self.rvi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'RVI_Period:{self.period}_TA_Indicator_Value'] = self.rvi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'rvi') or self.rvi is None:
            self.rvi = self.compute_values(df)
        cond_bull = self.rvi < self.lower_threshold
        cond_bear = self.rvi > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'RVI_Oversold', -1: 'RVI_Overbought', 0: 'RVI_Neutral'}
        mapping_explanation = {
            1: f'RVI is below the lower threshold of {self.lower_threshold}, indicating oversold conditions and a potential bullish reversal.',
            -1: f'RVI is above the upper threshold of {self.upper_threshold}, indicating overbought conditions and a potential bearish reversal.',
            0: f'RVI is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced volatility.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'RVI_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'RVI_Period:{self.period}_TA_Indicator_Value'] = self.rvi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'RVI_Period:{self.period}_TA_Indicator_Value'] = self.rvi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'rvi') or self.rvi is None:
            self.rvi = self.compute_values(df)
        diff = self.rvi.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'RVI_Rising', -1: 'RVI_Falling', 0: 'RVI_Unchanged'}
        mapping_explanation = {
            1: 'RVI is rising, indicating increasing bullish volatility dominance.',
            -1: 'RVI is falling, indicating increasing bearish volatility dominance.',
            0: 'RVI remains unchanged, indicating balanced volatility.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'RVI_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'RVI_Period:{self.period}_TA_Indicator_Value'] = self.rvi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'RVI_Period:{self.period}_TA_Indicator_Value'] = self.rvi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
  
class SchaffTrendCycleStrategies:
    def __init__(self, fast_period=23, slow_period=50, cycle_period=10, baseline=50, upper_threshold=75, lower_threshold=25):
        self.fast_period = fast_period
        self.slow_period = slow_period
        self.cycle_period = cycle_period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold

    def compute_values(self, df):
        fast_ema = df['Close'].ewm(span=self.fast_period, adjust=False).mean()
        slow_ema = df['Close'].ewm(span=self.slow_period, adjust=False).mean()
        macd = fast_ema - slow_ema
        lowest_macd = macd.rolling(window=self.cycle_period, min_periods=1).min()
        highest_macd = macd.rolling(window=self.cycle_period, min_periods=1).max()
        stoch = 100 * (macd - lowest_macd) / (highest_macd - lowest_macd).replace(0, np.nan)
        stoch = stoch.fillna(0)
        stc = stoch.ewm(span=self.cycle_period, adjust=False).mean()
        stc = stc.ewm(span=self.cycle_period, adjust=False).mean()
        return pd.Series(stc, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'stc') or self.stc is None:
            self.stc = self.compute_values(df)
        stc_prev = self.stc.shift(1)
        cond_bull = (stc_prev <= self.baseline) & (self.stc > self.baseline)
        cond_bear = (stc_prev >= self.baseline) & (self.stc < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'STC_Above_Baseline', -1: 'STC_Below_Baseline', 0: 'STC_Neutral'}
        mapping_explanation = {
            1: f'STC crossed above the baseline of {self.baseline}, indicating bullish momentum.',
            -1: f'STC crossed below the baseline of {self.baseline}, indicating bearish momentum.',
            0: f'STC remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'STC_Fast:{self.fast_period}_Slow:{self.slow_period}_Cycle:{self.cycle_period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'STC_Fast:{self.fast_period}_Slow:{self.slow_period}_Cycle:{self.cycle_period}_TA_Indicator_Value'] = self.stc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'STC_Fast:{self.fast_period}_Slow:{self.slow_period}_Cycle:{self.cycle_period}_TA_Indicator_Value'] = self.stc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'stc') or self.stc is None:
            self.stc = self.compute_values(df)
        cond_bull = self.stc < self.lower_threshold
        cond_bear = self.stc > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'STC_Oversold', -1: 'STC_Overbought', 0: 'STC_Neutral'}
        mapping_explanation = {
            1: f'STC is below the lower threshold of {self.lower_threshold}, indicating oversold conditions and a potential bullish reversal.',
            -1: f'STC is above the upper threshold of {self.upper_threshold}, indicating overbought conditions and a potential bearish reversal.',
            0: f'STC is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'STC_Fast:{self.fast_period}_Slow:{self.slow_period}_Cycle:{self.cycle_period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'STC_Fast:{self.fast_period}_Slow:{self.slow_period}_Cycle:{self.cycle_period}_TA_Indicator_Value'] = self.stc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'STC_Fast:{self.fast_period}_Slow:{self.slow_period}_Cycle:{self.cycle_period}_TA_Indicator_Value'] = self.stc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'stc') or self.stc is None:
            self.stc = self.compute_values(df)
        diff = self.stc.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'STC_Rising', -1: 'STC_Falling', 0: 'STC_Unchanged'}
        mapping_explanation = {
            1: 'STC is rising, indicating increasing bullish momentum.',
            -1: 'STC is falling, indicating increasing bearish momentum.',
            0: 'STC remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'STC_Fast:{self.fast_period}_Slow:{self.slow_period}_Cycle:{self.cycle_period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'STC_Fast:{self.fast_period}_Slow:{self.slow_period}_Cycle:{self.cycle_period}_TA_Indicator_Value'] = self.stc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'STC_Fast:{self.fast_period}_Slow:{self.slow_period}_Cycle:{self.cycle_period}_TA_Indicator_Value'] = self.stc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
  
class ShortRunStrategies:
    def __init__(self, period=5, baseline=0, upper_threshold=50, lower_threshold=-50):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold

    def compute_values(self, df):
        diff = df['Close'].diff()
        sum_diff = pd.Series(diff).rolling(window=self.period, min_periods=1).sum()
        sum_abs_diff = pd.Series(np.abs(diff)).rolling(window=self.period, min_periods=1).sum()
        sr = np.where(sum_abs_diff == 0, 0, 100 * (sum_diff / sum_abs_diff))
        return pd.Series(sr, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'sr') or self.sr is None:
            self.sr = self.compute_values(df)
        sr_prev = self.sr.shift(1)
        cond_bull = (sr_prev <= self.baseline) & (self.sr > self.baseline)
        cond_bear = (sr_prev >= self.baseline) & (self.sr < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'ShortRun_Above_Baseline', -1: 'ShortRun_Below_Baseline', 0: 'ShortRun_Neutral'}
        mapping_explanation = {
            1: f'ShortRun crossed above the baseline of {self.baseline}, indicating bullish momentum.',
            -1: f'ShortRun crossed below the baseline of {self.baseline}, indicating bearish momentum.',
            0: f'ShortRun remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'ShortRun_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'ShortRun_Period:{self.period}_TA_Indicator_Value'] = self.sr
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ShortRun_Period:{self.period}_TA_Indicator_Value'] = self.sr
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'sr') or self.sr is None:
            self.sr = self.compute_values(df)
        cond_bull = self.sr > self.upper_threshold
        cond_bear = self.sr < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'ShortRun_StrongBullish', -1: 'ShortRun_StrongBearish', 0: 'ShortRun_Neutral'}
        mapping_explanation = {
            1: f'ShortRun is above the upper threshold of {self.upper_threshold}, indicating strong bullish momentum.',
            -1: f'ShortRun is below the lower threshold of {self.lower_threshold}, indicating strong bearish momentum.',
            0: f'ShortRun is between {self.lower_threshold} and {self.upper_threshold}, indicating moderate momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'ShortRun_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'ShortRun_Period:{self.period}_TA_Indicator_Value'] = self.sr
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ShortRun_Period:{self.period}_TA_Indicator_Value'] = self.sr
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'sr') or self.sr is None:
            self.sr = self.compute_values(df)
        diff = self.sr.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'ShortRun_Rising', -1: 'ShortRun_Falling', 0: 'ShortRun_Unchanged'}
        mapping_explanation = {
            1: 'ShortRun is rising, indicating increasing bullish momentum.',
            -1: 'ShortRun is falling, indicating increasing bearish momentum.',
            0: 'ShortRun remains unchanged, indicating balanced momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'ShortRun_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'ShortRun_Period:{self.period}_TA_Indicator_Value'] = self.sr
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ShortRun_Period:{self.period}_TA_Indicator_Value'] = self.sr
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
  
class SineWeightedMovingAverageStrategies:
    def __init__(self, period=14, baseline=0, upper_threshold=1.0, lower_threshold=-1.0):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold

    def compute_values(self, df):
        full_weights = np.sin(np.arange(1, self.period + 1) * np.pi / (self.period + 1))
        def weighted_avg(x):
            L = len(x)
            local_weights = full_weights[-L:]
            return np.dot(x, local_weights) / np.sum(local_weights)
        swma = df['Close'].rolling(window=self.period, min_periods=1).apply(weighted_avg, raw=True)
        return pd.Series(swma, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'swma') or self.swma is None:
            self.swma = self.compute_values(df)
        diff = df['Close'] - self.swma
        diff_prev = diff.shift(1)
        cond_bull = (diff_prev <= self.baseline) & (diff > self.baseline)
        cond_bear = (diff_prev >= self.baseline) & (diff < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Price_Above_SWMA', -1: 'Price_Below_SWMA', 0: 'No_Crossover'}
        mapping_explanation = {
            1: 'Price has crossed above the SineWeightedMovingAverage, indicating bullish momentum.',
            -1: 'Price has crossed below the SineWeightedMovingAverage, indicating bearish momentum.',
            0: 'No crossover detected between price and the SineWeightedMovingAverage.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'SWMA_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'SWMA_Period:{self.period}_TA_Indicator_Value'] = self.swma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SWMA_Period:{self.period}_TA_Indicator_Value'] = self.swma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'swma') or self.swma is None:
            self.swma = self.compute_values(df)
        diff = df['Close'] - self.swma
        cond_bull = diff > self.upper_threshold
        cond_bear = diff < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Price_Much_Above_SWMA', -1: 'Price_Much_Below_SWMA', 0: 'Price_Near_SWMA'}
        mapping_explanation = {
            1: f'The price exceeds the SWMA by more than {self.upper_threshold}, indicating strong bullish conditions.',
            -1: f'The price is lower than the SWMA by more than {abs(self.lower_threshold)}, indicating strong bearish conditions.',
            0: 'The price is close to the SWMA, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'SWMA_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'SWMA_Period:{self.period}_TA_Indicator_Value'] = self.swma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SWMA_Period:{self.period}_TA_Indicator_Value'] = self.swma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'swma') or self.swma is None:
            self.swma = self.compute_values(df)
        slope = self.swma.diff()
        signals = np.where(slope > 0, 1, np.where(slope < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'SWMA_Rising', -1: 'SWMA_Falling', 0: 'SWMA_Unchanged'}
        mapping_explanation = {
            1: 'The SineWeightedMovingAverage is rising, indicating increasing bullish momentum.',
            -1: 'The SineWeightedMovingAverage is falling, indicating increasing bearish momentum.',
            0: 'The SineWeightedMovingAverage is unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'SWMA_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'SWMA_Period:{self.period}_TA_Indicator_Value'] = self.swma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SWMA_Period:{self.period}_TA_Indicator_Value'] = self.swma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
  
class SlopeStrategies:
    def __init__(self, period=14, baseline=0, upper_threshold=0.1, lower_threshold=-0.1):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold

    def compute_values(self, df):
        def linreg_slope(arr):
            n = len(arr)
            x = np.arange(n)
            sum_x = x.sum()
            sum_x2 = (x * x).sum()
            sum_y = arr.sum()
            sum_xy = (x * arr).sum()
            denominator = n * sum_x2 - sum_x ** 2
            if denominator == 0:
                return 0
            return (n * sum_xy - sum_x * sum_y) / denominator
        slope_values = df['Close'].rolling(window=self.period, min_periods=1).apply(linreg_slope, raw=True)
        return pd.Series(slope_values, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'slope') or self.slope is None:
            self.slope = self.compute_values(df)
        slope_prev = self.slope.shift(1)
        cond_bull = (slope_prev <= self.baseline) & (self.slope > self.baseline)
        cond_bear = (slope_prev >= self.baseline) & (self.slope < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Slope_Above_Baseline', -1: 'Slope_Below_Baseline', 0: 'Slope_Neutral'}
        mapping_explanation = {
            1: f'The slope crossed above the baseline of {self.baseline}, indicating a shift to bullish momentum.',
            -1: f'The slope crossed below the baseline of {self.baseline}, indicating a shift to bearish momentum.',
            0: f'The slope remains around the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'Slope_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'Slope_Period:{self.period}_TA_Indicator_Value'] = self.slope
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Slope_Period:{self.period}_TA_Indicator_Value'] = self.slope
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'slope') or self.slope is None:
            self.slope = self.compute_values(df)
        cond_bull = self.slope > self.upper_threshold
        cond_bear = self.slope < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Slope_High', -1: 'Slope_Low', 0: 'Slope_Moderate'}
        mapping_explanation = {
            1: f'The slope is above the upper threshold of {self.upper_threshold}, indicating strong bullish momentum.',
            -1: f'The slope is below the lower threshold of {self.lower_threshold}, indicating strong bearish momentum.',
            0: f'The slope is between {self.lower_threshold} and {self.upper_threshold}, indicating moderate conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'Slope_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'Slope_Period:{self.period}_TA_Indicator_Value'] = self.slope
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Slope_Period:{self.period}_TA_Indicator_Value'] = self.slope
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'slope') or self.slope is None:
            self.slope = self.compute_values(df)
        diff = self.slope.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Slope_Rising', -1: 'Slope_Falling', 0: 'Slope_Unchanged'}
        mapping_explanation = {
            1: 'The slope is increasing, indicating an acceleration in bullish momentum.',
            -1: 'The slope is decreasing, indicating an acceleration in bearish momentum.',
            0: 'There is no significant change in the slope, indicating stable conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'Slope_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'Slope_Period:{self.period}_TA_Indicator_Value'] = self.slope
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Slope_Period:{self.period}_TA_Indicator_Value'] = self.slope
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
  
class SmiErgodicOscillatorStrategies:
    def __init__(self, period=14, signal_period=5, baseline=0, upper_threshold=20, lower_threshold=-20):
        self.period = period
        self.signal_period = signal_period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold

    def compute_values(self, df):
        typical_price = (df['High'] + df['Low']) / 2
        raw = df['Close'] - typical_price
        diff = df['High'] - df['Low']
        smoothed_raw = pd.Series(raw).ewm(span=self.period, adjust=False).mean().ewm(span=self.period, adjust=False).mean()
        smoothed_diff = pd.Series(diff).ewm(span=self.period, adjust=False).mean().ewm(span=self.period, adjust=False).mean()
        smoothed_diff = smoothed_diff.replace(0, np.nan)
        smi = 200 * smoothed_raw / smoothed_diff
        smi = smi.fillna(0)
        signal_line = smi.rolling(window=self.signal_period, min_periods=1).mean()
        smi_eo = smi - signal_line
        return pd.Series(smi_eo, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'smi_eo') or self.smi_eo is None:
            self.smi_eo = self.compute_values(df)
        smi_eo_prev = self.smi_eo.shift(1)
        cond_bull = (smi_eo_prev <= self.baseline) & (self.smi_eo > self.baseline)
        cond_bear = (smi_eo_prev >= self.baseline) & (self.smi_eo < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'SMI_EO_Above_Baseline', -1: 'SMI_EO_Below_Baseline', 0: 'SMI_EO_Neutral'}
        mapping_explanation = {
            1: f'SMI Ergodic Oscillator crossed above the baseline of {self.baseline}, indicating bullish momentum.',
            -1: f'SMI Ergodic Oscillator crossed below the baseline of {self.baseline}, indicating bearish momentum.',
            0: f'SMI Ergodic Oscillator remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'SMI_EO_Period:{self.period}_SignalPeriod:{self.signal_period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'SMI_EO_Period:{self.period}_TA_Indicator_Value'] = self.smi_eo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SMI_EO_Period:{self.period}_TA_Indicator_Value'] = self.smi_eo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'smi_eo') or self.smi_eo is None:
            self.smi_eo = self.compute_values(df)
        cond_bull = self.smi_eo > self.upper_threshold
        cond_bear = self.smi_eo < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'SMI_EO_StrongBullish', -1: 'SMI_EO_StrongBearish', 0: 'SMI_EO_Neutral'}
        mapping_explanation = {
            1: f'SMI Ergodic Oscillator is above the upper threshold of {self.upper_threshold}, indicating strong bullish momentum.',
            -1: f'SMI Ergodic Oscillator is below the lower threshold of {self.lower_threshold}, indicating strong bearish momentum.',
            0: f'SMI Ergodic Oscillator is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'SMI_EO_Period:{self.period}_SignalPeriod:{self.signal_period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'SMI_EO_Period:{self.period}_TA_Indicator_Value'] = self.smi_eo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SMI_EO_Period:{self.period}_TA_Indicator_Value'] = self.smi_eo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'smi_eo') or self.smi_eo is None:
            self.smi_eo = self.compute_values(df)
        diff = self.smi_eo.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'SMI_EO_Rising', -1: 'SMI_EO_Falling', 0: 'SMI_EO_Unchanged'}
        mapping_explanation = {
            1: 'SMI Ergodic Oscillator is rising, indicating increasing bullish momentum.',
            -1: 'SMI Ergodic Oscillator is falling, indicating increasing bearish momentum.',
            0: 'SMI Ergodic Oscillator remains unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'SMI_EO_Period:{self.period}_SignalPeriod:{self.signal_period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'SMI_EO_Period:{self.period}_TA_Indicator_Value'] = self.smi_eo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SMI_EO_Period:{self.period}_TA_Indicator_Value'] = self.smi_eo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
  
class SmoothedExponentialMovingAverageStrategies:
    def __init__(self, period=14, baseline=0, upper_threshold=1.0, lower_threshold=-1.0):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold

    def compute_values(self, df):
        prices = df['Close'].values
        sema = np.empty_like(prices, dtype=float)
        sema[0] = prices[0]
        for i in range(1, len(prices)):
            sema[i] = (prices[i] + (self.period - 1) * sema[i - 1]) / self.period
        return pd.Series(sema, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'sema') or self.sema is None:
            self.sema = self.compute_values(df)
        diff = df['Close'] - self.sema
        diff_prev = diff.shift(1)
        cond_bull = (diff_prev <= self.baseline) & (diff > self.baseline)
        cond_bear = (diff_prev >= self.baseline) & (diff < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Price_Above_SEMA', -1: 'Price_Below_SEMA', 0: 'No_Crossover'}
        mapping_explanation = {
            1: 'Price crossed above the Smoothed Exponential Moving Average, indicating bullish momentum.',
            -1: 'Price crossed below the Smoothed Exponential Moving Average, indicating bearish momentum.',
            0: 'No crossover detected between price and the Smoothed Exponential Moving Average.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'SEMA_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'SEMA_Period:{self.period}_TA_Indicator_Value'] = self.sema
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SEMA_Period:{self.period}_TA_Indicator_Value'] = self.sema
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'sema') or self.sema is None:
            self.sema = self.compute_values(df)
        diff = df['Close'] - self.sema
        cond_bull = diff > self.upper_threshold
        cond_bear = diff < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Strong_Bullish', -1: 'Strong_Bearish', 0: 'Neutral'}
        mapping_explanation = {
            1: f'Price exceeds SEMA by more than {self.upper_threshold}, indicating strong bullish momentum.',
            -1: f'Price is below SEMA by more than {abs(self.lower_threshold)}, indicating strong bearish momentum.',
            0: 'Price is within the neutral range relative to SEMA.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'SEMA_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'SEMA_Period:{self.period}_TA_Indicator_Value'] = self.sema
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SEMA_Period:{self.period}_TA_Indicator_Value'] = self.sema
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'sema') or self.sema is None:
            self.sema = self.compute_values(df)
        diff = self.sema.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'SEMA_Rising', -1: 'SEMA_Falling', 0: 'SEMA_Unchanged'}
        mapping_explanation = {
            1: 'The Smoothed Exponential Moving Average is rising, indicating increasing bullish momentum.',
            -1: 'The Smoothed Exponential Moving Average is falling, indicating increasing bearish momentum.',
            0: 'The Smoothed Exponential Moving Average is unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'SEMA_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'SEMA_Period:{self.period}_TA_Indicator_Value'] = self.sema
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SEMA_Period:{self.period}_TA_Indicator_Value'] = self.sema
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
  
class SmoothedSimpleMovingAverageStrategies:
    def __init__(self, period=14, baseline=0, upper_threshold=1.0, lower_threshold=-1.0):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold

    def compute_values(self, df):
        prices = df['Close'].values
        ssma = np.empty_like(prices, dtype=float)
        ssma[0] = prices[0]
        for i in range(1, len(prices)):
            ssma[i] = (prices[i] + (self.period - 1) * ssma[i - 1]) / self.period
        return pd.Series(ssma, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'ssma') or self.ssma is None:
            self.ssma = self.compute_values(df)
        diff = df['Close'] - self.ssma
        diff_prev = diff.shift(1)
        cond_bull = (diff_prev <= self.baseline) & (diff > self.baseline)
        cond_bear = (diff_prev >= self.baseline) & (diff < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Price_Above_SSMA', -1: 'Price_Below_SSMA', 0: 'No_Crossover'}
        mapping_explanation = {
            1: 'Price crossed above the Smoothed Simple Moving Average, indicating bullish momentum.',
            -1: 'Price crossed below the Smoothed Simple Moving Average, indicating bearish momentum.',
            0: 'No crossover detected between price and the Smoothed Simple Moving Average.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'SSMA_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'SSMA_Period:{self.period}_TA_Indicator_Value'] = self.ssma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SSMA_Period:{self.period}_TA_Indicator_Value'] = self.ssma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'ssma') or self.ssma is None:
            self.ssma = self.compute_values(df)
        diff = df['Close'] - self.ssma
        cond_bull = diff > self.upper_threshold
        cond_bear = diff < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Strong_Bullish', -1: 'Strong_Bearish', 0: 'Neutral'}
        mapping_explanation = {
            1: f'Price exceeds SSMA by more than {self.upper_threshold}, indicating strong bullish momentum.',
            -1: f'Price is below SSMA by more than {abs(self.lower_threshold)}, indicating strong bearish momentum.',
            0: 'Price is within the neutral range relative to SSMA.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'SSMA_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'SSMA_Period:{self.period}_TA_Indicator_Value'] = self.ssma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SSMA_Period:{self.period}_TA_Indicator_Value'] = self.ssma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'ssma') or self.ssma is None:
            self.ssma = self.compute_values(df)
        diff = self.ssma.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'SSMA_Rising', -1: 'SSMA_Falling', 0: 'SSMA_Unchanged'}
        mapping_explanation = {
            1: 'The Smoothed Simple Moving Average is rising, indicating increasing bullish momentum.',
            -1: 'The Smoothed Simple Moving Average is falling, indicating increasing bearish momentum.',
            0: 'The Smoothed Simple Moving Average is unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'SSMA_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'SSMA_Period:{self.period}_TA_Indicator_Value'] = self.ssma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SSMA_Period:{self.period}_TA_Indicator_Value'] = self.ssma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
  
class SqueezeStrategies:
    def __init__(self, period=20, bb_mult=2, kc_mult=1.5, baseline=0, upper_threshold=0.5, lower_threshold=-0.5):
        self.period = period
        self.bb_mult = bb_mult
        self.kc_mult = kc_mult
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold

    def compute_values(self, df):
        stdev = pd.Series(df['Close']).rolling(window=self.period, min_periods=1).std()
        prev_close = df['Close'].shift(1)
        tr1 = df['High'] - df['Low']
        tr2 = (df['High'] - prev_close).abs()
        tr3 = (df['Low'] - prev_close).abs()
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
        atr = tr.rolling(window=self.period, min_periods=1).mean()
        bb_range = 2 * self.bb_mult * stdev
        kc_range = 2 * self.kc_mult * atr
        squeeze_value = kc_range - bb_range
        return pd.Series(squeeze_value, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'sqz') or self.sqz is None:
            self.sqz = self.compute_values(df)
        sqz_prev = self.sqz.shift(1)
        cond_bull = (sqz_prev <= self.baseline) & (self.sqz > self.baseline)
        cond_bear = (sqz_prev >= self.baseline) & (self.sqz < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Squeeze_On', -1: 'Squeeze_Off', 0: 'No_Change'}
        mapping_explanation = {
            1: f'The Squeeze indicator crossed above the baseline of {self.baseline}, suggesting a transition into a squeezed (low volatility) state.',
            -1: f'The Squeeze indicator crossed below the baseline of {self.baseline}, suggesting an exit from the squeeze and potential volatility expansion.',
            0: f'The Squeeze indicator remains unchanged relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'Squeeze_Period:{self.period}_BBmult:{self.bb_mult}_KCmult:{self.kc_mult}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'Squeeze_Period:{self.period}_TA_Indicator_Value'] = self.sqz
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Squeeze_Period:{self.period}_TA_Indicator_Value'] = self.sqz
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'sqz') or self.sqz is None:
            self.sqz = self.compute_values(df)
        cond_bull = self.sqz > self.upper_threshold
        cond_bear = self.sqz < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Strong_Squeeze_On', -1: 'Strong_Squeeze_Off', 0: 'Neutral'}
        mapping_explanation = {
            1: f'The Squeeze indicator is above the upper threshold of {self.upper_threshold}, indicating a strong squeezed (low volatility) condition.',
            -1: f'The Squeeze indicator is below the lower threshold of {self.lower_threshold}, indicating a release from squeeze and potential volatility expansion.',
            0: f'The Squeeze indicator is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'Squeeze_Period:{self.period}_BBmult:{self.bb_mult}_KCmult:{self.kc_mult}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'Squeeze_Period:{self.period}_TA_Indicator_Value'] = self.sqz
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Squeeze_Period:{self.period}_TA_Indicator_Value'] = self.sqz
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'sqz') or self.sqz is None:
            self.sqz = self.compute_values(df)
        diff = self.sqz.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Squeeze_Rising', -1: 'Squeeze_Falling', 0: 'Squeeze_Unchanged'}
        mapping_explanation = {
            1: 'The Squeeze indicator is rising, suggesting increasing low volatility conditions.',
            -1: 'The Squeeze indicator is falling, suggesting decreasing low volatility and a potential volatility expansion.',
            0: 'The Squeeze indicator is unchanged, indicating stable conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'Squeeze_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'Squeeze_Period:{self.period}_TA_Indicator_Value'] = self.sqz
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Squeeze_Period:{self.period}_TA_Indicator_Value'] = self.sqz
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
  
class SqueezeProStrategies:
    def __init__(self, period=20, bb_mult=2, kc_mult=1.5, momentum_period=5, baseline=0, upper_threshold=0.5, lower_threshold=-0.5):
        self.period = period
        self.bb_mult = bb_mult
        self.kc_mult = kc_mult
        self.momentum_period = momentum_period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold

    def compute_values(self, df):
        stdev = pd.Series(df['Close']).rolling(window=self.period, min_periods=1).std()
        prev_close = df['Close'].shift(1)
        tr1 = df['High'] - df['Low']
        tr2 = (df['High'] - prev_close).abs()
        tr3 = (df['Low'] - prev_close).abs()
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
        atr = tr.rolling(window=self.period, min_periods=1).mean()
        bb_range = 2 * self.bb_mult * stdev
        kc_range = 2 * self.kc_mult * atr
        raw_squeeze = kc_range - bb_range
        momentum = (df['Close'] - df['Close'].shift(self.momentum_period)) / df['Close'].shift(self.momentum_period)
        momentum = momentum.fillna(0)
        squeeze_pro = raw_squeeze * momentum
        return pd.Series(squeeze_pro, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'sqz_pro') or self.sqz_pro is None:
            self.sqz_pro = self.compute_values(df)
        sqz_prev = self.sqz_pro.shift(1)
        cond_bull = (sqz_prev <= self.baseline) & (self.sqz_pro > self.baseline)
        cond_bear = (sqz_prev >= self.baseline) & (self.sqz_pro < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'SqueezePro_Bullish', -1: 'SqueezePro_Bearish', 0: 'SqueezePro_Neutral'}
        mapping_explanation = {
            1: f'SqueezePro crossed above the baseline of {self.baseline}, indicating bullish breakout potential.',
           -1: f'SqueezePro crossed below the baseline of {self.baseline}, indicating bearish breakout potential.',
            0: f'SqueezePro remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'SqueezePro_Period:{self.period}_BBmult:{self.bb_mult}_KCmult:{self.kc_mult}_MomentumPeriod:{self.momentum_period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'SqueezePro_Period:{self.period}_TA_Indicator_Value'] = self.sqz_pro
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SqueezePro_Period:{self.period}_TA_Indicator_Value'] = self.sqz_pro
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'sqz_pro') or self.sqz_pro is None:
            self.sqz_pro = self.compute_values(df)
        cond_bull = self.sqz_pro > self.upper_threshold
        cond_bear = self.sqz_pro < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Strong_Bullish', -1: 'Strong_Bearish', 0: 'Neutral'}
        mapping_explanation = {
            1: f'SqueezePro is above the upper threshold of {self.upper_threshold}, indicating strong bullish momentum.',
           -1: f'SqueezePro is below the lower threshold of {self.lower_threshold}, indicating strong bearish momentum.',
            0: f'SqueezePro is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'SqueezePro_Period:{self.period}_BBmult:{self.bb_mult}_KCmult:{self.kc_mult}_MomentumPeriod:{self.momentum_period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'SqueezePro_Period:{self.period}_TA_Indicator_Value'] = self.sqz_pro
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SqueezePro_Period:{self.period}_TA_Indicator_Value'] = self.sqz_pro
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'sqz_pro') or self.sqz_pro is None:
            self.sqz_pro = self.compute_values(df)
        diff = self.sqz_pro.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'SqueezePro_Rising', -1: 'SqueezePro_Falling', 0: 'SqueezePro_Unchanged'}
        mapping_explanation = {
            1: 'SqueezePro is rising, indicating increasing bullish momentum and potential breakout.',
           -1: 'SqueezePro is falling, indicating increasing bearish momentum and potential breakdown.',
            0: 'SqueezePro remains unchanged, indicating stable volatility conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'SqueezePro_Period:{self.period}_MomentumPeriod:{self.momentum_period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'SqueezePro_Period:{self.period}_TA_Indicator_Value'] = self.sqz_pro
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SqueezePro_Period:{self.period}_TA_Indicator_Value'] = self.sqz_pro
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
  
class StandardDeviationStrategies:
    def __init__(self, period=20, baseline=1.0, upper_threshold=2.0, lower_threshold=0.5):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold

    def compute_values(self, df):
        std_dev = df['Close'].rolling(window=self.period, min_periods=1).std()
        return pd.Series(std_dev, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'std_dev') or self.std_dev is None:
            self.std_dev = self.compute_values(df)
        std_prev = self.std_dev.shift(1)
        cond_bull = (std_prev <= self.baseline) & (self.std_dev > self.baseline)
        cond_bear = (std_prev >= self.baseline) & (self.std_dev < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'StdDev_Above_Baseline', -1: 'StdDev_Below_Baseline', 0: 'StdDev_Neutral'}
        mapping_explanation = {
            1: f'Standard Deviation crossed above the baseline of {self.baseline}, indicating increasing volatility.',
           -1: f'Standard Deviation crossed below the baseline of {self.baseline}, indicating decreasing volatility.',
            0: f'Standard Deviation remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'StdDev_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'StdDev_Period:{self.period}_TA_Indicator_Value'] = self.std_dev
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StdDev_Period:{self.period}_TA_Indicator_Value'] = self.std_dev
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'std_dev') or self.std_dev is None:
            self.std_dev = self.compute_values(df)
        cond_bull = self.std_dev < self.lower_threshold
        cond_bear = self.std_dev > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Low_Volatility', -1: 'High_Volatility', 0: 'Moderate_Volatility'}
        mapping_explanation = {
            1: f'Standard Deviation is below the lower threshold of {self.lower_threshold}, indicating low volatility that may precede a breakout.',
           -1: f'Standard Deviation is above the upper threshold of {self.upper_threshold}, indicating high volatility that may signal trend exhaustion.',
            0: f'Standard Deviation is between {self.lower_threshold} and {self.upper_threshold}, indicating moderate volatility.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'StdDev_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'StdDev_Period:{self.period}_TA_Indicator_Value'] = self.std_dev
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StdDev_Period:{self.period}_TA_Indicator_Value'] = self.std_dev
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'std_dev') or self.std_dev is None:
            self.std_dev = self.compute_values(df)
        diff = self.std_dev.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'StdDev_Rising', -1: 'StdDev_Falling', 0: 'StdDev_Unchanged'}
        mapping_explanation = {
            1: 'Standard Deviation is rising, indicating increasing volatility.',
           -1: 'Standard Deviation is falling, indicating decreasing volatility.',
            0: 'Standard Deviation is unchanged, indicating stable volatility.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'StdDev_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'StdDev_Period:{self.period}_TA_Indicator_Value'] = self.std_dev
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StdDev_Period:{self.period}_TA_Indicator_Value'] = self.std_dev
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
  
class StochasticStrategies:
    def __init__(self, period=14, baseline=50, upper_threshold=80, lower_threshold=20):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold

    def compute_values(self, df):
        lowest_low = df['Low'].rolling(window=self.period, min_periods=1).min()
        highest_high = df['High'].rolling(window=self.period, min_periods=1).max()
        stoch = 100 * (df['Close'] - lowest_low) / (highest_high - lowest_low).replace(0, np.nan)
        stoch = stoch.fillna(0)
        return pd.Series(stoch, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'stoch') or self.stoch is None:
            self.stoch = self.compute_values(df)
        stoch_prev = self.stoch.shift(1)
        cond_bull = (stoch_prev <= self.baseline) & (self.stoch > self.baseline)
        cond_bear = (stoch_prev >= self.baseline) & (self.stoch < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Stoch_Above_Baseline', -1: 'Stoch_Below_Baseline', 0: 'Stoch_Neutral'}
        mapping_explanation = {
            1: f'Stoch crossed above the baseline of {self.baseline}, indicating a potential bullish trend.',
           -1: f'Stoch crossed below the baseline of {self.baseline}, indicating a potential bearish trend.',
            0: f'Stoch remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'Stoch_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'Stoch_Period:{self.period}_TA_Indicator_Value'] = self.stoch
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Stoch_Period:{self.period}_TA_Indicator_Value'] = self.stoch
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'stoch') or self.stoch is None:
            self.stoch = self.compute_values(df)
        cond_bull = self.stoch < self.lower_threshold
        cond_bear = self.stoch > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Oversold', -1: 'Overbought', 0: 'Neutral'}
        mapping_explanation = {
            1: f'Stoch is below the lower threshold of {self.lower_threshold}, indicating oversold (bullish) conditions.',
           -1: f'Stoch is above the upper threshold of {self.upper_threshold}, indicating overbought (bearish) conditions.',
            0: f'Stoch is within the normal range between {self.lower_threshold} and {self.upper_threshold}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'Stoch_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'Stoch_Period:{self.period}_TA_Indicator_Value'] = self.stoch
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Stoch_Period:{self.period}_TA_Indicator_Value'] = self.stoch
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'stoch') or self.stoch is None:
            self.stoch = self.compute_values(df)
        diff = self.stoch.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Stoch_Rising', -1: 'Stoch_Falling', 0: 'Stoch_Unchanged'}
        mapping_explanation = {
            1: 'Stochastic is rising, indicating increasing bullish momentum.',
           -1: 'Stochastic is falling, indicating increasing bearish momentum.',
            0: 'Stochastic remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'Stoch_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'Stoch_Period:{self.period}_TA_Indicator_Value'] = self.stoch
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Stoch_Period:{self.period}_TA_Indicator_Value'] = self.stoch
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
  
class StochasticFastStrategies:
    def __init__(self, period=14, baseline=50, upper_threshold=80, lower_threshold=20):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold

    def compute_values(self, df):
        lowest_low = df['Low'].rolling(window=self.period, min_periods=1).min()
        highest_high = df['High'].rolling(window=self.period, min_periods=1).max()
        stoch_fast = 100 * (df['Close'] - lowest_low) / (highest_high - lowest_low).replace(0, np.nan)
        stoch_fast = stoch_fast.fillna(0)
        return pd.Series(stoch_fast, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'stoch_fast') or self.stoch_fast is None:
            self.stoch_fast = self.compute_values(df)
        stoch_prev = self.stoch_fast.shift(1)
        cond_bull = (stoch_prev <= self.baseline) & (self.stoch_fast > self.baseline)
        cond_bear = (stoch_prev >= self.baseline) & (self.stoch_fast < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'StochFast_Above_Baseline', -1: 'StochFast_Below_Baseline', 0: 'StochFast_Neutral'}
        mapping_explanation = {
            1: f'Stochastic Fast crossed above the baseline of {self.baseline}, indicating bullish momentum.',
           -1: f'Stochastic Fast crossed below the baseline of {self.baseline}, indicating bearish momentum.',
            0: f'Stochastic Fast remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'StochFast_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'StochFast_Period:{self.period}_TA_Indicator_Value'] = self.stoch_fast
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StochFast_Period:{self.period}_TA_Indicator_Value'] = self.stoch_fast
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'stoch_fast') or self.stoch_fast is None:
            self.stoch_fast = self.compute_values(df)
        cond_bull = self.stoch_fast < self.lower_threshold
        cond_bear = self.stoch_fast > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'StochFast_Oversold', -1: 'StochFast_Overbought', 0: 'StochFast_Neutral'}
        mapping_explanation = {
            1: f'Stochastic Fast is below the lower threshold of {self.lower_threshold}, indicating oversold conditions and potential bullish reversal.',
           -1: f'Stochastic Fast is above the upper threshold of {self.upper_threshold}, indicating overbought conditions and potential bearish reversal.',
            0: f'Stochastic Fast is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'StochFast_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'StochFast_Period:{self.period}_TA_Indicator_Value'] = self.stoch_fast
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StochFast_Period:{self.period}_TA_Indicator_Value'] = self.stoch_fast
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'stoch_fast') or self.stoch_fast is None:
            self.stoch_fast = self.compute_values(df)
        diff = self.stoch_fast.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'StochFast_Rising', -1: 'StochFast_Falling', 0: 'StochFast_Unchanged'}
        mapping_explanation = {
            1: 'Stochastic Fast is rising, indicating increasing bullish momentum.',
           -1: 'Stochastic Fast is falling, indicating increasing bearish momentum.',
            0: 'Stochastic Fast remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'StochFast_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'StochFast_Period:{self.period}_TA_Indicator_Value'] = self.stoch_fast
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StochFast_Period:{self.period}_TA_Indicator_Value'] = self.stoch_fast
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
  
class StochasticOscillatorStrategies:
    def __init__(self, period=14, baseline=50, upper_threshold=80, lower_threshold=20):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold

    def compute_values(self, df):
        lowest_low = df['Low'].rolling(window=self.period, min_periods=1).min()
        highest_high = df['High'].rolling(window=self.period, min_periods=1).max()
        stoch_osc = 100 * (df['Close'] - lowest_low) / (highest_high - lowest_low).replace(0, np.nan)
        stoch_osc = stoch_osc.fillna(0)
        return pd.Series(stoch_osc, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'stoch_osc') or self.stoch_osc is None:
            self.stoch_osc = self.compute_values(df)
        stoch_prev = self.stoch_osc.shift(1)
        cond_bull = (stoch_prev <= self.baseline) & (self.stoch_osc > self.baseline)
        cond_bear = (stoch_prev >= self.baseline) & (self.stoch_osc < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'StochOsc_Above_Baseline', -1: 'StochOsc_Below_Baseline', 0: 'StochOsc_Neutral'}
        mapping_explanation = {
            1: f'Stochastic Oscillator crossed above the baseline of {self.baseline}, indicating bullish momentum.',
            -1: f'Stochastic Oscillator crossed below the baseline of {self.baseline}, indicating bearish momentum.',
            0: f'Stochastic Oscillator remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'StochOsc_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'StochOsc_Period:{self.period}_TA_Indicator_Value'] = self.stoch_osc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StochOsc_Period:{self.period}_TA_Indicator_Value'] = self.stoch_osc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'stoch_osc') or self.stoch_osc is None:
            self.stoch_osc = self.compute_values(df)
        cond_bull = self.stoch_osc < self.lower_threshold
        cond_bear = self.stoch_osc > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Oversold', -1: 'Overbought', 0: 'Neutral'}
        mapping_explanation = {
            1: f'Stochastic Oscillator is below the lower threshold of {self.lower_threshold}, indicating oversold (bullish) conditions.',
            -1: f'Stochastic Oscillator is above the upper threshold of {self.upper_threshold}, indicating overbought (bearish) conditions.',
            0: f'Stochastic Oscillator is within the range of {self.lower_threshold} to {self.upper_threshold}, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'StochOsc_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'StochOsc_Period:{self.period}_TA_Indicator_Value'] = self.stoch_osc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StochOsc_Period:{self.period}_TA_Indicator_Value'] = self.stoch_osc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'stoch_osc') or self.stoch_osc is None:
            self.stoch_osc = self.compute_values(df)
        diff = self.stoch_osc.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'StochOsc_Rising', -1: 'StochOsc_Falling', 0: 'StochOsc_Unchanged'}
        mapping_explanation = {
            1: 'Stochastic Oscillator is rising, indicating increasing bullish momentum.',
            -1: 'Stochastic Oscillator is falling, indicating increasing bearish momentum.',
            0: 'Stochastic Oscillator remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'StochOsc_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'StochOsc_Period:{self.period}_TA_Indicator_Value'] = self.stoch_osc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StochOsc_Period:{self.period}_TA_Indicator_Value'] = self.stoch_osc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
  
class StochasticOscillatorKStrategies:
    def __init__(self, period=14, baseline=50, upper_threshold=80, lower_threshold=20):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold

    def compute_values(self, df):
        lowest_low = df['Low'].rolling(window=self.period, min_periods=1).min()
        highest_high = df['High'].rolling(window=self.period, min_periods=1).max()
        stoch_k = 100 * (df['Close'] - lowest_low) / (highest_high - lowest_low).replace(0, np.nan)
        stoch_k = stoch_k.fillna(0)
        return pd.Series(stoch_k, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'stoch_k') or self.stoch_k is None:
            self.stoch_k = self.compute_values(df)
        stoch_prev = self.stoch_k.shift(1)
        cond_bull = (stoch_prev <= self.baseline) & (self.stoch_k > self.baseline)
        cond_bear = (stoch_prev >= self.baseline) & (self.stoch_k < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'StochK_Above_Baseline', -1: 'StochK_Below_Baseline', 0: 'StochK_Neutral'}
        mapping_explanation = {
            1: f'Stochastic Oscillator %K crossed above the baseline of {self.baseline}, indicating bullish momentum.',
           -1: f'Stochastic Oscillator %K crossed below the baseline of {self.baseline}, indicating bearish momentum.',
            0: f'Stochastic Oscillator %K remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'StochK_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'StochK_Period:{self.period}_TA_Indicator_Value'] = self.stoch_k
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StochK_Period:{self.period}_TA_Indicator_Value'] = self.stoch_k
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'stoch_k') or self.stoch_k is None:
            self.stoch_k = self.compute_values(df)
        cond_bull = self.stoch_k < self.lower_threshold
        cond_bear = self.stoch_k > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Oversold', -1: 'Overbought', 0: 'Neutral'}
        mapping_explanation = {
            1: f'Stochastic Oscillator %K is below the lower threshold of {self.lower_threshold}, indicating oversold conditions (bullish reversal potential).',
           -1: f'Stochastic Oscillator %K is above the upper threshold of {self.upper_threshold}, indicating overbought conditions (bearish reversal potential).',
            0: f'Stochastic Oscillator %K is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'StochK_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'StochK_Period:{self.period}_TA_Indicator_Value'] = self.stoch_k
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StochK_Period:{self.period}_TA_Indicator_Value'] = self.stoch_k
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'stoch_k') or self.stoch_k is None:
            self.stoch_k = self.compute_values(df)
        diff = self.stoch_k.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'StochK_Rising', -1: 'StochK_Falling', 0: 'StochK_Unchanged'}
        mapping_explanation = {
            1: 'Stochastic Oscillator %K is rising, indicating increasing bullish momentum.',
           -1: 'Stochastic Oscillator %K is falling, indicating increasing bearish momentum.',
            0: 'Stochastic Oscillator %K remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'StochK_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'StochK_Period:{self.period}_TA_Indicator_Value'] = self.stoch_k
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StochK_Period:{self.period}_TA_Indicator_Value'] = self.stoch_k
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
  
class StochasticRSIStrategies:
    def __init__(self, period=14, baseline=50, lower_threshold=20, upper_threshold=80):
        self.period = period
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold

    def compute_values(self, df):
        delta = df['Close'].diff()
        gain = delta.clip(lower=0)
        loss = -delta.clip(upper=0)
        avg_gain = gain.rolling(window=self.period, min_periods=1).mean()
        avg_loss = loss.rolling(window=self.period, min_periods=1).mean()
        rs = avg_gain / avg_loss.replace(0, 1e-10)
        rsi = 100 - (100 / (1 + rs))
        rsi_min = rsi.rolling(window=self.period, min_periods=1).min()
        rsi_max = rsi.rolling(window=self.period, min_periods=1).max()
        stoch_rsi = ((rsi - rsi_min) / (rsi_max - rsi_min).replace(0, 1e-10)) * 100
        self.stoch_rsi = pd.Series(stoch_rsi, index=df.index)
        return self.stoch_rsi

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'stoch_rsi') or self.stoch_rsi is None:
            self.stoch_rsi = self.compute_values(df)
        stoch_prev = self.stoch_rsi.shift(1)
        cond_bull = (stoch_prev <= self.baseline) & (self.stoch_rsi > self.baseline)
        cond_bear = (stoch_prev >= self.baseline) & (self.stoch_rsi < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'StochRSI_Above_Baseline', -1: 'StochRSI_Below_Baseline', 0: 'StochRSI_Neutral'}
        mapping_explanation = {
            1: f'StochRSI crossed above the baseline of {self.baseline}, suggesting bullish momentum.',
            -1: f'StochRSI crossed below the baseline of {self.baseline}, suggesting bearish momentum.',
            0: f'StochRSI remains near the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'StochRSI_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'StochRSI_Period:{self.period}_TA_Indicator_Value'] = self.stoch_rsi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StochRSI_Period:{self.period}_TA_Indicator_Value'] = self.stoch_rsi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'stoch_rsi') or self.stoch_rsi is None:
            self.stoch_rsi = self.compute_values(df)
        cond_bull = self.stoch_rsi < self.lower_threshold
        cond_bear = self.stoch_rsi > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'StochRSI_Oversold', -1: 'StochRSI_Overbought', 0: 'StochRSI_Neutral'}
        mapping_explanation = {
            1: f'StochRSI is below the lower threshold of {self.lower_threshold}, indicating oversold conditions and a potential bullish reversal.',
            -1: f'StochRSI is above the upper threshold of {self.upper_threshold}, indicating overbought conditions and a potential bearish reversal.',
            0: f'StochRSI is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'StochRSI_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'StochRSI_Period:{self.period}_TA_Indicator_Value'] = self.stoch_rsi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StochRSI_Period:{self.period}_TA_Indicator_Value'] = self.stoch_rsi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'stoch_rsi') or self.stoch_rsi is None:
            self.stoch_rsi = self.compute_values(df)
        diff = self.stoch_rsi.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'StochRSI_Rising', -1: 'StochRSI_Falling', 0: 'StochRSI_Unchanged'}
        mapping_explanation = {
            1: 'StochRSI is rising, indicating increasing bullish momentum.',
            -1: 'StochRSI is falling, indicating increasing bearish momentum.',
            0: 'StochRSI remains unchanged, indicating neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'StochRSI_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'StochRSI_Period:{self.period}_TA_Indicator_Value'] = self.stoch_rsi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StochRSI_Period:{self.period}_TA_Indicator_Value'] = self.stoch_rsi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)




  
  
class StochasticOscillatorDStrategies:
    def __init__(self, period=14, d_period=3, baseline=50, upper_threshold=80, lower_threshold=20):
        self.period = period
        self.d_period = d_period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold

    def compute_values(self, df):
        lowest_low = df['Low'].rolling(window=self.period, min_periods=1).min()
        highest_high = df['High'].rolling(window=self.period, min_periods=1).max()
        stoch_k = 100 * (df['Close'] - lowest_low) / (highest_high - lowest_low).replace(0, np.nan)
        stoch_k = stoch_k.fillna(0)
        stoch_d = stoch_k.rolling(window=self.d_period, min_periods=1).mean()
        return pd.Series(stoch_d, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        if not hasattr(self, 'stoch_d') or self.stoch_d is None:
            self.stoch_d = self.compute_values(df)
        stoch_prev = self.stoch_d.shift(1)
        cond_bull = (stoch_prev <= self.baseline) & (self.stoch_d > self.baseline)
        cond_bear = (stoch_prev >= self.baseline) & (self.stoch_d < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'StochOscD_Above_Baseline', -1: 'StochOscD_Below_Baseline', 0: 'StochOscD_Neutral'}
        mapping_explanation = {
            1: f'Stochastic Oscillator %D crossed above the baseline of {self.baseline}, indicating bullish momentum.',
            -1: f'Stochastic Oscillator %D crossed below the baseline of {self.baseline}, indicating bearish momentum.',
            0: f'Stochastic Oscillator %D remains neutral relative to the baseline of {self.baseline}.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'StochOscD_Period:{self.period}_DPeriod:{self.d_period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'StochOscD_Period:{self.period}_DPeriod:{self.d_period}_TA_Indicator_Value'] = self.stoch_d
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StochOscD_Period:{self.period}_DPeriod:{self.d_period}_TA_Indicator_Value'] = self.stoch_d
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if not hasattr(self, 'stoch_d') or self.stoch_d is None:
            self.stoch_d = self.compute_values(df)
        cond_bull = self.stoch_d < self.lower_threshold
        cond_bear = self.stoch_d > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Oversold', -1: 'Overbought', 0: 'Neutral'}
        mapping_explanation = {
            1: f'Stochastic Oscillator %D is below the lower threshold of {self.lower_threshold}, indicating oversold conditions with bullish reversal potential.',
            -1: f'Stochastic Oscillator %D is above the upper threshold of {self.upper_threshold}, indicating overbought conditions with bearish reversal potential.',
            0: f'Stochastic Oscillator %D is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'StochOscD_Period:{self.period}_DPeriod:{self.d_period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'StochOscD_Period:{self.period}_DPeriod:{self.d_period}_TA_Indicator_Value'] = self.stoch_d
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StochOscD_Period:{self.period}_DPeriod:{self.d_period}_TA_Indicator_Value'] = self.stoch_d
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if not hasattr(self, 'stoch_d') or self.stoch_d is None:
            self.stoch_d = self.compute_values(df)
        diff = self.stoch_d.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'StochOscD_Rising', -1: 'StochOscD_Falling', 0: 'StochOscD_Unchanged'}
        mapping_explanation = {
            1: 'Stochastic Oscillator %D is rising, indicating increasing bullish momentum.',
            -1: 'Stochastic Oscillator %D is falling, indicating increasing bearish momentum.',
            0: 'Stochastic Oscillator %D remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'StochOscD_Period:{self.period}_DPeriod:{self.d_period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'StochOscD_Period:{self.period}_DPeriod:{self.d_period}_TA_Indicator_Value'] = self.stoch_d
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'StochOscD_Period:{self.period}_DPeriod:{self.d_period}_TA_Indicator_Value'] = self.stoch_d
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
  
class StopAndReverseStrategies:
    def __init__(self, initial_af=0.02, max_af=0.2, baseline=0, upper_threshold=1, lower_threshold=-1):
        self.initial_af = initial_af
        self.max_af = max_af
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.sar = None

    def compute_values(self, df):
        n = len(df)
        sar = [0] * n
        if n == 0:
            return pd.Series([])
        if df['Close'].iloc[1] > df['Close'].iloc[0]:
            trend = 1
            sar[0] = df['Low'].iloc[0]
            ep = df['High'].iloc[0]
        else:
            trend = -1
            sar[0] = df['High'].iloc[0]
            ep = df['Low'].iloc[0]
        af = self.initial_af
        for i in range(1, n):
            current_high = df['High'].iloc[i]
            current_low = df['Low'].iloc[i]
            previous_sar = sar[i - 1]
            if trend == 1:
                sar_i = previous_sar + af * (ep - previous_sar)
                if i >= 2:
                    sar_i = min(sar_i, df['Low'].iloc[i - 1], df['Low'].iloc[i - 2])
                else:
                    sar_i = min(sar_i, df['Low'].iloc[i - 1])
                if current_low < sar_i:
                    trend = -1
                    sar_i = ep
                    af = self.initial_af
                    ep = current_low
                else:
                    if current_high > ep:
                        ep = current_high
                        af = min(af + self.initial_af, self.max_af)
                sar[i] = sar_i
            else:
                sar_i = previous_sar - af * (previous_sar - ep)
                if i >= 2:
                    sar_i = max(sar_i, df['High'].iloc[i - 1], df['High'].iloc[i - 2])
                else:
                    sar_i = max(sar_i, df['High'].iloc[i - 1])
                if current_high > sar_i:
                    trend = 1
                    sar_i = ep
                    af = self.initial_af
                    ep = current_high
                else:
                    if current_low < ep:
                        ep = current_low
                        af = min(af + self.initial_af, self.max_af)
                sar[i] = sar_i
        self.sar = pd.Series(sar, index=df.index)
        return self.sar

    def calculate_scores_zero_cross_strategy(self, df):
        if self.sar is None:
            self.sar = self.compute_values(df)
        close_prev = df['Close'].shift(1)
        sar_prev = self.sar.shift(1)
        cond_bull = (close_prev < sar_prev) & (df['Close'] > self.sar)
        cond_bear = (close_prev > sar_prev) & (df['Close'] < self.sar)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'SAR_Bullish_Reversal', -1: 'SAR_Bearish_Reversal', 0: 'SAR_Neutral'}
        mapping_explanation = {
            1: f'Price crossed above the SAR, indicating a bullish stop and reverse.',
            -1: f'Price crossed below the SAR, indicating a bearish stop and reverse.',
            0: f'No clear stop and reverse signal detected relative to the SAR.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'SAR_SAR_{self.initial_af}_{self.max_af}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'SAR_TA_Indicator_Value'] = self.sar
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SAR_TA_Indicator_Value'] = self.sar
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.sar is None:
            self.sar = self.compute_values(df)
        diff = df['Close'] - self.sar
        cond_bull = diff > self.upper_threshold
        cond_bear = diff < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Strong_Bullish', -1: 'Strong_Bearish', 0: 'Neutral'}
        mapping_explanation = {
            1: f'Price is significantly above the SAR by more than {self.upper_threshold}, indicating strong bullish momentum.',
            -1: f'Price is significantly below the SAR by more than {abs(self.lower_threshold)}, indicating strong bearish momentum.',
            0: f'Price is near the SAR, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'SAR_Threshold_Signal_Upper:{self.upper_threshold}_Lower:{self.lower_threshold}'
        if append:
            if ta_indicator_value:
                df[f'SAR_TA_Indicator_Value'] = self.sar
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SAR_TA_Indicator_Value'] = self.sar
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.sar is None:
            self.sar = self.compute_values(df)
        diff = self.sar.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'SAR_Rising', -1: 'SAR_Falling', 0: 'SAR_Unchanged'}
        mapping_explanation = {
            1: 'The SAR is rising, indicating strengthening bullish momentum.',
            -1: 'The SAR is falling, indicating strengthening bearish momentum.',
            0: 'The SAR remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'SAR_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'SAR_TA_Indicator_Value'] = self.sar
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'SAR_TA_Indicator_Value'] = self.sar
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
  
  
  
class SummationStrategies:
    def __init__(self, period=14, baseline=0, upper_threshold=0.05, lower_threshold=-0.05):
        self.period = period
        self.baseline = baseline
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.summation = None

    def compute_values(self, df):
        log_returns = np.log(df['Close'] / df['Close'].shift(1))
        summation = log_returns.rolling(window=self.period, min_periods=1).sum()
        return summation

    def calculate_scores_zero_cross_strategy(self, df):
        if self.summation is None:
            self.summation = self.compute_values(df)
        summation_prev = self.summation.shift(1)
        cond_bull = (summation_prev <= self.baseline) & (self.summation > self.baseline)
        cond_bear = (summation_prev >= self.baseline) & (self.summation < self.baseline)
        signals = np.where(cond_bull, 1, np.where(cond_bear, -1, 0))
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Summation_Above_Zero', -1: 'Summation_Below_Zero', 0: 'Summation_Neutral'}
        mapping_explanation = {
            1: f'Summation crossed above zero, indicating a shift to bullish momentum.',
            -1: f'Summation crossed below zero, indicating a shift to bearish momentum.',
            0: 'Summation remains neutral around zero, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'Summation_Period:{self.period}_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'Summation_Period:{self.period}_TA_Indicator_Value'] = self.summation
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = {}
        if ta_indicator_value:
            df_copy[f'Summation_Period:{self.period}_TA_Indicator_Value'] = self.summation
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return pd.DataFrame(df_copy)

    def calculate_scores_threshold_strategy(self, df):
        if self.summation is None:
            self.summation = self.compute_values(df)
        cond_bull = self.summation > self.upper_threshold
        cond_bear = self.summation < self.lower_threshold
        signals = np.where(cond_bull, 1, np.where(cond_bear, -1, 0))
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Summation_High', -1: 'Summation_Low', 0: 'Summation_Neutral'}
        mapping_explanation = {
            1: f'Summation is above the positive threshold of {self.upper_threshold}, suggesting strong bullish conditions.',
            -1: f'Summation is below the negative threshold of {self.lower_threshold}, suggesting strong bearish conditions.',
            0: 'Summation is within the threshold range, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'Summation_Period:{self.period}_Upper_Threshold:{self.upper_threshold}_Lower_Threshold:{self.lower_threshold}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'Summation_Period:{self.period}_TA_Indicator_Value'] = self.summation
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = {}
        if ta_indicator_value:
            df_copy[f'Summation_Period:{self.period}_TA_Indicator_Value'] = self.summation
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return pd.DataFrame(df_copy)

    def calculate_scores_slope_strategy(self, df):
        if self.summation is None:
            self.summation = self.compute_values(df)
        diff = self.summation.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Summation_Rising', -1: 'Summation_Falling', 0: 'Summation_Unchanged'}
        mapping_explanation = {
            1: 'Summation is rising, indicating strengthening bullish momentum.',
            -1: 'Summation is falling, indicating strengthening bearish momentum.',
            0: 'Summation shows no change, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'Summation_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'Summation_Period:{self.period}_TA_Indicator_Value'] = self.summation
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = {}
        if ta_indicator_value:
            df_copy[f'Summation_Period:{self.period}_TA_Indicator_Value'] = self.summation
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return pd.DataFrame(df_copy)

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class SupertrendStrategies:
    def __init__(self, period=10, multiplier=3.0):
        self.period = period
        self.multiplier = multiplier
        self.supertrend = None
        self.trend = None

    def compute_values(self, df):
        high_low = df['High'] - df['Low']
        high_close = (df['High'] - df['Close'].shift(1)).abs()
        low_close = (df['Low'] - df['Close'].shift(1)).abs()
        tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
        atr = tr.rolling(window=self.period, min_periods=1).mean()
        typical_price = (df['High'] + df['Low']) / 2
        basic_ub = typical_price + self.multiplier * atr
        basic_lb = typical_price - self.multiplier * atr
        final_ub_list = [0] * len(df)
        final_lb_list = [0] * len(df)
        for i in range(len(df)):
            if i == 0:
                final_ub_list[i] = basic_ub.iloc[i]
                final_lb_list[i] = basic_lb.iloc[i]
            else:
                if (basic_ub.iloc[i] < final_ub_list[i-1]) or (df['Close'].iloc[i-1] > final_ub_list[i-1]):
                    final_ub_list[i] = basic_ub.iloc[i]
                else:
                    final_ub_list[i] = final_ub_list[i-1]
                if (basic_lb.iloc[i] > final_lb_list[i-1]) or (df['Close'].iloc[i-1] < final_lb_list[i-1]):
                    final_lb_list[i] = basic_lb.iloc[i]
                else:
                    final_lb_list[i] = final_lb_list[i-1]
        final_ub = pd.Series(final_ub_list, index=df.index)
        final_lb = pd.Series(final_lb_list, index=df.index)
        supertrend_list = [None] * len(df)
        trend_list = [0] * len(df)
        for i in range(len(df)):
            if i == 0:
                supertrend_list[i] = None
                trend_list[i] = 1
            else:
                if df['Close'].iloc[i] <= final_ub.iloc[i]:
                    supertrend_list[i] = final_ub.iloc[i]
                    trend_list[i] = -1
                elif df['Close'].iloc[i] >= final_lb.iloc[i]:
                    supertrend_list[i] = final_lb.iloc[i]
                    trend_list[i] = 1
                else:
                    supertrend_list[i] = supertrend_list[i-1]
                    trend_list[i] = trend_list[i-1]
        self.supertrend = pd.Series(supertrend_list, index=df.index)
        self.trend = pd.Series(trend_list, index=df.index)
        return self.supertrend, self.trend

    def calculate_scores_zero_cross_strategy(self, df):
        if self.trend is None:
            self.compute_values(df)
        trend_prev = self.trend.shift(1)
        signals = np.where((trend_prev == -1) & (self.trend == 1), 1, np.where((trend_prev == 1) & (self.trend == -1), -1, 0))
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'ST_TrendShift_Bullish', -1: 'ST_TrendShift_Bearish', 0: 'ST_TrendShift_Neutral'}
        mapping_explanation = {
            1: 'Supertrend shifted from bearish to bullish, indicating a potential bullish reversal.',
            -1: 'Supertrend shifted from bullish to bearish, indicating a potential bearish reversal.',
            0: 'No trend shift detected in Supertrend, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'ST_Period:{self.period}_Multiplier:{self.multiplier}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'ST_Period:{self.period}_TA_Indicator_Value'] = self.supertrend
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = {}
        if ta_indicator_value:
            df_copy[f'ST_Period:{self.period}_TA_Indicator_Value'] = self.supertrend
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return pd.DataFrame(df_copy)

    def calculate_scores_price_cross_strategy(self, df):
        if self.supertrend is None:
            self.compute_values(df)
        close_prev = df['Close'].shift(1)
        st_prev = self.supertrend.shift(1)
        cond_bull = (close_prev < st_prev) & (df['Close'] > self.supertrend)
        cond_bear = (close_prev > st_prev) & (df['Close'] < self.supertrend)
        signals = np.where(cond_bull, 1, np.where(cond_bear, -1, 0))
        return pd.Series(signals, index=df.index)

    def price_cross_map(self, series):
        mapping_value = {1: 'PriceAbove_ST', -1: 'PriceBelow_ST', 0: 'PriceAround_ST'}
        mapping_explanation = {
            1: 'Closing price crossed above the Supertrend value, indicating bullish momentum.',
            -1: 'Closing price crossed below the Supertrend value, indicating bearish momentum.',
            0: 'No significant price cross relative to Supertrend detected, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = f'ST_Period:{self.period}_Multiplier:{self.multiplier}_PriceCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'ST_Period:{self.period}_TA_Indicator_Value'] = self.supertrend
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = {}
        if ta_indicator_value:
            df_copy[f'ST_Period:{self.period}_TA_Indicator_Value'] = self.supertrend
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return pd.DataFrame(df_copy)

    def calculate_scores_slope_strategy(self, df):
        if self.supertrend is None:
            self.compute_values(df)
        diff = (df['Close'] - self.supertrend).diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'PriceGap_Widening', -1: 'PriceGap_Narrowing', 0: 'PriceGap_Unchanged'}
        mapping_explanation = {
            1: 'The gap between the closing price and Supertrend is widening in a bullish manner.',
            -1: 'The gap between the closing price and Supertrend is narrowing or reversing, indicating bearish pressure.',
            0: 'No change in the price gap relative to Supertrend, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'ST_Period:{self.period}_Multiplier:{self.multiplier}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'ST_Period:{self.period}_TA_Indicator_Value'] = self.supertrend
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = {}
        if ta_indicator_value:
            df_copy[f'ST_Period:{self.period}_TA_Indicator_Value'] = self.supertrend
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return pd.DataFrame(df_copy)

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class SymmetricWeightedMovingAverageStrategies:
    def __init__(self, period=5, price_column='Close', pos_threshold=0.02, neg_threshold=-0.02):
        self.period = period
        self.price_column = price_column
        self.pos_threshold = pos_threshold
        self.neg_threshold = neg_threshold
        self.swma = None

    def compute_weights(self):
        if self.period % 2 == 1:
            mid = self.period // 2 + 1
            weights = list(range(1, mid + 1)) + list(range(mid - 1, 0, -1))
        else:
            mid = self.period // 2
            weights = list(range(1, mid + 1)) + list(range(mid, 0, -1))
        return weights

    def compute_values(self, df):
        weights = self.compute_weights()
        swma_list = []
        price_series = df[self.price_column]
        for i in range(len(price_series)):
            if i < self.period - 1:
                swma_list.append(None)
            else:
                window = price_series.iloc[i - self.period + 1 : i + 1]
                weighted_sum = sum(w * price for w, price in zip(weights, window))
                swma_value = weighted_sum / sum(weights)
                swma_list.append(swma_value)
        self.swma = pd.Series(swma_list, index=df.index)
        return self.swma

    def calculate_scores_price_cross_strategy(self, df):
        if self.swma is None:
            self.compute_values(df)
        price = df[self.price_column]
        price_prev = price.shift(1)
        swma_prev = self.swma.shift(1)
        cond_bull = (price_prev <= swma_prev) & (price > self.swma)
        cond_bear = (price_prev >= swma_prev) & (price < self.swma)
        signals = np.where(cond_bull, 1, np.where(cond_bear, -1, 0))
        return pd.Series(signals, index=df.index)

    def price_cross_map(self, series):
        mapping_value = {1: 'PriceAbove_SWMA', -1: 'PriceBelow_SWMA', 0: 'PriceNeutral'}
        mapping_explanation = {
            1: 'Price crossed above the SWMA, indicating bullish momentum.',
            -1: 'Price crossed below the SWMA, indicating bearish momentum.',
            0: 'No significant price cross relative to the SWMA, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = f'SWMA_Period:{self.period}_PriceCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'SWMA_Period:{self.period}_TA_Indicator_Value'] = self.swma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = {}
        if ta_indicator_value:
            df_copy[f'SWMA_Period:{self.period}_TA_Indicator_Value'] = self.swma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return pd.DataFrame(df_copy)

    def calculate_scores_slope_strategy(self, df):
        if self.swma is None:
            self.compute_values(df)
        diff = self.swma.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'SWMA_Rising', -1: 'SWMA_Falling', 0: 'SWMA_Unchanged'}
        mapping_explanation = {
            1: 'SWMA is rising, indicating a bullish trend.',
            -1: 'SWMA is falling, indicating a bearish trend.',
            0: 'SWMA is flat, indicating neutral trend conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'SWMA_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'SWMA_Period:{self.period}_TA_Indicator_Value'] = self.swma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = {}
        if ta_indicator_value:
            df_copy[f'SWMA_Period:{self.period}_TA_Indicator_Value'] = self.swma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return pd.DataFrame(df_copy)

    def calculate_scores_threshold_strategy(self, df):
        if self.swma is None:
            self.compute_values(df)
        price = df[self.price_column]
        diff = price - self.swma
        cond_bull = diff > self.pos_threshold
        cond_bear = diff < self.neg_threshold
        signals = np.where(cond_bull, 1, np.where(cond_bear, -1, 0))
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'PriceMuchAbove_SWMA', -1: 'PriceMuchBelow_SWMA', 0: 'PriceAround_SWMA'}
        mapping_explanation = {
            1: 'Price is significantly above the SWMA, indicating strong bullish conditions.',
            -1: 'Price is significantly below the SWMA, indicating strong bearish conditions.',
            0: 'Price is close to the SWMA, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'SWMA_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'SWMA_Period:{self.period}_TA_Indicator_Value'] = self.swma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = {}
        if ta_indicator_value:
            df_copy[f'SWMA_Period:{self.period}_TA_Indicator_Value'] = self.swma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return pd.DataFrame(df_copy)

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class T3MovingAverageStrategies:
    def __init__(self, period=10, v=0.7, price_column='Close', pos_threshold=0.02, neg_threshold=-0.02):
        self.period = period
        self.v = v
        self.price_column = price_column
        self.pos_threshold = pos_threshold
        self.neg_threshold = neg_threshold
        self.t3 = None

    def compute_values(self, df):
        price = df[self.price_column]
        ema1 = price.ewm(span=self.period, adjust=False).mean()
        ema2 = ema1.ewm(span=self.period, adjust=False).mean()
        ema3 = ema2.ewm(span=self.period, adjust=False).mean()
        ema4 = ema3.ewm(span=self.period, adjust=False).mean()
        c1 = -self.v**3
        c2 = 3*self.v**2 + 3*self.v**3
        c3 = -6*self.v**2 - self.v - 3*self.v**3
        c4 = 1 + 3*self.v + self.v**3 + 3*self.v**2
        t3 = c1 * ema4 + c2 * ema3 + c3 * ema2 + c4 * ema1
        self.t3 = t3
        return self.t3

    def calculate_scores_price_cross_strategy(self, df):
        if self.t3 is None:
            self.compute_values(df)
        price = df[self.price_column]
        price_prev = price.shift(1)
        t3_prev = self.t3.shift(1)
        cond_bull = (price_prev <= t3_prev) & (price > self.t3)
        cond_bear = (price_prev >= t3_prev) & (price < self.t3)
        signals = np.where(cond_bull, 1, np.where(cond_bear, -1, 0))
        return pd.Series(signals, index=df.index)

    def price_cross_map(self, series):
        mapping_value = {1: 'PriceAbove_T3', -1: 'PriceBelow_T3', 0: 'PriceNeutral'}
        mapping_explanation = {
            1: 'Price crossed above the T3 Moving Average, indicating bullish momentum.',
            -1: 'Price crossed below the T3 Moving Average, indicating bearish momentum.',
            0: 'No significant price cross relative to the T3 Moving Average, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_cross_strategy(df)
        value, explanation = self.price_cross_map(score)
        column_prefix = f'T3MA_Period:{self.period}_PriceCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'T3MA_Period:{self.period}_TA_Indicator_Value'] = self.t3
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = {}
        if ta_indicator_value:
            df_copy[f'T3MA_Period:{self.period}_TA_Indicator_Value'] = self.t3
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return pd.DataFrame(df_copy)

    def calculate_scores_slope_strategy(self, df):
        if self.t3 is None:
            self.compute_values(df)
        diff = self.t3.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'T3_Rising', -1: 'T3_Falling', 0: 'T3_Unchanged'}
        mapping_explanation = {
            1: 'The T3 Moving Average is rising, indicating bullish trend strength.',
            -1: 'The T3 Moving Average is falling, indicating bearish trend strength.',
            0: 'The T3 Moving Average is unchanged, indicating neutral trend conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'T3MA_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'T3MA_Period:{self.period}_TA_Indicator_Value'] = self.t3
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = {}
        if ta_indicator_value:
            df_copy[f'T3MA_Period:{self.period}_TA_Indicator_Value'] = self.t3
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return pd.DataFrame(df_copy)

    def calculate_scores_threshold_strategy(self, df):
        if self.t3 is None:
            self.compute_values(df)
        price = df[self.price_column]
        diff = price - self.t3
        cond_bull = diff > self.pos_threshold
        cond_bear = diff < self.neg_threshold
        signals = np.where(cond_bull, 1, np.where(cond_bear, -1, 0))
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'PriceMuchAbove_T3', -1: 'PriceMuchBelow_T3', 0: 'PriceAround_T3'}
        mapping_explanation = {
            1: 'Price is significantly above the T3 Moving Average, indicating strong bullish conditions.',
            -1: 'Price is significantly below the T3 Moving Average, indicating strong bearish conditions.',
            0: 'Price is close to the T3 Moving Average, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'T3MA_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'T3MA_Period:{self.period}_TA_Indicator_Value'] = self.t3
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = {}
        if ta_indicator_value:
            df_copy[f'T3MA_Period:{self.period}_TA_Indicator_Value'] = self.t3
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return pd.DataFrame(df_copy)

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        # df_copy_1 = self.calculate_price_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        # df_copy_3 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        # return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
        return pd.concat([ df_copy_2], axis=1)


  
class TDSequentialStrategies:
    def __init__(self, threshold=7, completion_count=9):
        self.threshold = threshold
        self.completion_count = completion_count
        self.buy_setup = None
        self.sell_setup = None

    def compute_values(self, df):
        buy_counts = [0] * len(df)
        sell_counts = [0] * len(df)
        closes = df['Close'].tolist()
        for i in range(len(df)):
            if i < 4:
                buy_counts[i] = 0
                sell_counts[i] = 0
            else:
                if closes[i] < closes[i - 4]:
                    buy_counts[i] = buy_counts[i - 1] + 1
                else:
                    buy_counts[i] = 0
                if closes[i] > closes[i - 4]:
                    sell_counts[i] = sell_counts[i - 1] + 1
                else:
                    sell_counts[i] = 0
        self.buy_setup = pd.Series(buy_counts, index=df.index)
        self.sell_setup = pd.Series(sell_counts, index=df.index)
        return self.buy_setup, self.sell_setup

    def calculate_scores_setup_completion_strategy(self, df):
        if self.buy_setup is None or self.sell_setup is None:
            self.compute_values(df)
        signals = np.select([self.buy_setup == self.completion_count, self.sell_setup == self.completion_count], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def setup_completion_map(self, series):
        mapping_value = {1: 'TDSequential_Buy_Setup_Complete', -1: 'TDSequential_Sell_Setup_Complete', 0: 'TDSequential_No_Completion'}
        mapping_explanation = {
            1: f'Buy setup count reached {self.completion_count}, indicating a potential bullish reversal.',
            -1: f'Sell setup count reached {self.completion_count}, indicating a potential bearish reversal.',
            0: f'No setup completion detected at the {self.completion_count} count threshold.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_setup_completion_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_setup_completion_strategy(df)
        value, explanation = self.setup_completion_map(score)
        column_prefix = f'TDSeq_Completion_Count:{self.completion_count}_Signal'
        if append:
            if ta_indicator_value:
                df['TDSeq_Buy_Setup'] = self.buy_setup
                df['TDSeq_Sell_Setup'] = self.sell_setup
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['TDSeq_Buy_Setup'] = self.buy_setup
            df_copy['TDSeq_Sell_Setup'] = self.sell_setup
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.buy_setup is None or self.sell_setup is None:
            self.compute_values(df)
        signals = np.select([self.buy_setup >= self.threshold, self.sell_setup >= self.threshold], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'TDSequential_Buy_Setup_Threshold', -1: 'TDSequential_Sell_Setup_Threshold', 0: 'TDSequential_Setup_Neutral'}
        mapping_explanation = {
            1: f'Buy setup count is at or above the threshold of {self.threshold}, suggesting an impending bullish reversal.',
            -1: f'Sell setup count is at or above the threshold of {self.threshold}, suggesting an impending bearish reversal.',
            0: f'Neither setup count has reached the threshold of {self.threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'TDSeq_Threshold:{self.threshold}_Signal'
        if append:
            if ta_indicator_value:
                df['TDSeq_Buy_Setup'] = self.buy_setup
                df['TDSeq_Sell_Setup'] = self.sell_setup
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['TDSeq_Buy_Setup'] = self.buy_setup
            df_copy['TDSeq_Sell_Setup'] = self.sell_setup
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_setup_completion_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2], axis=1)

  
  
class TrendSignalsStrategies:
    def __init__(self, short_period=10, long_period=50, threshold=0):
        self.short_period = short_period
        self.long_period = long_period
        self.threshold = threshold
        self.trend_signal = None

    def compute_values(self, df):
        sma_short = df['Close'].rolling(window=self.short_period, min_periods=1).mean()
        sma_long = df['Close'].rolling(window=self.long_period, min_periods=1).mean()
        self.trend_signal = sma_short - sma_long
        return self.trend_signal

    def calculate_scores_zero_cross_strategy(self, df):
        if self.trend_signal is None:
            self.compute_values(df)
        ts_prev = self.trend_signal.shift(1)
        ts_current = self.trend_signal
        cond_bull = (ts_prev <= 0) & (ts_current > 0)
        cond_bear = (ts_prev >= 0) & (ts_current < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'TrendSignals_Cross_Above_Zero', -1: 'TrendSignals_Cross_Below_Zero', 0: 'TrendSignals_Neutral'}
        mapping_explanation = {
            1: 'TrendSignals crossed above zero, indicating a shift to bullish conditions.',
            -1: 'TrendSignals crossed below zero, indicating a shift to bearish conditions.',
            0: 'TrendSignals remains around zero, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = 'TS_Strategy_ZeroCross'
        if append:
            if ta_indicator_value:
                df['TS_TA_Indicator_Value'] = self.trend_signal
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['TS_TA_Indicator_Value'] = self.trend_signal
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.trend_signal is None:
            self.compute_values(df)
        cond_bull = self.trend_signal > self.threshold
        cond_bear = self.trend_signal < -self.threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'TrendSignals_Above_Threshold', -1: 'TrendSignals_Below_Threshold', 0: 'TrendSignals_Neutral'}
        mapping_explanation = {
            1: f'TrendSignals is above the threshold of {self.threshold}, indicating bullish conditions.',
            -1: f'TrendSignals is below the negative threshold of {-self.threshold}, indicating bearish conditions.',
            0: f'TrendSignals is within the threshold range, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = 'TS_Strategy_Threshold'
        if append:
            if ta_indicator_value:
                df['TS_TA_Indicator_Value'] = self.trend_signal
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['TS_TA_Indicator_Value'] = self.trend_signal
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.trend_signal is None:
            self.compute_values(df)
        diff = self.trend_signal.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'TrendSignals_Rising', -1: 'TrendSignals_Falling', 0: 'TrendSignals_Unchanged'}
        mapping_explanation = {
            1: 'TrendSignals is rising, indicating strengthening bullish momentum.',
            -1: 'TrendSignals is falling, indicating strengthening bearish momentum.',
            0: 'TrendSignals is unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'TS_Strategy_Slope'
        if append:
            if ta_indicator_value:
                df['TS_TA_Indicator_Value'] = self.trend_signal
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['TS_TA_Indicator_Value'] = self.trend_signal
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class TriangularMovingAverageStrategies:
    def __init__(self, period=20, threshold_percentage=0.01):
        self.period = period
        self.threshold_percentage = threshold_percentage
        self.tma = None

    def compute_values(self, df):
        inner_sma = df['Close'].rolling(window=self.period, min_periods=1).mean()
        self.tma = inner_sma.rolling(window=self.period, min_periods=1).mean()
        return self.tma

    def calculate_scores_price_crossover_strategy(self, df):
        if self.tma is None:
            self.compute_values(df)
        price_prev = df['Close'].shift(1)
        tma_prev = self.tma.shift(1)
        price_current = df['Close']
        tma_current = self.tma
        cond_bull = (price_prev <= tma_prev) & (price_current > tma_current)
        cond_bear = (price_prev >= tma_prev) & (price_current < tma_current)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def price_crossover_map(self, series):
        mapping_value = {1: 'Price_Above_TMA', -1: 'Price_Below_TMA', 0: 'Price_Neutral'}
        mapping_explanation = {
            1: 'Price has crossed above the Triangular Moving Average, indicating bullish conditions.',
            -1: 'Price has crossed below the Triangular Moving Average, indicating bearish conditions.',
            0: 'No significant price crossover with the Triangular Moving Average detected.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_crossover_strategy(df)
        value, explanation = self.price_crossover_map(score)
        column_prefix = f'TMA_Period:{self.period}_PriceCrossover_Signal'
        if append:
            if ta_indicator_value:
                df[f'TMA_Period:{self.period}_TA_Indicator_Value'] = self.tma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'TMA_Period:{self.period}_TA_Indicator_Value'] = self.tma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.tma is None:
            self.compute_values(df)
        diff = self.tma.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'TMA_Rising', -1: 'TMA_Falling', 0: 'TMA_Unchanged'}
        mapping_explanation = {
            1: 'Triangular Moving Average is rising, indicating bullish momentum.',
            -1: 'Triangular Moving Average is falling, indicating bearish momentum.',
            0: 'Triangular Moving Average remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'TMA_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'TMA_Period:{self.period}_TA_Indicator_Value'] = self.tma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'TMA_Period:{self.period}_TA_Indicator_Value'] = self.tma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.tma is None:
            self.compute_values(df)
        ratio = (df['Close'] - self.tma) / self.tma
        cond_bull = ratio > self.threshold_percentage
        cond_bear = ratio < -self.threshold_percentage
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Price_Above_Threshold', -1: 'Price_Below_Threshold', 0: 'Price_Near_TMA'}
        mapping_explanation = {
            1: f'Price is more than {self.threshold_percentage * 100}% above the TMA, indicating strong bullish conditions.',
            -1: f'Price is more than {self.threshold_percentage * 100}% below the TMA, indicating strong bearish conditions.',
            0: f'Price is within {self.threshold_percentage * 100}% of the TMA, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'TMA_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'TMA_Period:{self.period}_TA_Indicator_Value'] = self.tma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'TMA_Period:{self.period}_TA_Indicator_Value'] = self.tma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_crossover_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class TripleExponentialMovingAverageOscillatorStrategies:
    def __init__(self, period=15, threshold_value=0.2):
        self.period = period
        self.threshold_value = threshold_value
        self.trix = None

    def compute_values(self, df):
        alpha = 2 / (self.period + 1)
        e1 = df['Close'].ewm(alpha=alpha, adjust=False).mean()
        e2 = e1.ewm(alpha=alpha, adjust=False).mean()
        e3 = e2.ewm(alpha=alpha, adjust=False).mean()
        self.trix = 100 * (e3 - e3.shift(1)) / e3.shift(1)
        return self.trix

    def calculate_scores_zero_cross_strategy(self, df):
        if self.trix is None:
            self.compute_values(df)
        trix_prev = self.trix.shift(1)
        trix_current = self.trix
        cond_bull = (trix_prev <= 0) & (trix_current > 0)
        cond_bear = (trix_prev >= 0) & (trix_current < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'TRIX_Cross_Above_Zero', -1: 'TRIX_Cross_Below_Zero', 0: 'TRIX_Neutral'}
        mapping_explanation = {
            1: 'TRIX crossed above zero, indicating a bullish momentum shift.',
            -1: 'TRIX crossed below zero, indicating a bearish momentum shift.',
            0: 'TRIX remains around zero, indicating no clear momentum shift.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'TRIX_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'TRIX_Period:{self.period}_TA_Indicator_Value'] = self.trix
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'TRIX_Period:{self.period}_TA_Indicator_Value'] = self.trix
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.trix is None:
            self.compute_values(df)
        diff = self.trix.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'TRIX_Rising', -1: 'TRIX_Falling', 0: 'TRIX_Unchanged'}
        mapping_explanation = {
            1: 'TRIX is rising, indicating strengthening bullish momentum.',
            -1: 'TRIX is falling, indicating strengthening bearish momentum.',
            0: 'TRIX remains unchanged, indicating a lack of momentum shift.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'TRIX_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'TRIX_Period:{self.period}_TA_Indicator_Value'] = self.trix
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'TRIX_Period:{self.period}_TA_Indicator_Value'] = self.trix
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.trix is None:
            self.compute_values(df)
        cond_bull = self.trix > self.threshold_value
        cond_bear = self.trix < -self.threshold_value
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'TRIX_Above_Threshold', -1: 'TRIX_Below_Threshold', 0: 'TRIX_Near_Zero'}
        mapping_explanation = {
            1: f'TRIX is above the threshold of {self.threshold_value}, indicating strong bullish momentum.',
            -1: f'TRIX is below the negative threshold of {-self.threshold_value}, indicating strong bearish momentum.',
            0: f'TRIX is within the threshold range, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'TRIX_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'TRIX_Period:{self.period}_TA_Indicator_Value'] = self.trix
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'TRIX_Period:{self.period}_TA_Indicator_Value'] = self.trix
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class TrixStrategies:
    def __init__(self, period=15, threshold_value=0.2):
        self.period = period
        self.threshold_value = threshold_value
        self.trix = None

    def compute_values(self, df):
        alpha = 2 / (self.period + 1)
        e1 = df['Close'].ewm(alpha=alpha, adjust=False).mean()
        e2 = e1.ewm(alpha=alpha, adjust=False).mean()
        e3 = e2.ewm(alpha=alpha, adjust=False).mean()
        self.trix = 100 * (e3 - e3.shift(1)) / e3.shift(1)
        return self.trix

    def calculate_scores_zero_cross_strategy(self, df):
        if self.trix is None:
            self.compute_values(df)
        trix_prev = self.trix.shift(1)
        trix_current = self.trix
        cond_bull = (trix_prev <= 0) & (trix_current > 0)
        cond_bear = (trix_prev >= 0) & (trix_current < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'TRIX_Cross_Above_Zero', -1: 'TRIX_Cross_Below_Zero', 0: 'TRIX_Neutral'}
        mapping_explanation = {
            1: 'TRIX crossed above zero, indicating bullish momentum.',
            -1: 'TRIX crossed below zero, indicating bearish momentum.',
            0: 'TRIX remains around zero, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'TRIX_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'TRIX_Period:{self.period}_TA_Indicator_Value'] = self.trix
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'TRIX_Period:{self.period}_TA_Indicator_Value'] = self.trix
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.trix is None:
            self.compute_values(df)
        diff = self.trix.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'TRIX_Rising', -1: 'TRIX_Falling', 0: 'TRIX_Unchanged'}
        mapping_explanation = {
            1: 'TRIX is rising, indicating strengthening bullish momentum.',
            -1: 'TRIX is falling, indicating strengthening bearish momentum.',
            0: 'TRIX remains unchanged, indicating no clear momentum shift.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'TRIX_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'TRIX_Period:{self.period}_TA_Indicator_Value'] = self.trix
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'TRIX_Period:{self.period}_TA_Indicator_Value'] = self.trix
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.trix is None:
            self.compute_values(df)
        cond_bull = self.trix > self.threshold_value
        cond_bear = self.trix < -self.threshold_value
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'TRIX_Above_Threshold', -1: 'TRIX_Below_Threshold', 0: 'TRIX_Neutral'}
        mapping_explanation = {
            1: f'TRIX is above the threshold of {self.threshold_value}, indicating strong bullish momentum.',
            -1: f'TRIX is below the negative threshold of {-self.threshold_value}, indicating strong bearish momentum.',
            0: f'TRIX is within the threshold range, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'TRIX_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'TRIX_Period:{self.period}_TA_Indicator_Value'] = self.trix
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'TRIX_Period:{self.period}_TA_Indicator_Value'] = self.trix
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class TwiggsMoneyIndexStrategies:
    def __init__(self, period=20, upper_threshold=100000, lower_threshold=-100000):
        self.period = period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.tmi = None

    def compute_values(self, df):
        condition = (df['High'] - df['Low']) != 0
        mf = np.where(condition, (((df['Close'] - df['Low']) - (df['High'] - df['Close'])) / (df['High'] - df['Low'])) * df['Volume'], 0)
        self.tmi = pd.Series(mf, index=df.index).rolling(window=self.period, min_periods=1).sum()
        return self.tmi

    def calculate_scores_zero_cross_strategy(self, df):
        if self.tmi is None:
            self.compute_values(df)
        tmi_prev = self.tmi.shift(1)
        tmi_current = self.tmi
        cond_bull = (tmi_prev <= 0) & (tmi_current > 0)
        cond_bear = (tmi_prev >= 0) & (tmi_current < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'TMI_Cross_Above_Zero', -1: 'TMI_Cross_Below_Zero', 0: 'TMI_Neutral'}
        mapping_explanation = {
            1: 'Twiggs Money Index crossed above zero, indicating a shift to bullish buying pressure.',
            -1: 'Twiggs Money Index crossed below zero, indicating a shift to bearish selling pressure.',
            0: 'Twiggs Money Index remains around zero, indicating neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'TMI_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'TMI_Period:{self.period}_TA_Indicator_Value'] = self.tmi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'TMI_Period:{self.period}_TA_Indicator_Value'] = self.tmi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.tmi is None:
            self.compute_values(df)
        cond_bull = self.tmi > self.upper_threshold
        cond_bear = self.tmi < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'TMI_Above_Upper_Threshold', -1: 'TMI_Below_Lower_Threshold', 0: 'TMI_Neutral'}
        mapping_explanation = {
            1: f'Twiggs Money Index is above the upper threshold of {self.upper_threshold}, indicating strong bullish accumulation.',
            -1: f'Twiggs Money Index is below the lower threshold of {self.lower_threshold}, indicating strong bearish distribution.',
            0: f'Twiggs Money Index is between the set thresholds, indicating neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'TMI_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'TMI_Period:{self.period}_TA_Indicator_Value'] = self.tmi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'TMI_Period:{self.period}_TA_Indicator_Value'] = self.tmi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.tmi is None:
            self.compute_values(df)
        diff = self.tmi.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'TMI_Rising', -1: 'TMI_Falling', 0: 'TMI_Unchanged'}
        mapping_explanation = {
            1: 'Twiggs Money Index is rising, indicating increasing bullish money flow.',
            -1: 'Twiggs Money Index is falling, indicating increasing bearish money flow.',
            0: 'Twiggs Money Index is unchanged, indicating balanced market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'TMI_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'TMI_Period:{self.period}_TA_Indicator_Value'] = self.tmi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'TMI_Period:{self.period}_TA_Indicator_Value'] = self.tmi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class TTMTrendStrategies:
    def __init__(self, period=20, threshold_percentage=0.01):
        self.period = period
        self.threshold_percentage = threshold_percentage
        self.ttm = None

    def compute_values(self, df):
        ema1 = df['Close'].ewm(span=self.period, adjust=False).mean()
        ema2 = ema1.ewm(span=self.period, adjust=False).mean()
        self.ttm = ema1 - ema2
        return self.ttm

    def calculate_scores_zero_cross_strategy(self, df):
        if self.ttm is None:
            self.compute_values(df)
        ttm_prev = self.ttm.shift(1)
        ttm_current = self.ttm
        cond_bull = (ttm_prev <= 0) & (ttm_current > 0)
        cond_bear = (ttm_prev >= 0) & (ttm_current < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'TTMTrend_Cross_Above_Zero', -1: 'TTMTrend_Cross_Below_Zero', 0: 'TTMTrend_Neutral'}
        mapping_explanation = {
            1: 'TTM Trend crossed above zero, indicating a bullish trend shift.',
            -1: 'TTM Trend crossed below zero, indicating a bearish trend shift.',
            0: 'TTM Trend remains around zero, indicating no clear trend shift.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'TTMTrend_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'TTMTrend_Period:{self.period}_TA_Indicator_Value'] = self.ttm
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'TTMTrend_Period:{self.period}_TA_Indicator_Value'] = self.ttm
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_price_crossover_strategy(self, df):
        if self.ttm is None:
            self.compute_values(df)
        price_prev = df['Close'].shift(1)
        ttm_prev = self.ttm.shift(1)
        price_current = df['Close']
        ttm_current = self.ttm
        cond_bull = (price_prev <= ttm_prev) & (price_current > ttm_current)
        cond_bear = (price_prev >= ttm_prev) & (price_current < ttm_current)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def price_crossover_map(self, series):
        mapping_value = {1: 'Price_Above_TTMTrend', -1: 'Price_Below_TTMTrend', 0: 'Price_Neutral'}
        mapping_explanation = {
            1: 'Price crossed above the TTM Trend line, indicating bullish conditions.',
            -1: 'Price crossed below the TTM Trend line, indicating bearish conditions.',
            0: 'No significant price crossover with the TTM Trend line detected.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_crossover_strategy(df)
        value, explanation = self.price_crossover_map(score)
        column_prefix = f'TTMTrend_Period:{self.period}_PriceCrossover_Signal'
        if append:
            if ta_indicator_value:
                df[f'TTMTrend_Period:{self.period}_TA_Indicator_Value'] = self.ttm
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'TTMTrend_Period:{self.period}_TA_Indicator_Value'] = self.ttm
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.ttm is None:
            self.compute_values(df)
        diff = self.ttm.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'TTMTrend_Rising', -1: 'TTMTrend_Falling', 0: 'TTMTrend_Unchanged'}
        mapping_explanation = {
            1: 'TTM Trend is rising, indicating strengthening bullish momentum.',
            -1: 'TTM Trend is falling, indicating strengthening bearish momentum.',
            0: 'TTM Trend is unchanged, indicating a lack of momentum shift.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'TTMTrend_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'TTMTrend_Period:{self.period}_TA_Indicator_Value'] = self.ttm
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'TTMTrend_Period:{self.period}_TA_Indicator_Value'] = self.ttm
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        # df_copy_2 = self.calculate_price_crossover_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        # return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)
        return pd.concat([df_copy_1, df_copy_3], axis=1)


  
  
class TypicalPriceStrategies:
    def __init__(self, threshold_percentage=0.01):
        self.threshold_percentage = threshold_percentage
        self.tp = None

    def compute_values(self, df):
        self.tp = (df['High'] + df['Low'] + df['Close']) / 3
        return self.tp

    def calculate_scores_price_crossover_strategy(self, df):
        if self.tp is None:
            self.compute_values(df)
        close_prev = df['Close'].shift(1)
        tp_prev = self.tp.shift(1)
        close_current = df['Close']
        tp_current = self.tp
        cond_bull = (close_prev <= tp_prev) & (close_current > tp_current)
        cond_bear = (close_prev >= tp_prev) & (close_current < tp_current)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def price_crossover_map(self, series):
        mapping_value = {1: 'Close_Above_TP', -1: 'Close_Below_TP', 0: 'TP_Neutral'}
        mapping_explanation = {
            1: 'The closing price has crossed above the Typical Price, suggesting bullish conditions.',
            -1: 'The closing price has crossed below the Typical Price, suggesting bearish conditions.',
            0: 'No significant crossover between the closing price and the Typical Price.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_crossover_strategy(df)
        value, explanation = self.price_crossover_map(score)
        column_prefix = 'TP_PriceCrossover_Signal'
        if append:
            if ta_indicator_value:
                df['TP_TA_Indicator_Value'] = self.tp
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['TP_TA_Indicator_Value'] = self.tp
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.tp is None:
            self.compute_values(df)
        diff = self.tp.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'TP_Rising', -1: 'TP_Falling', 0: 'TP_Unchanged'}
        mapping_explanation = {
            1: 'The Typical Price is rising, indicating upward momentum.',
            -1: 'The Typical Price is falling, indicating downward momentum.',
            0: 'The Typical Price remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'TP_Slope_Signal'
        if append:
            if ta_indicator_value:
                df['TP_TA_Indicator_Value'] = self.tp
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['TP_TA_Indicator_Value'] = self.tp
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.tp is None:
            self.compute_values(df)
        diff_ratio = (df['Close'] - self.tp) / self.tp
        cond_bull = diff_ratio > self.threshold_percentage
        cond_bear = diff_ratio < -self.threshold_percentage
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Close_Significantly_Above_TP', -1: 'Close_Significantly_Below_TP', 0: 'Close_Near_TP'}
        mapping_explanation = {
            1: f'The closing price is more than {self.threshold_percentage * 100}% above the Typical Price, indicating strong bullish pressure.',
            -1: f'The closing price is more than {self.threshold_percentage * 100}% below the Typical Price, indicating strong bearish pressure.',
            0: f'The closing price is within {self.threshold_percentage * 100}% of the Typical Price, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = 'TP_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df['TP_TA_Indicator_Value'] = self.tp
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['TP_TA_Indicator_Value'] = self.tp
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_crossover_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class UltimateOscillatorStrategies:
    def __init__(self, period1=7, period2=14, period3=28, baseline=50, lower_threshold=30, upper_threshold=70):
        self.period1 = period1
        self.period2 = period2
        self.period3 = period3
        self.baseline = baseline
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.uo = None

    def compute_values(self, df):
        prev_close = df['Close'].shift(1)
        bp = df['Close'] - np.minimum(df['Low'], prev_close)
        tr = np.maximum(df['High'], prev_close) - np.minimum(df['Low'], prev_close)
        avg1 = bp.rolling(window=self.period1, min_periods=1).sum() / tr.rolling(window=self.period1, min_periods=1).sum()
        avg2 = bp.rolling(window=self.period2, min_periods=1).sum() / tr.rolling(window=self.period2, min_periods=1).sum()
        avg3 = bp.rolling(window=self.period3, min_periods=1).sum() / tr.rolling(window=self.period3, min_periods=1).sum()
        self.uo = 100 * (4 * avg1 + 2 * avg2 + avg3) / 7
        return self.uo

    def calculate_scores_zero_cross_strategy(self, df):
        if self.uo is None:
            self.compute_values(df)
        uo_prev = self.uo.shift(1)
        uo_current = self.uo
        cond_bull = (uo_prev <= self.baseline) & (uo_current > self.baseline)
        cond_bear = (uo_prev >= self.baseline) & (uo_current < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'UO_Cross_Above_Baseline', -1: 'UO_Cross_Below_Baseline', 0: 'UO_Neutral'}
        mapping_explanation = {
            1: f'UO crossed above the baseline of {self.baseline}, suggesting bullish momentum.',
            -1: f'UO crossed below the baseline of {self.baseline}, suggesting bearish momentum.',
            0: f'UO remains around the baseline of {self.baseline}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'UO_Baseline:{self.baseline}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'UO_TA_Indicator_Value'] = self.uo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'UO_TA_Indicator_Value'] = self.uo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.uo is None:
            self.compute_values(df)
        cond_bull = self.uo < self.lower_threshold
        cond_bear = self.uo > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'UO_Oversold', -1: 'UO_Overbought', 0: 'UO_Neutral'}
        mapping_explanation = {
            1: f'UO is below {self.lower_threshold}, indicating oversold conditions and potential bullish reversal.',
            -1: f'UO is above {self.upper_threshold}, indicating overbought conditions and potential bearish reversal.',
            0: f'UO is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'UO_Threshold_Low:{self.lower_threshold}_High:{self.upper_threshold}_Signal'
        if append:
            if ta_indicator_value:
                df[f'UO_TA_Indicator_Value'] = self.uo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'UO_TA_Indicator_Value'] = self.uo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.uo is None:
            self.compute_values(df)
        diff = self.uo.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'UO_Rising', -1: 'UO_Falling', 0: 'UO_Unchanged'}
        mapping_explanation = {
            1: 'UO is rising, suggesting increasing bullish momentum.',
            -1: 'UO is falling, suggesting increasing bearish momentum.',
            0: 'UO remains unchanged, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'UO_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'UO_TA_Indicator_Value'] = self.uo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'UO_TA_Indicator_Value'] = self.uo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class UlcerIndexStrategies:
    def __init__(self, period=14, lower_threshold=5, upper_threshold=15, ma_period=14):
        self.period = period
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.ma_period = ma_period
        self.ui = None
        self.ui_ma = None

    def compute_values(self, df):
        rolling_max = df['Close'].rolling(window=self.period, min_periods=1).max()
        drawdown = (rolling_max - df['Close']) / rolling_max * 100
        self.ui = drawdown.pow(2).rolling(window=self.period, min_periods=1).mean().apply(np.sqrt)
        return self.ui

    def compute_ui_ma(self, df):
        if self.ui is None:
            self.compute_values(df)
        self.ui_ma = self.ui.rolling(window=self.ma_period, min_periods=1).mean()
        return self.ui_ma

    def calculate_scores_threshold_strategy(self, df):
        if self.ui is None:
            self.compute_values(df)
        cond_bull = self.ui < self.lower_threshold
        cond_bear = self.ui > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Low_Risk', -1: 'High_Risk', 0: 'Moderate_Risk'}
        mapping_explanation = {
            1: f'Ulcer Index is below {self.lower_threshold}, indicating low downside risk and a favorable environment.',
            -1: f'Ulcer Index is above {self.upper_threshold}, indicating high downside risk and an unfavorable environment.',
            0: f'Ulcer Index is between {self.lower_threshold} and {self.upper_threshold}, indicating moderate risk.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'UI_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'UI_Period:{self.period}_TA_Indicator_Value'] = self.ui
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'UI_Period:{self.period}_TA_Indicator_Value'] = self.ui
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.ui is None:
            self.compute_values(df)
        diff = self.ui.diff()
        signals = np.where(diff < 0, 1, np.where(diff > 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'UI_Falling', -1: 'UI_Rising', 0: 'UI_Unchanged'}
        mapping_explanation = {
            1: 'Ulcer Index is falling, indicating a reduction in downside risk and a potentially bullish environment.',
            -1: 'Ulcer Index is rising, indicating increasing downside risk and a potentially bearish environment.',
            0: 'Ulcer Index remains unchanged, indicating stable risk conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'UI_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'UI_Period:{self.period}_TA_Indicator_Value'] = self.ui
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'UI_Period:{self.period}_TA_Indicator_Value'] = self.ui
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_ma_crossover_strategy(self, df):
        if self.ui is None:
            self.compute_values(df)
        if self.ui_ma is None:
            self.compute_ui_ma(df)
        ui_prev = self.ui.shift(1)
        ui_ma_prev = self.ui_ma.shift(1)
        ui_current = self.ui
        ui_ma_current = self.ui_ma
        cond_bull = (ui_prev >= ui_ma_prev) & (ui_current < ui_ma_current)
        cond_bear = (ui_prev <= ui_ma_prev) & (ui_current > ui_ma_current)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def ma_crossover_map(self, series):
        mapping_value = {1: 'UI_Cross_Below_MA', -1: 'UI_Cross_Above_MA', 0: 'UI_MA_Neutral'}
        mapping_explanation = {
            1: 'Ulcer Index crossed below its moving average, suggesting a reduction in risk and a bullish signal.',
            -1: 'Ulcer Index crossed above its moving average, suggesting an increase in risk and a bearish signal.',
            0: 'No significant crossover between Ulcer Index and its moving average.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_ma_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_ma_crossover_strategy(df)
        value, explanation = self.ma_crossover_map(score)
        column_prefix = f'UI_Period:{self.period}_MA_Crossover_Signal'
        if append:
            if ta_indicator_value:
                df[f'UI_Period:{self.period}_TA_Indicator_Value'] = self.ui
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'UI_Period:{self.period}_TA_Indicator_Value'] = self.ui
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_threshold_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_ma_crossover_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class UpDownStrategies:
    def __init__(self, period=14, upper_threshold=50, lower_threshold=-50):
        self.period = period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.updown = None

    def compute_values(self, df):
        up = (df['Close'] > df['Close'].shift(1)).astype(int)
        down = (df['Close'] < df['Close'].shift(1)).astype(int)
        up_count = up.rolling(window=self.period, min_periods=1).sum()
        down_count = down.rolling(window=self.period, min_periods=1).sum()
        self.updown = ((up_count - down_count) / self.period) * 100
        return self.updown

    def calculate_scores_zero_cross_strategy(self, df):
        if self.updown is None:
            self.compute_values(df)
        updown_prev = self.updown.shift(1)
        updown_current = self.updown
        cond_bull = (updown_prev <= 0) & (updown_current > 0)
        cond_bear = (updown_prev >= 0) & (updown_current < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'UpDown_Cross_Above_Zero', -1: 'UpDown_Cross_Below_Zero', 0: 'UpDown_Neutral'}
        mapping_explanation = {
            1: 'UpDown indicator crossed above zero, indicating a shift towards more up days and bullish sentiment.',
            -1: 'UpDown indicator crossed below zero, indicating a shift towards more down days and bearish sentiment.',
            0: 'UpDown indicator remains around zero, indicating balanced market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'UpDown_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'UpDown_Period:{self.period}_TA_Indicator_Value'] = self.updown
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'UpDown_Period:{self.period}_TA_Indicator_Value'] = self.updown
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.updown is None:
            self.compute_values(df)
        cond_bull = self.updown > self.upper_threshold
        cond_bear = self.updown < self.lower_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'UpDown_Above_Upper_Threshold', -1: 'UpDown_Below_Lower_Threshold', 0: 'UpDown_Neutral'}
        mapping_explanation = {
            1: f'UpDown indicator is above {self.upper_threshold}, indicating strong bullish bias with many more up days.',
            -1: f'UpDown indicator is below {self.lower_threshold}, indicating strong bearish bias with many more down days.',
            0: f'UpDown indicator is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'UpDown_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'UpDown_Period:{self.period}_TA_Indicator_Value'] = self.updown
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'UpDown_Period:{self.period}_TA_Indicator_Value'] = self.updown
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.updown is None:
            self.compute_values(df)
        diff = self.updown.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'UpDown_Rising', -1: 'UpDown_Falling', 0: 'UpDown_Unchanged'}
        mapping_explanation = {
            1: 'UpDown indicator is rising, suggesting an increasing number of up days and improving bullish momentum.',
            -1: 'UpDown indicator is falling, suggesting an increasing number of down days and growing bearish momentum.',
            0: 'UpDown indicator is unchanged, indicating no significant change in market bias.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'UpDown_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'UpDown_Period:{self.period}_TA_Indicator_Value'] = self.updown
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'UpDown_Period:{self.period}_TA_Indicator_Value'] = self.updown
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class VariableIndexDynamicAverageStrategies:
    def __init__(self, period=14, k=0.2, threshold_percentage=0.01):
        self.period = period
        self.k = k
        self.threshold_percentage = threshold_percentage
        self.vidya = None

    def compute_values(self, df):
        close = df['Close']
        delta = (close - close.shift(1)).abs()
        avg_delta = delta.rolling(window=self.period, min_periods=1).mean()
        alpha = pd.Series(np.where(avg_delta == 0, 0, self.k * (delta / avg_delta)), index=df.index)
        vidya = pd.Series(index=df.index, dtype=float)
        vidya.iloc[0] = close.iloc[0]
        for i in range(1, len(df)):
            vidya.iloc[i] = alpha.iloc[i] * close.iloc[i] + (1 - alpha.iloc[i]) * vidya.iloc[i-1]
        self.vidya = vidya
        return self.vidya

    def calculate_scores_price_crossover_strategy(self, df):
        if self.vidya is None:
            self.compute_values(df)
        close_prev = df['Close'].shift(1)
        vidya_prev = self.vidya.shift(1)
        close_current = df['Close']
        vidya_current = self.vidya
        cond_bull = (close_prev <= vidya_prev) & (close_current > vidya_current)
        cond_bear = (close_prev >= vidya_prev) & (close_current < vidya_current)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def price_crossover_map(self, series):
        mapping_value = {1: 'Price_Above_VIDYA', -1: 'Price_Below_VIDYA', 0: 'Price_Neutral'}
        mapping_explanation = {
            1: 'The closing price crossed above the Variable Index Dynamic Average, indicating bullish momentum.',
            -1: 'The closing price crossed below the Variable Index Dynamic Average, indicating bearish momentum.',
            0: 'No significant crossover between the closing price and the VIDYA was detected.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_crossover_strategy(df)
        value, explanation = self.price_crossover_map(score)
        column_prefix = 'VIDYA_PriceCrossover_Signal'
        if append:
            if ta_indicator_value:
                df['VIDYA_TA_Indicator_Value'] = self.vidya
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['VIDYA_TA_Indicator_Value'] = self.vidya
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.vidya is None:
            self.compute_values(df)
        diff = self.vidya.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'VIDYA_Rising', -1: 'VIDYA_Falling', 0: 'VIDYA_Unchanged'}
        mapping_explanation = {
            1: 'VIDYA is rising, suggesting increasing bullish momentum.',
            -1: 'VIDYA is falling, suggesting increasing bearish momentum.',
            0: 'VIDYA remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'VIDYA_Slope_Signal'
        if append:
            if ta_indicator_value:
                df['VIDYA_TA_Indicator_Value'] = self.vidya
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['VIDYA_TA_Indicator_Value'] = self.vidya
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.vidya is None:
            self.compute_values(df)
        diff_ratio = (df['Close'] - self.vidya) / self.vidya
        cond_bull = diff_ratio > self.threshold_percentage
        cond_bear = diff_ratio < -self.threshold_percentage
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Price_Significantly_Above_VIDYA', -1: 'Price_Significantly_Below_VIDYA', 0: 'Price_Near_VIDYA'}
        mapping_explanation = {
            1: f'The closing price is more than {self.threshold_percentage * 100}% above VIDYA, indicating strong bullish conditions.',
            -1: f'The closing price is more than {self.threshold_percentage * 100}% below VIDYA, indicating strong bearish conditions.',
            0: f'The closing price is within {self.threshold_percentage * 100}% of VIDYA, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = 'VIDYA_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df['VIDYA_TA_Indicator_Value'] = self.vidya
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['VIDYA_TA_Indicator_Value'] = self.vidya
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_crossover_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class VarianceStrategies:
    def __init__(self, period=14, lower_threshold=1.0, upper_threshold=5.0):
        self.period = period
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.variance = None
        self.variance_ma = None

    def compute_values(self, df):
        self.variance = df['Close'].rolling(window=self.period, min_periods=1).var()
        return self.variance

    def compute_ma(self, df):
        if self.variance is None:
            self.compute_values(df)
        self.variance_ma = self.variance.rolling(window=self.period, min_periods=1).mean()
        return self.variance_ma

    def calculate_scores_crossover_strategy(self, df):
        if self.variance is None:
            self.compute_values(df)
        if self.variance_ma is None:
            self.compute_ma(df)
        diff = self.variance - self.variance_ma
        diff_prev = diff.shift(1)
        diff_current = diff
        cond_bull = (diff_prev >= 0) & (diff_current < 0)
        cond_bear = (diff_prev <= 0) & (diff_current > 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def crossover_map(self, series):
        mapping_value = {1: 'Variance_Below_MA', -1: 'Variance_Above_MA', 0: 'Variance_Neutral'}
        mapping_explanation = {
            1: 'Variance has fallen below its moving average, indicating a contraction in volatility (a bullish signal).',
            -1: 'Variance has risen above its moving average, indicating an expansion in volatility (a bearish signal).',
            0: 'No significant crossover between Variance and its moving average.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_crossover_strategy(df)
        value, explanation = self.crossover_map(score)
        column_prefix = f'Variance_Period:{self.period}_Crossover_Signal'
        if append:
            if ta_indicator_value:
                df[f'Variance_Period:{self.period}_TA_Indicator_Value'] = self.variance
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Variance_Period:{self.period}_TA_Indicator_Value'] = self.variance
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.variance is None:
            self.compute_values(df)
        cond_bull = self.variance < self.lower_threshold
        cond_bear = self.variance > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Low_Variance', -1: 'High_Variance', 0: 'Moderate_Variance'}
        mapping_explanation = {
            1: f'Variance is below {self.lower_threshold}, indicating a low volatility environment that is typically bullish.',
            -1: f'Variance is above {self.upper_threshold}, indicating high volatility and increased risk (a bearish signal).',
            0: f'Variance is between {self.lower_threshold} and {self.upper_threshold}, suggesting moderate volatility.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'Variance_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'Variance_Period:{self.period}_TA_Indicator_Value'] = self.variance
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Variance_Period:{self.period}_TA_Indicator_Value'] = self.variance
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.variance is None:
            self.compute_values(df)
        diff = self.variance.diff()
        signals = np.where(diff < 0, 1, np.where(diff > 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Variance_Decreasing', -1: 'Variance_Increasing', 0: 'Variance_Unchanged'}
        mapping_explanation = {
            1: 'Variance is decreasing, indicating a reduction in volatility (a bullish signal).',
            -1: 'Variance is increasing, indicating rising volatility and potential risk (a bearish signal).',
            0: 'Variance remains unchanged, indicating stable volatility conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'Variance_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'Variance_Period:{self.period}_TA_Indicator_Value'] = self.variance
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'Variance_Period:{self.period}_TA_Indicator_Value'] = self.variance
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_crossover_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class VerticalHorizontalFilterStrategies:
    def __init__(self, period=14, trending_threshold=0.6, range_threshold=0.4, ma_period=5):
        self.period = period
        self.trending_threshold = trending_threshold
        self.range_threshold = range_threshold
        self.ma_period = ma_period
        self.vhf = None

    def compute_values(self, df):
        highest = df['High'].rolling(window=self.period, min_periods=1).max()
        lowest = df['Low'].rolling(window=self.period, min_periods=1).min()
        numerator = highest - lowest
        denominator = df['Close'].diff().abs().rolling(window=self.period, min_periods=1).sum()
        self.vhf = pd.Series(np.where(denominator == 0, 0, numerator / denominator), index=df.index)
        return self.vhf

    def calculate_scores_threshold_strategy(self, df):
        if self.vhf is None:
            self.compute_values(df)
        cond_bull = self.vhf > self.trending_threshold
        cond_bear = self.vhf < self.range_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Trending', -1: 'Ranging', 0: 'Neutral'}
        mapping_explanation = {
            1: f'VHF is above {self.trending_threshold}, indicating strong trending conditions favorable for directional moves.',
            -1: f'VHF is below {self.range_threshold}, indicating a ranging market where trends are weak.',
            0: f'VHF is between {self.range_threshold} and {self.trending_threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'VHF_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'VHF_Period:{self.period}_TA_Indicator_Value'] = self.vhf
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VHF_Period:{self.period}_TA_Indicator_Value'] = self.vhf
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.vhf is None:
            self.compute_values(df)
        diff = self.vhf.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'VHF_Rising', -1: 'VHF_Falling', 0: 'VHF_Unchanged'}
        mapping_explanation = {
            1: 'VHF is rising, indicating increasing trendiness in the market.',
            -1: 'VHF is falling, suggesting that the market is becoming more range-bound.',
            0: 'VHF remains unchanged, indicating stable market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'VHF_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'VHF_Period:{self.period}_TA_Indicator_Value'] = self.vhf
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VHF_Period:{self.period}_TA_Indicator_Value'] = self.vhf
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_ma_crossover_strategy(self, df):
        if self.vhf is None:
            self.compute_values(df)
        ma_vhf = self.vhf.rolling(window=self.ma_period, min_periods=1).mean()
        vhf_prev = self.vhf.shift(1)
        ma_prev = ma_vhf.shift(1)
        cond_bull = (vhf_prev < ma_prev) & (self.vhf >= ma_vhf)
        cond_bear = (vhf_prev > ma_prev) & (self.vhf <= ma_vhf)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def ma_crossover_map(self, series):
        mapping_value = {1: 'VHF_Crossed_Above_MA', -1: 'VHF_Crossed_Below_MA', 0: 'VHF_MA_Neutral'}
        mapping_explanation = {
            1: 'VHF crossed above its moving average, indicating emerging trendiness.',
            -1: 'VHF crossed below its moving average, suggesting a loss of trend strength.',
            0: 'No significant crossover between VHF and its moving average.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_ma_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_ma_crossover_strategy(df)
        value, explanation = self.ma_crossover_map(score)
        column_prefix = f'VHF_Period:{self.period}_MA_Crossover_Signal'
        if append:
            if ta_indicator_value:
                df[f'VHF_Period:{self.period}_TA_Indicator_Value'] = self.vhf
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VHF_Period:{self.period}_TA_Indicator_Value'] = self.vhf
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_threshold_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_ma_crossover_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class VolumeAdjustedMovingAverageStrategies:
    def __init__(self, period=14, threshold_percentage=0.01):
        self.period = period
        self.threshold_percentage = threshold_percentage
        self.vama = None

    def compute_values(self, df):
        self.vama = (df['Close'] * df['Volume']).rolling(window=self.period, min_periods=1).sum() / df['Volume'].rolling(window=self.period, min_periods=1).sum()
        return self.vama

    def calculate_scores_price_crossover_strategy(self, df):
        if self.vama is None:
            self.compute_values(df)
        close_prev = df['Close'].shift(1)
        vama_prev = self.vama.shift(1)
        close_current = df['Close']
        vama_current = self.vama
        cond_bull = (close_prev <= vama_prev) & (close_current > vama_current)
        cond_bear = (close_prev >= vama_prev) & (close_current < vama_current)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def price_crossover_map(self, series):
        mapping_value = {1: 'Price_Above_VAMA', -1: 'Price_Below_VAMA', 0: 'Price_Neutral'}
        mapping_explanation = {
            1: 'The closing price crossed above the Volume Adjusted Moving Average, indicating bullish momentum.',
            -1: 'The closing price crossed below the Volume Adjusted Moving Average, indicating bearish momentum.',
            0: 'No significant crossover between the closing price and the VAMA was detected.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_crossover_strategy(df)
        value, explanation = self.price_crossover_map(score)
        column_prefix = 'VAMA_PriceCrossover_Signal'
        if append:
            if ta_indicator_value:
                df['VAMA_TA_Indicator_Value'] = self.vama
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['VAMA_TA_Indicator_Value'] = self.vama
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.vama is None:
            self.compute_values(df)
        diff = self.vama.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'VAMA_Rising', -1: 'VAMA_Falling', 0: 'VAMA_Unchanged'}
        mapping_explanation = {
            1: 'The VAMA is rising, indicating increasing bullish momentum.',
            -1: 'The VAMA is falling, indicating increasing bearish momentum.',
            0: 'The VAMA remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'VAMA_Slope_Signal'
        if append:
            if ta_indicator_value:
                df['VAMA_TA_Indicator_Value'] = self.vama
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['VAMA_TA_Indicator_Value'] = self.vama
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.vama is None:
            self.compute_values(df)
        diff_ratio = (df['Close'] - self.vama) / self.vama
        cond_bull = diff_ratio > self.threshold_percentage
        cond_bear = diff_ratio < -self.threshold_percentage
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Price_Significantly_Above_VAMA', -1: 'Price_Significantly_Below_VAMA', 0: 'Price_Near_VAMA'}
        mapping_explanation = {
            1: f'The closing price is more than {self.threshold_percentage * 100}% above the VAMA, indicating strong bullish conditions.',
            -1: f'The closing price is more than {self.threshold_percentage * 100}% below the VAMA, indicating strong bearish conditions.',
            0: f'The closing price is within {self.threshold_percentage * 100}% of the VAMA, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = 'VAMA_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df['VAMA_TA_Indicator_Value'] = self.vama
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['VAMA_TA_Indicator_Value'] = self.vama
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_crossover_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
  
class VolumeFlowIndicatorStrategies:
    def __init__(self, period=14, lower_threshold=30, upper_threshold=70):
        self.period = period
        self.lower_threshold = lower_threshold
        self.upper_threshold = upper_threshold
        self.vfi = None

    def compute_values(self, df):
        typical_price = (df['High'] + df['Low'] + df['Close']) / 3
        price_range = df['High'] - df['Low']
        mfm = np.where(price_range == 0, 0, ((df['Close'] - df['Low']) - (df['High'] - df['Close'])) / price_range)
        mfv = mfm * df['Volume']
        self.vfi = pd.Series(mfv.rolling(window=self.period, min_periods=1).sum() / 
                             df['Volume'].rolling(window=self.period, min_periods=1).sum() * 100, index=df.index)
        return self.vfi

    def calculate_scores_zero_cross_strategy(self, df):
        if self.vfi is None:
            self.compute_values(df)
        vfi_prev = self.vfi.shift(1)
        vfi_current = self.vfi
        cond_bull = (vfi_prev <= 0) & (vfi_current > 0)
        cond_bear = (vfi_prev >= 0) & (vfi_current < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'VFI_Cross_Above_Zero', -1: 'VFI_Cross_Below_Zero', 0: 'VFI_Neutral'}
        mapping_explanation = {
            1: 'VFI crossed above zero, indicating a shift towards positive volume flow and bullish conditions.',
            -1: 'VFI crossed below zero, indicating a shift towards negative volume flow and bearish conditions.',
            0: 'VFI remains around zero, indicating neutral volume flow.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'VFI_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'VFI_Period:{self.period}_TA_Indicator_Value'] = self.vfi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VFI_Period:{self.period}_TA_Indicator_Value'] = self.vfi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.vfi is None:
            self.compute_values(df)
        cond_bull = self.vfi < self.lower_threshold
        cond_bear = self.vfi > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'VFI_Oversold', -1: 'VFI_Overbought', 0: 'VFI_Neutral'}
        mapping_explanation = {
            1: f'VFI is below {self.lower_threshold}, indicating oversold conditions and potential bullish reversal.',
            -1: f'VFI is above {self.upper_threshold}, indicating overbought conditions and potential bearish reversal.',
            0: f'VFI is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced volume flow.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'VFI_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'VFI_Period:{self.period}_TA_Indicator_Value'] = self.vfi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VFI_Period:{self.period}_TA_Indicator_Value'] = self.vfi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.vfi is None:
            self.compute_values(df)
        diff = self.vfi.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'VFI_Rising', -1: 'VFI_Falling', 0: 'VFI_Unchanged'}
        mapping_explanation = {
            1: 'VFI is rising, indicating increasing positive volume flow and bullish momentum.',
            -1: 'VFI is falling, indicating increasing negative volume flow and bearish momentum.',
            0: 'VFI remains unchanged, indicating stable volume flow.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'VFI_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'VFI_Period:{self.period}_TA_Indicator_Value'] = self.vfi
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VFI_Period:{self.period}_TA_Indicator_Value'] = self.vfi
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class VolumePriceTrendStrategies:
    def __init__(self, ma_period=14, threshold_percentage=0.01):
        self.ma_period = ma_period
        self.threshold_percentage = threshold_percentage
        self.vpt = None

    def compute_values(self, df):
        pct_change = (df['Close'] - df['Close'].shift(1)) / df['Close'].shift(1)
        self.vpt = (df['Volume'] * pct_change).fillna(0).cumsum()
        return self.vpt

    def calculate_scores_slope_strategy(self, df):
        if self.vpt is None:
            self.compute_values(df)
        diff = self.vpt.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'VPT_Rising', -1: 'VPT_Falling', 0: 'VPT_Unchanged'}
        mapping_explanation = {
            1: 'The Volume Price Trend is rising, indicating accumulation and bullish momentum.',
            -1: 'The Volume Price Trend is falling, indicating distribution and bearish momentum.',
            0: 'The Volume Price Trend remains unchanged, indicating neutral market conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'VPT_Slope_Signal'
        if append:
            if ta_indicator_value:
                df['VPT_TA_Indicator_Value'] = self.vpt
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['VPT_TA_Indicator_Value'] = self.vpt
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_ma_crossover_strategy(self, df):
        if self.vpt is None:
            self.compute_values(df)
        ma_vpt = self.vpt.rolling(window=self.ma_period, min_periods=1).mean()
        vpt_prev = self.vpt.shift(1)
        ma_prev = ma_vpt.shift(1)
        cond_bull = (vpt_prev < ma_prev) & (self.vpt >= ma_vpt)
        cond_bear = (vpt_prev > ma_prev) & (self.vpt <= ma_vpt)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def ma_crossover_map(self, series):
        mapping_value = {1: 'VPT_Cross_Above_MA', -1: 'VPT_Cross_Below_MA', 0: 'VPT_MA_Neutral'}
        mapping_explanation = {
            1: f'Volume Price Trend crossed above its {self.ma_period}-period moving average, suggesting bullish confirmation.',
            -1: f'Volume Price Trend crossed below its {self.ma_period}-period moving average, suggesting bearish confirmation.',
            0: f'No significant crossover between Volume Price Trend and its moving average.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_ma_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_ma_crossover_strategy(df)
        value, explanation = self.ma_crossover_map(score)
        column_prefix = f'VPT_MA_Crossover_Signal'
        if append:
            if ta_indicator_value:
                df['VPT_TA_Indicator_Value'] = self.vpt
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['VPT_TA_Indicator_Value'] = self.vpt
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.vpt is None:
            self.compute_values(df)
        pct_change = self.vpt.diff() / self.vpt.shift(1)
        pct_change = pct_change.replace([np.inf, -np.inf], 0).fillna(0)
        cond_bull = pct_change > self.threshold_percentage
        cond_bear = pct_change < -self.threshold_percentage
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'VPT_Significantly_Rising', -1: 'VPT_Significantly_Falling', 0: 'VPT_Near_MA'}
        mapping_explanation = {
            1: f'The percentage change in VPT exceeds {self.threshold_percentage*100}%, indicating strong bullish accumulation.',
            -1: f'The percentage change in VPT is below -{self.threshold_percentage*100}%, indicating strong bearish distribution.',
            0: f'The change in VPT is within {self.threshold_percentage*100}%, indicating moderate movement.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = 'VPT_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df['VPT_TA_Indicator_Value'] = self.vpt
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['VPT_TA_Indicator_Value'] = self.vpt
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_slope_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_ma_crossover_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  
class VolumeProfileStrategies:
    def __init__(self, period=14, bin_size=1, value_area_percentage=0.7):
        self.period = period
        self.bin_size = bin_size
        self.value_area_percentage = value_area_percentage
        self.volume_profile = None
        self.total_volume = None
        self.poc = None
        self.value_area_low = None
        self.value_area_high = None
        self.rolling_poc = None

    def compute_values(self, df):
        bins = np.floor(df['Close'] / self.bin_size) * self.bin_size
        df_bins = pd.DataFrame({'PriceBin': bins, 'Volume': df['Volume']})
        volume_profile = df_bins.groupby('PriceBin')['Volume'].sum()
        self.volume_profile = volume_profile.sort_index()
        self.total_volume = self.volume_profile.sum()
        self.poc = self.volume_profile.idxmax()
        price_bins = self.volume_profile.index.to_list()
        poc_index = price_bins.index(self.poc)
        left = poc_index
        right = poc_index
        value_area_volume = self.volume_profile.iloc[poc_index]
        target_volume = self.total_volume * self.value_area_percentage
        while value_area_volume < target_volume:
            left_candidate = price_bins[left-1] if left > 0 else None
            right_candidate = price_bins[right+1] if right < len(price_bins)-1 else None
            if left_candidate is None and right_candidate is None:
                break
            if left_candidate is not None and right_candidate is not None:
                if self.volume_profile[left_candidate] >= self.volume_profile[right_candidate]:
                    left -= 1
                    value_area_volume += self.volume_profile[left_candidate]
                else:
                    right += 1
                    value_area_volume += self.volume_profile[right_candidate]
            elif left_candidate is not None:
                left -= 1
                value_area_volume += self.volume_profile[left_candidate]
            elif right_candidate is not None:
                right += 1
                value_area_volume += self.volume_profile[right_candidate]
        self.value_area_low = price_bins[left]
        self.value_area_high = price_bins[right]
        return self.volume_profile

    def calculate_scores_poc_breakout_strategy(self, df):
        if self.volume_profile is None:
            self.compute_values(df)
        score = np.where(df['Close'] > self.poc, 1, np.where(df['Close'] < self.poc, -1, 0))
        return pd.Series(score, index=df.index)

    def poc_breakout_map(self, series):
        mapping_value = {1: 'Close_Above_POC', -1: 'Close_Below_POC', 0: 'Close_At_POC'}
        mapping_explanation = {
            1: f'The current closing price is above the POC ({self.poc}), indicating bullish breakout conditions.',
            -1: f'The current closing price is below the POC ({self.poc}), indicating bearish breakout conditions.',
            0: f'The current closing price is at the POC ({self.poc}), indicating neutral breakout conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_poc_breakout_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_poc_breakout_strategy(df)
        value, explanation = self.poc_breakout_map(score)
        column_prefix = f'VP_Period:{self.period}_POC_Breakout_Signal'
        if append:
            if ta_indicator_value:
                df[f'VP_Indicator_POC'] = self.poc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VP_Indicator_POC'] = self.poc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_value_area_strategy(self, df):
        if self.volume_profile is None:
            self.compute_values(df)
        score = np.where(df['Close'] > self.value_area_high, -1, np.where(df['Close'] < self.value_area_low, 1, 0))
        return pd.Series(score, index=df.index)

    def value_area_map(self, series):
        mapping_value = {1: 'Below_Value_Area', -1: 'Above_Value_Area', 0: 'Within_Value_Area'}
        mapping_explanation = {
            1: f'The current closing price is below the value area (low boundary: {self.value_area_low}), indicating potential bullish reversal.',
            -1: f'The current closing price is above the value area (high boundary: {self.value_area_high}), indicating potential bearish reversal.',
            0: f'The current closing price is within the value area (between {self.value_area_low} and {self.value_area_high}), indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_value_area_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_value_area_strategy(df)
        value, explanation = self.value_area_map(score)
        column_prefix = f'VP_Period:{self.period}_ValueArea_Rejection_Signal'
        if append:
            if ta_indicator_value:
                df[f'VP_Indicator_ValueArea_Low'] = self.value_area_low
                df[f'VP_Indicator_ValueArea_High'] = self.value_area_high
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VP_Indicator_ValueArea_Low'] = self.value_area_low
            df_copy[f'VP_Indicator_ValueArea_High'] = self.value_area_high
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def compute_rolling_poc(self, df):
        rolling_poc = []
        indices = df.index
        for i in range(len(df)):
            if i < self.period - 1:
                rolling_poc.append(np.nan)
            else:
                window_df = df.iloc[i - self.period + 1:i + 1]
                bins = np.floor(window_df['Close'] / self.bin_size) * self.bin_size
                window_df_bins = pd.DataFrame({'PriceBin': bins, 'Volume': window_df['Volume']})
                volume_profile = window_df_bins.groupby('PriceBin')['Volume'].sum()
                volume_profile = volume_profile.sort_index()
                poc_value = volume_profile.idxmax()
                rolling_poc.append(poc_value)
        self.rolling_poc = pd.Series(rolling_poc, index=indices)
        return self.rolling_poc

    def calculate_scores_cluster_shift_strategy(self, df):
        if self.rolling_poc is None:
            self.compute_rolling_poc(df)
        poc_diff = self.rolling_poc.diff()
        score = np.where(poc_diff > 0, 1, np.where(poc_diff < 0, -1, 0))
        return pd.Series(score, index=df.index)

    def cluster_shift_map(self, series):
        mapping_value = {1: 'POC_Shift_Up', -1: 'POC_Shift_Down', 0: 'POC_Stable'}
        mapping_explanation = {
            1: 'The rolling POC is shifting upward, indicating volume is clustering at higher price levels (bullish signal).',
            -1: 'The rolling POC is shifting downward, indicating volume is clustering at lower price levels (bearish signal).',
            0: 'The rolling POC remains stable, indicating no significant shift in volume clustering.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_cluster_shift_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_cluster_shift_strategy(df)
        value, explanation = self.cluster_shift_map(score)
        column_prefix = f'VP_Period:{self.period}_ClusterShift_Signal'
        if append:
            if ta_indicator_value:
                self.compute_rolling_poc(df)
                df[f'VP_Rolling_POC'] = self.rolling_poc
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VP_Rolling_POC'] = self.rolling_poc
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_poc_breakout_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_value_area_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_cluster_shift_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)

  


  
  
class VolumeWeightedAveragePriceStrategies:
    def __init__(self, threshold=0.01):
        self.threshold = threshold
        self.vwap = None

    def compute_values(self, df):
        typical_price = (df['High'] + df['Low'] + df['Close']) / 3
        cum_pv = (typical_price * df['Volume']).cumsum()
        cum_vol = df['Volume'].cumsum().replace(0, 1)
        vwap = cum_pv / cum_vol
        self.vwap = vwap
        return vwap

    def calculate_scores_zero_cross_strategy(self, df):
        if self.vwap is None:
            self.compute_values(df)
        price = df['Close']
        price_prev = price.shift(1)
        vwap_prev = self.vwap.shift(1)
        cond_bull = (price_prev <= vwap_prev) & (price > self.vwap)
        cond_bear = (price_prev >= vwap_prev) & (price < self.vwap)
        signals = np.where(cond_bull, 1, np.where(cond_bear, -1, 0))
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Price_Above_VWAP', -1: 'Price_Below_VWAP', 0: 'Neutral'}
        mapping_explanation = {
            1: 'Price crossed above VWAP indicating potential bullish trend.',
            -1: 'Price crossed below VWAP indicating potential bearish trend.',
            0: 'No clear crossover signal between price and VWAP.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = 'VWAP_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df['VWAP_TA_Indicator_Value'] = self.vwap
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['VWAP_TA_Indicator_Value'] = self.vwap
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.vwap is None:
            self.compute_values(df)
        price = df['Close']
        pct_diff = (price - self.vwap) / self.vwap
        cond_bull = pct_diff <= -self.threshold
        cond_bear = pct_diff >= self.threshold
        signals = np.where(cond_bull, 1, np.where(cond_bear, -1, 0))
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Price_Significantly_Below_VWAP', -1: 'Price_Significantly_Above_VWAP', 0: 'Price_Near_VWAP'}
        mapping_explanation = {
            1: f'Price is below VWAP by at least {self.threshold*100:.1f}%, suggesting oversold conditions and potential bullish reversal.',
            -1: f'Price is above VWAP by at least {self.threshold*100:.1f}%, suggesting overbought conditions and potential bearish reversal.',
            0: 'Price is within the threshold range of VWAP, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = 'VWAP_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df['VWAP_TA_Indicator_Value'] = self.vwap
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['VWAP_TA_Indicator_Value'] = self.vwap
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.vwap is None:
            self.compute_values(df)
        diff = self.vwap.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'VWAP_Rising', -1: 'VWAP_Falling', 0: 'VWAP_Unchanged'}
        mapping_explanation = {
            1: 'VWAP is rising, indicating bullish momentum.',
            -1: 'VWAP is falling, indicating bearish momentum.',
            0: 'VWAP is unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'VWAP_Slope_Signal'
        if append:
            if ta_indicator_value:
                df['VWAP_TA_Indicator_Value'] = self.vwap
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['VWAP_TA_Indicator_Value'] = self.vwap
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class VolumeWeightedMovingAverageStrategies:
    def __init__(self, period=20, threshold=0.01):
        self.period = period
        self.threshold = threshold
        self.vwma = None

    def compute_values(self, df):
        vwma = (df['Close'] * df['Volume']).rolling(window=self.period, min_periods=1).sum() / df['Volume'].rolling(window=self.period, min_periods=1).sum().replace(0, 1)
        self.vwma = vwma
        return vwma

    def calculate_scores_zero_cross_strategy(self, df):
        if self.vwma is None:
            self.compute_values(df)
        price = df['Close']
        price_prev = price.shift(1)
        vwma_prev = self.vwma.shift(1)
        cond_bull = (price_prev <= vwma_prev) & (price > self.vwma)
        cond_bear = (price_prev >= vwma_prev) & (price < self.vwma)
        signals = np.where(cond_bull, 1, np.where(cond_bear, -1, 0))
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'Price_Above_VWMA', -1: 'Price_Below_VWMA', 0: 'VWMA_Neutral'}
        mapping_explanation = {
            1: 'Closing price crossed above VWMA indicating bullish momentum.',
            -1: 'Closing price crossed below VWMA indicating bearish momentum.',
            0: 'No crossover signal between closing price and VWMA.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'VWMA_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'VWMA_Period:{self.period}_TA_Indicator_Value'] = self.vwma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VWMA_Period:{self.period}_TA_Indicator_Value'] = self.vwma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.vwma is None:
            self.compute_values(df)
        price = df['Close']
        pct_diff = (price - self.vwma) / self.vwma
        cond_bull = pct_diff <= -self.threshold
        cond_bear = pct_diff >= self.threshold
        signals = np.where(cond_bull, 1, np.where(cond_bear, -1, 0))
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Price_Significantly_Below_VWMA', -1: 'Price_Significantly_Above_VWMA', 0: 'Price_Near_VWMA'}
        mapping_explanation = {
            1: f'Price is below VWMA by at least {self.threshold*100:.1f}%, suggesting potential bullish reversal.',
            -1: f'Price is above VWMA by at least {self.threshold*100:.1f}%, suggesting potential bearish reversal.',
            0: 'Price is within the threshold range of VWMA, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'VWMA_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'VWMA_Period:{self.period}_TA_Indicator_Value'] = self.vwma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VWMA_Period:{self.period}_TA_Indicator_Value'] = self.vwma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.vwma is None:
            self.compute_values(df)
        diff = self.vwma.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'VWMA_Rising', -1: 'VWMA_Falling', 0: 'VWMA_Unchanged'}
        mapping_explanation = {
            1: 'VWMA is rising, indicating bullish momentum.',
            -1: 'VWMA is falling, indicating bearish momentum.',
            0: 'VWMA remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'VWMA_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'VWMA_Period:{self.period}_TA_Indicator_Value'] = self.vwma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VWMA_Period:{self.period}_TA_Indicator_Value'] = self.vwma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


class VolumeZoneOscillatorStrategies:
    def __init__(self, period=14, upper_threshold=30, lower_threshold=-30, baseline=0):
        self.period = period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.baseline = baseline
        self.vzo = None

    def compute_values(self, df):
        delta = df['Close'].diff()
        up_volume = np.where(delta > 0, df['Volume'], 0)
        down_volume = np.where(delta < 0, df['Volume'], 0)
        rolling_up = pd.Series(up_volume).rolling(window=self.period, min_periods=1).sum()
        rolling_down = pd.Series(down_volume).rolling(window=self.period, min_periods=1).sum()
        denominator = rolling_up + rolling_down
        vzo = 100 * (rolling_up - rolling_down) / np.where(denominator == 0, np.nan, denominator)
        self.vzo = pd.Series(vzo, index=df.index).fillna(0)
        return self.vzo

    def calculate_scores_zero_cross_strategy(self, df):
        if self.vzo is None:
            self.compute_values(df)
        vzo_prev = self.vzo.shift(1)
        cond_bull = (vzo_prev <= self.baseline) & (self.vzo > self.baseline)
        cond_bear = (vzo_prev >= self.baseline) & (self.vzo < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'VZO_Crossed_Above_0', -1: 'VZO_Crossed_Below_0', 0: 'VZO_Neutral'}
        mapping_explanation = {
            1: 'VZO crossed above 0, indicating a shift to dominant buying volume (bullish signal).',
            -1: 'VZO crossed below 0, indicating a shift to dominant selling volume (bearish signal).',
            0: 'VZO remains around 0, indicating balanced volume between up and down days (neutral signal).'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'VZO_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'VZO_Period:{self.period}_TA_Indicator_Value'] = self.vzo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VZO_Period:{self.period}_TA_Indicator_Value'] = self.vzo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.vzo is None:
            self.compute_values(df)
        signals = np.select([self.vzo > self.upper_threshold, self.vzo < self.lower_threshold], [1, -1], default=0)
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'VZO_Above_Upper_Threshold', -1: 'VZO_Below_Lower_Threshold', 0: 'VZO_Neutral'}
        mapping_explanation = {
            1: f'VZO is above the upper threshold of {self.upper_threshold}, indicating strong buying volume (bullish signal).',
            -1: f'VZO is below the lower threshold of {self.lower_threshold}, indicating strong selling volume (bearish signal).',
            0: f'VZO is between {self.lower_threshold} and {self.upper_threshold}, indicating balanced volume (neutral signal).'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'VZO_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'VZO_Period:{self.period}_TA_Indicator_Value'] = self.vzo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VZO_Period:{self.period}_TA_Indicator_Value'] = self.vzo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.vzo is None:
            self.compute_values(df)
        diff = self.vzo.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'VZO_Rising', -1: 'VZO_Falling', 0: 'VZO_Stable'}
        mapping_explanation = {
            1: 'VZO is rising, indicating increasing dominance of buying volume (bullish signal).',
            -1: 'VZO is falling, indicating increasing dominance of selling volume (bearish signal).',
            0: 'VZO is stable, indicating no significant change in volume dynamics (neutral signal).'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'VZO_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'VZO_Period:{self.period}_TA_Indicator_Value'] = self.vzo
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VZO_Period:{self.period}_TA_Indicator_Value'] = self.vzo
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class VolumeWeightedMACDStrategies:
    def __init__(self, fast_period=12, slow_period=26, signal_period=9, threshold=0):
        self.fast_period = fast_period
        self.slow_period = slow_period
        self.signal_period = signal_period
        self.threshold = threshold
        self.macd_line = None
        self.signal_line = None

    def compute_values(self, df):
        fast_vwma = (df['Close'] * df['Volume']).rolling(window=self.fast_period, min_periods=1).sum() / df['Volume'].rolling(window=self.fast_period, min_periods=1).sum().replace(0, 1)
        slow_vwma = (df['Close'] * df['Volume']).rolling(window=self.slow_period, min_periods=1).sum() / df['Volume'].rolling(window=self.slow_period, min_periods=1).sum().replace(0, 1)
        self.macd_line = fast_vwma - slow_vwma
        self.signal_line = self.macd_line.rolling(window=self.signal_period, min_periods=1).mean()
        return self.macd_line, self.signal_line

    def calculate_scores_zero_cross_strategy(self, df):
        if self.macd_line is None or self.signal_line is None:
            self.compute_values(df)
        macd_prev = self.macd_line.shift(1)
        signal_prev = self.signal_line.shift(1)
        cond_bull = (macd_prev <= signal_prev) & (self.macd_line > self.signal_line)
        cond_bear = (macd_prev >= signal_prev) & (self.macd_line < self.signal_line)
        signals = np.where(cond_bull, 1, np.where(cond_bear, -1, 0))
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'MACD_Above_Signal', -1: 'MACD_Below_Signal', 0: 'MACD_Neutral'}
        mapping_explanation = {
            1: 'MACD line crossed above the signal line, indicating bullish momentum.',
            -1: 'MACD line crossed below the signal line, indicating bearish momentum.',
            0: 'No significant crossover between MACD and signal line.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'VW_MACD_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'VW_MACD_TA_Indicator_Value'] = self.macd_line
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VW_MACD_TA_Indicator_Value'] = self.macd_line
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.macd_line is None:
            self.compute_values(df)
        cond_bull = self.macd_line > self.threshold
        cond_bear = self.macd_line < self.threshold
        signals = np.where(cond_bull, 1, np.where(cond_bear, -1, 0))
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'MACD_Above_Threshold', -1: 'MACD_Below_Threshold', 0: 'MACD_Neutral'}
        mapping_explanation = {
            1: f'MACD line is above the threshold of {self.threshold}, indicating bullish momentum.',
            -1: f'MACD line is below the threshold of {self.threshold}, indicating bearish momentum.',
            0: 'MACD is neutral relative to the threshold.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'VW_MACD_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'VW_MACD_TA_Indicator_Value'] = self.macd_line
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VW_MACD_TA_Indicator_Value'] = self.macd_line
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.macd_line is None:
            self.compute_values(df)
        diff = self.macd_line.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'MACD_Rising', -1: 'MACD_Falling', 0: 'MACD_Unchanged'}
        mapping_explanation = {
            1: 'MACD line is rising, suggesting strengthening bullish momentum.',
            -1: 'MACD line is falling, suggesting strengthening bearish momentum.',
            0: 'MACD line remains unchanged, indicating no clear momentum shift.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'VW_MACD_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'VW_MACD_TA_Indicator_Value'] = self.macd_line
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VW_MACD_TA_Indicator_Value'] = self.macd_line
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class VortexIndicatorStrategies:
    def __init__(self, period=14, threshold=1):
        self.period = period
        self.threshold = threshold
        self.vi_plus = None
        self.vi_minus = None

    def compute_values(self, df):
        tr1 = df['High'] - df['Low']
        tr2 = (df['High'] - df['Close'].shift(1)).abs()
        tr3 = (df['Low'] - df['Close'].shift(1)).abs()
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
        vi_plus = (abs(df['High'] - df['Low'].shift(1))).rolling(window=self.period, min_periods=1).sum() / tr.rolling(window=self.period, min_periods=1).sum().replace(0, 1)
        vi_minus = (abs(df['Low'] - df['High'].shift(1))).rolling(window=self.period, min_periods=1).sum() / tr.rolling(window=self.period, min_periods=1).sum().replace(0, 1)
        self.vi_plus = vi_plus
        self.vi_minus = vi_minus
        return vi_plus, vi_minus

    def calculate_scores_zero_cross_strategy(self, df):
        if self.vi_plus is None or self.vi_minus is None:
            self.compute_values(df)
        vi_plus_prev = self.vi_plus.shift(1)
        vi_minus_prev = self.vi_minus.shift(1)
        cond_bull = (vi_plus_prev <= vi_minus_prev) & (self.vi_plus > self.vi_minus)
        cond_bear = (vi_plus_prev >= vi_minus_prev) & (self.vi_plus < self.vi_minus)
        signals = np.where(cond_bull, 1, np.where(cond_bear, -1, 0))
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'VI+_Crossed_Above_VI-', -1: 'VI+_Crossed_Below_VI-', 0: 'VI_Neutral'}
        mapping_explanation = {
            1: 'VI+ crossed above VI-, indicating a bullish trend reversal.',
            -1: 'VI+ crossed below VI-, indicating a bearish trend reversal.',
            0: 'No significant crossover between VI+ and VI-.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'VI_Period:{self.period}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'VI_Period:{self.period}_TA_Indicator_Value'] = self.vi_plus
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VI_Period:{self.period}_TA_Indicator_Value'] = self.vi_plus
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.vi_plus is None or self.vi_minus is None:
            self.compute_values(df)
        cond_bull = (self.vi_plus > self.threshold) & (self.vi_plus > self.vi_minus)
        cond_bear = (self.vi_minus > self.threshold) & (self.vi_minus > self.vi_plus)
        signals = np.where(cond_bull, 1, np.where(cond_bear, -1, 0))
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'VI+_Above_Threshold', -1: 'VI-_Above_Threshold', 0: 'VI_Neutral'}
        mapping_explanation = {
            1: f'VI+ is above the threshold of {self.threshold} and higher than VI-, indicating bullish trend.',
            -1: f'VI- is above the threshold of {self.threshold} and higher than VI+, indicating bearish trend.',
            0: 'Both VI+ and VI- are below the threshold, indicating a weak trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'VI_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'VI_Period:{self.period}_TA_Indicator_Value'] = self.vi_plus
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VI_Period:{self.period}_TA_Indicator_Value'] = self.vi_plus
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.vi_plus is None or self.vi_minus is None:
            self.compute_values(df)
        diff = (self.vi_plus - self.vi_minus).diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Increasing_VI_Gap', -1: 'Decreasing_VI_Gap', 0: 'Stable_VI_Gap'}
        mapping_explanation = {
            1: 'The gap between VI+ and VI- is increasing, suggesting strengthening bullish momentum.',
            -1: 'The gap between VI+ and VI- is decreasing, suggesting strengthening bearish momentum.',
            0: 'No significant change in the gap between VI+ and VI-, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'VI_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'VI_Period:{self.period}_TA_Indicator_Value'] = self.vi_plus
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'VI_Period:{self.period}_TA_Indicator_Value'] = self.vi_plus
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class WaveTrendOscillatorStrategies:
    def __init__(self, period1=10, period2=21, signal_period=4, upper_threshold=60, lower_threshold=-60):
        self.period1 = period1
        self.period2 = period2
        self.signal_period = signal_period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.wt1 = None
        self.wt2 = None

    def compute_values(self, df):
        tp = (df['High'] + df['Low'] + df['Close']) / 3
        esa = tp.ewm(span=self.period1, adjust=False).mean()
        d = abs(tp - esa).ewm(span=self.period1, adjust=False).mean()
        ci = (tp - esa) / (0.015 * d.replace(0, 1))
        wt1 = ci.ewm(span=self.period2, adjust=False).mean()
        wt2 = wt1.rolling(window=self.signal_period, min_periods=1).mean()
        self.wt1 = wt1
        self.wt2 = wt2
        return wt1, wt2

    def calculate_scores_zero_cross_strategy(self, df):
        if self.wt1 is None or self.wt2 is None:
            self.compute_values(df)
        wt1_prev = self.wt1.shift(1)
        wt2_prev = self.wt2.shift(1)
        cond_bull = (wt1_prev <= wt2_prev) & (self.wt1 > self.wt2)
        cond_bear = (wt1_prev >= wt2_prev) & (self.wt1 < self.wt2)
        signals = np.where(cond_bull, 1, np.where(cond_bear, -1, 0))
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'WT1_Crossed_Above_Signal', -1: 'WT1_Crossed_Below_Signal', 0: 'WT_Neutral'}
        mapping_explanation = {
            1: 'WT1 crossed above WT2, indicating a potential bullish reversal.',
            -1: 'WT1 crossed below WT2, indicating a potential bearish reversal.',
            0: 'No significant crossover between WT1 and WT2.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = f'WT_Period1:{self.period1}_Period2:{self.period2}_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df[f'WT_Period1:{self.period1}_TA_Indicator_Value'] = self.wt1
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'WT_Period1:{self.period1}_TA_Indicator_Value'] = self.wt1
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.wt1 is None:
            self.compute_values(df)
        cond_bull = self.wt1 < self.lower_threshold
        cond_bear = self.wt1 > self.upper_threshold
        signals = np.where(cond_bull, 1, np.where(cond_bear, -1, 0))
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'WT_Below_Lower_Threshold', -1: 'WT_Above_Upper_Threshold', 0: 'WT_Neutral'}
        mapping_explanation = {
            1: f'WT1 is below the lower threshold of {self.lower_threshold}, suggesting oversold conditions and potential bullish reversal.',
            -1: f'WT1 is above the upper threshold of {self.upper_threshold}, suggesting overbought conditions and potential bearish reversal.',
            0: 'WT1 is within the normal range, indicating balanced conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'WT_Period1:{self.period1}_Period2:{self.period2}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'WT_Period1:{self.period1}_TA_Indicator_Value'] = self.wt1
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'WT_Period1:{self.period1}_TA_Indicator_Value'] = self.wt1
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.wt1 is None:
            self.compute_values(df)
        diff = self.wt1.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'WT1_Rising', -1: 'WT1_Falling', 0: 'WT1_Unchanged'}
        mapping_explanation = {
            1: 'WT1 is rising, indicating increasing bullish momentum.',
            -1: 'WT1 is falling, indicating increasing bearish momentum.',
            0: 'WT1 remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'WT_Period1:{self.period1}_Period2:{self.period2}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'WT_Period1:{self.period1}_TA_Indicator_Value'] = self.wt1
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'WT_Period1:{self.period1}_TA_Indicator_Value'] = self.wt1
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class WeightedClosingPriceStrategies:
    def __init__(self, sma_period=20, threshold=0.01):
        self.sma_period = sma_period
        self.threshold = threshold
        self.wcl = None

    def compute_values(self, df):
        wcl = (df['High'] + df['Low'] + 2 * df['Close']) / 4
        self.wcl = wcl
        return wcl

    def calculate_scores_zero_cross_strategy(self, df):
        if self.wcl is None:
            self.compute_values(df)
        diff = self.wcl - df['Close']
        diff_prev = diff.shift(1)
        cond_bull = (diff_prev <= 0) & (diff > 0)
        cond_bear = (diff_prev >= 0) & (diff < 0)
        signals = np.where(cond_bull, 1, np.where(cond_bear, -1, 0))
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'WCP_Above_Close', -1: 'WCP_Below_Close', 0: 'WCP_Neutral'}
        mapping_explanation = {
            1: 'Weighted Closing Price crossed above the closing price, indicating bullish momentum.',
            -1: 'Weighted Closing Price crossed below the closing price, indicating bearish momentum.',
            0: 'No significant crossover between Weighted Closing Price and closing price.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = 'WCP_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df['WCP_TA_Indicator_Value'] = self.wcl
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['WCP_TA_Indicator_Value'] = self.wcl
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_threshold_strategy(self, df):
        if self.wcl is None:
            self.compute_values(df)
        sma_wcl = self.wcl.rolling(window=self.sma_period, min_periods=1).mean()
        pct_diff = (self.wcl - sma_wcl) / sma_wcl
        cond_bull = pct_diff >= self.threshold
        cond_bear = pct_diff <= -self.threshold
        signals = np.where(cond_bull, 1, np.where(cond_bear, -1, 0))
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'WCP_Above_SMA', -1: 'WCP_Below_SMA', 0: 'WCP_Near_SMA'}
        mapping_explanation = {
            1: f'Weighted Closing Price is above its {self.sma_period}-period SMA by at least {self.threshold*100:.1f}%, indicating bullish conditions.',
            -1: f'Weighted Closing Price is below its {self.sma_period}-period SMA by at least {self.threshold*100:.1f}%, indicating bearish conditions.',
            0: f'Weighted Closing Price is near its {self.sma_period}-period SMA, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'WCP_SMA_Period:{self.sma_period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'WCP_TA_Indicator_Value'] = self.wcl
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'WCP_TA_Indicator_Value'] = self.wcl
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        if self.wcl is None:
            self.compute_values(df)
        diff = self.wcl.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'WCP_Rising', -1: 'WCP_Falling', 0: 'WCP_Unchanged'}
        mapping_explanation = {
            1: 'Weighted Closing Price is rising, indicating bullish momentum.',
            -1: 'Weighted Closing Price is falling, indicating bearish momentum.',
            0: 'Weighted Closing Price remains unchanged, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'WCP_Slope_Signal'
        if append:
            if ta_indicator_value:
                df['WCP_TA_Indicator_Value'] = self.wcl
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['WCP_TA_Indicator_Value'] = self.wcl
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_threshold_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)



class WeightedMovingAverageStrategies:
    def __init__(self, period=14, deviation_threshold=0.01):
        self.period = period
        self.deviation_threshold = deviation_threshold

    def compute_values(self, df):
        w = list(range(1, self.period + 1))
        def weighted_avg(series):
            return sum(series[i] * w[i] for i in range(len(series))) / sum(w)
        return df['Close'].rolling(window=self.period, min_periods=1).apply(weighted_avg, raw=True)

    def calculate_scores_price_crossover_strategy(self, df):
        wma = self.compute_values(df)
        price = df['Close']
        price_prev = price.shift(1)
        wma_prev = wma.shift(1)
        cond_bull = (price_prev <= wma_prev) & (price > wma)
        cond_bear = (price_prev >= wma_prev) & (price < wma)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        self.wma = wma
        return pd.Series(signals, index=df.index)

    def price_crossover_map(self, series):
        mapping_value = {1: 'Price_Cross_Above_WMA', -1: 'Price_Cross_Below_WMA', 0: 'No_Crossover'}
        mapping_explanation = {
            1: 'Price crossed above the Weighted Moving Average, indicating bullish momentum.',
            -1: 'Price crossed below the Weighted Moving Average, indicating bearish momentum.',
            0: 'No price crossover relative to the Weighted Moving Average.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_crossover_strategy(df)
        value, explanation = self.price_crossover_map(score)
        column_prefix = f'WMA_Period:{self.period}_PriceCrossover_Signal'
        if append:
            if ta_indicator_value:
                df[f'WMA_Period:{self.period}_TA_Indicator_Value'] = self.wma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'WMA_Period:{self.period}_TA_Indicator_Value'] = self.wma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        wma = self.compute_values(df)
        diff = wma.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        self.wma = wma
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'WMA_Rising', -1: 'WMA_Falling', 0: 'WMA_Unchanged'}
        mapping_explanation = {
            1: 'Weighted Moving Average is rising, suggesting bullish trend.',
            -1: 'Weighted Moving Average is falling, suggesting bearish trend.',
            0: 'Weighted Moving Average remains unchanged, suggesting neutral trend.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'WMA_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'WMA_Period:{self.period}_TA_Indicator_Value'] = self.wma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'WMA_Period:{self.period}_TA_Indicator_Value'] = self.wma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_deviation_strategy(self, df):
        wma = self.compute_values(df)
        price = df['Close']
        deviation = (price - wma) / wma
        cond_bull = deviation > self.deviation_threshold
        cond_bear = deviation < -self.deviation_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        self.wma = wma
        return pd.Series(signals, index=df.index)

    def deviation_map(self, series):
        mapping_value = {1: 'Price_Above_WMA', -1: 'Price_Below_WMA', 0: 'Price_Near_WMA'}
        mapping_explanation = {
            1: f'Price is above the Weighted Moving Average by more than {self.deviation_threshold*100:.2f}%, indicating bullish conditions.',
            -1: f'Price is below the Weighted Moving Average by more than {self.deviation_threshold*100:.2f}%, indicating bearish conditions.',
            0: 'Price is within the acceptable deviation range of the Weighted Moving Average, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_deviation_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_deviation_strategy(df)
        value, explanation = self.deviation_map(score)
        column_prefix = f'WMA_Period:{self.period}_DeviationThreshold:{self.deviation_threshold}_Signal'
        if append:
            if ta_indicator_value:
                df[f'WMA_Period:{self.period}_TA_Indicator_Value'] = self.wma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'WMA_Period:{self.period}_TA_Indicator_Value'] = self.wma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_crossover_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_deviation_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


  
class WeightedOnBalanceVolumeStrategies:
    def __init__(self, ma_period=20):
        self.ma_period = ma_period

    def compute_values(self, df):
        close = df['Close']
        volume = df['Volume']
        delta = (close.diff() / close.shift(1)) * volume
        delta.iloc[0] = 0
        wobv = delta.cumsum()
        return pd.Series(wobv, index=df.index)

    def calculate_scores_zero_cross_strategy(self, df):
        wobv = self.compute_values(df)
        wobv_prev = wobv.shift(1)
        cond_bull = (wobv_prev <= 0) & (wobv > 0)
        cond_bear = (wobv_prev >= 0) & (wobv < 0)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        self.wobv = wobv
        return pd.Series(signals, index=df.index)

    def zero_cross_map(self, series):
        mapping_value = {1: 'WOBV_Above_Zero', -1: 'WOBV_Below_Zero', 0: 'WOBV_Neutral'}
        mapping_explanation = {
            1: 'Weighted On Balance Volume crossed above zero, indicating bullish volume pressure.',
            -1: 'Weighted On Balance Volume crossed below zero, indicating bearish volume pressure.',
            0: 'No significant zero cross observed in Weighted On Balance Volume.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_zero_cross_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_zero_cross_strategy(df)
        value, explanation = self.zero_cross_map(score)
        column_prefix = 'WOBV_ZeroCross_Signal'
        if append:
            if ta_indicator_value:
                df['WOBV_TA_Indicator_Value'] = self.wobv
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['WOBV_TA_Indicator_Value'] = self.wobv
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        wobv = self.compute_values(df)
        diff = wobv.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        self.wobv = wobv
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'WOBV_Rising', -1: 'WOBV_Falling', 0: 'WOBV_Unchanged'}
        mapping_explanation = {
            1: 'Weighted On Balance Volume is rising, suggesting increasing bullish volume flow.',
            -1: 'Weighted On Balance Volume is falling, suggesting increasing bearish volume flow.',
            0: 'Weighted On Balance Volume remains unchanged, indicating neutral volume pressure.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = 'WOBV_Slope_Signal'
        if append:
            if ta_indicator_value:
                df['WOBV_TA_Indicator_Value'] = self.wobv
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['WOBV_TA_Indicator_Value'] = self.wobv
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_ma_crossover_strategy(self, df):
        wobv = self.compute_values(df)
        ma = wobv.rolling(window=self.ma_period, min_periods=1).mean()
        wobv_prev = wobv.shift(1)
        ma_prev = ma.shift(1)
        cond_bull = (wobv_prev <= ma_prev) & (wobv > ma)
        cond_bear = (wobv_prev >= ma_prev) & (wobv < ma)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        self.wobv = wobv
        self.ma = ma
        return pd.Series(signals, index=df.index)

    def ma_crossover_map(self, series):
        mapping_value = {1: 'WOBV_Above_MA', -1: 'WOBV_Below_MA', 0: 'No_MA_Crossover'}
        mapping_explanation = {
            1: f'Weighted On Balance Volume crossed above its {self.ma_period}-period moving average, indicating bullish momentum.',
            -1: f'Weighted On Balance Volume crossed below its {self.ma_period}-period moving average, indicating bearish momentum.',
            0: f'No crossover between Weighted On Balance Volume and its {self.ma_period}-period moving average detected.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_ma_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_ma_crossover_strategy(df)
        value, explanation = self.ma_crossover_map(score)
        column_prefix = f'WOBV_MA_Crossover_Signal_MA_Period:{self.ma_period}'
        if append:
            if ta_indicator_value:
                df['WOBV_TA_Indicator_Value'] = self.wobv
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy['WOBV_TA_Indicator_Value'] = self.wobv
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_zero_cross_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_ma_crossover_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


  
class WilliamsRStrategies:
    def __init__(self, period=14, upper_threshold=-20, lower_threshold=-80, baseline=-50):
        self.period = period
        self.upper_threshold = upper_threshold
        self.lower_threshold = lower_threshold
        self.baseline = baseline

    def compute_values(self, df):
        highest = df['High'].rolling(window=self.period, min_periods=1).max()
        lowest = df['Low'].rolling(window=self.period, min_periods=1).min()
        wr = ((highest - df['Close']) / (highest - lowest)) * -100
        return pd.Series(wr, index=df.index)

    def calculate_scores_threshold_strategy(self, df):
        wr = self.compute_values(df)
        cond_bull = wr < self.lower_threshold
        cond_bear = wr > self.upper_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        self.wr = wr
        return pd.Series(signals, index=df.index)

    def threshold_map(self, series):
        mapping_value = {1: 'Oversold', -1: 'Overbought', 0: 'Neutral'}
        mapping_explanation = {
            1: f'Williams %R is below {self.lower_threshold}, indicating oversold conditions and potential bullish reversal.',
            -1: f'Williams %R is above {self.upper_threshold}, indicating overbought conditions and potential bearish reversal.',
            0: f'Williams %R is between {self.lower_threshold} and {self.upper_threshold}, indicating neutral conditions.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_threshold_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_threshold_strategy(df)
        value, explanation = self.threshold_map(score)
        column_prefix = f'WR_Period:{self.period}_Threshold_Signal'
        if append:
            if ta_indicator_value:
                df[f'WR_Period:{self.period}_TA_Indicator_Value'] = self.wr
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'WR_Period:{self.period}_TA_Indicator_Value'] = self.wr
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        wr = self.compute_values(df)
        diff = wr.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        self.wr = wr
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'Rising', -1: 'Falling', 0: 'Unchanged'}
        mapping_explanation = {
            1: 'Williams %R is rising, suggesting increasing bullish momentum.',
            -1: 'Williams %R is falling, suggesting increasing bearish momentum.',
            0: 'Williams %R remains unchanged, suggesting neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'WR_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'WR_Period:{self.period}_TA_Indicator_Value'] = self.wr
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'WR_Period:{self.period}_TA_Indicator_Value'] = self.wr
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_baseline_crossover_strategy(self, df):
        wr = self.compute_values(df)
        wr_prev = wr.shift(1)
        cond_bull = (wr_prev <= self.baseline) & (wr > self.baseline)
        cond_bear = (wr_prev >= self.baseline) & (wr < self.baseline)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        self.wr = wr
        return pd.Series(signals, index=df.index)

    def baseline_map(self, series):
        mapping_value = {1: 'Crossed_Above_Baseline', -1: 'Crossed_Below_Baseline', 0: 'No_Crossover'}
        mapping_explanation = {
            1: f'Williams %R crossed above the baseline of {self.baseline}, indicating a bullish shift.',
            -1: f'Williams %R crossed below the baseline of {self.baseline}, indicating a bearish shift.',
            0: f'Williams %R did not cross the baseline of {self.baseline}, indicating neutral momentum.'
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_baseline_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_baseline_crossover_strategy(df)
        value, explanation = self.baseline_map(score)
        column_prefix = f'WR_Period:{self.period}_Baseline:{self.baseline}_Crossover_Signal'
        if append:
            if ta_indicator_value:
                df[f'WR_Period:{self.period}_TA_Indicator_Value'] = self.wr
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'WR_Period:{self.period}_TA_Indicator_Value'] = self.wr
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_threshold_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_baseline_crossover_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


  
class WildersMovingAverageStrategies:
    def __init__(self, period=14, deviation_threshold=0.01):
        self.period = period
        self.deviation_threshold = deviation_threshold

    def compute_values(self, df):
        close = df['Close']
        wma = pd.Series(index=close.index, dtype=float)
        for i in range(len(close)):
            if i < self.period:
                wma.iloc[i] = close.iloc[:i+1].mean()
            else:
                wma.iloc[i] = (wma.iloc[i-1]*(self.period - 1) + close.iloc[i]) / self.period
        return wma

    def calculate_scores_price_crossover_strategy(self, df):
        wma = self.compute_values(df)
        price = df['Close']
        price_prev = price.shift(1)
        wma_prev = wma.shift(1)
        cond_bull = (price_prev <= wma_prev) & (price > wma)
        cond_bear = (price_prev >= wma_prev) & (price < wma)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        self.wma = wma
        return pd.Series(signals, index=df.index)

    def price_crossover_map(self, series):
        mapping_value = {1: 'Price_Cross_Above_WMA', -1: 'Price_Cross_Below_WMA', 0: 'No_Crossover'}
        mapping_explanation = {
            1: "Price crossed above Wilder's Moving Average, indicating bullish momentum.",
            -1: "Price crossed below Wilder's Moving Average, indicating bearish momentum.",
            0: "No price crossover relative to Wilder's Moving Average detected."
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_crossover_strategy(df)
        value, explanation = self.price_crossover_map(score)
        column_prefix = f'WMA_Period:{self.period}_PriceCrossover_Signal'
        if append:
            if ta_indicator_value:
                df[f'WMA_Period:{self.period}_TA_Indicator_Value'] = self.wma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'WMA_Period:{self.period}_TA_Indicator_Value'] = self.wma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        wma = self.compute_values(df)
        diff = wma.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        self.wma = wma
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'WMA_Rising', -1: 'WMA_Falling', 0: 'WMA_Unchanged'}
        mapping_explanation = {
            1: "Wilder's Moving Average is rising, indicating bullish trend momentum.",
            -1: "Wilder's Moving Average is falling, indicating bearish trend momentum.",
            0: "Wilder's Moving Average is unchanged, indicating neutral trend."
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'WMA_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'WMA_Period:{self.period}_TA_Indicator_Value'] = self.wma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'WMA_Period:{self.period}_TA_Indicator_Value'] = self.wma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_deviation_strategy(self, df):
        wma = self.compute_values(df)
        price = df['Close']
        deviation = (price - wma) / wma
        cond_bull = deviation > self.deviation_threshold
        cond_bear = deviation < -self.deviation_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        self.wma = wma
        return pd.Series(signals, index=df.index)

    def deviation_map(self, series):
        mapping_value = {1: 'Price_Above_WMA', -1: 'Price_Below_WMA', 0: 'Price_Near_WMA'}
        mapping_explanation = {
            1: f"Price is above Wilder's Moving Average by more than {self.deviation_threshold*100:.2f}%, indicating bullish conditions.",
            -1: f"Price is below Wilder's Moving Average by more than {self.deviation_threshold*100:.2f}%, indicating bearish conditions.",
            0: "Price is within the acceptable deviation range of Wilder's Moving Average, indicating neutral conditions."
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_deviation_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_deviation_strategy(df)
        value, explanation = self.deviation_map(score)
        column_prefix = f'WMA_Period:{self.period}_DeviationThreshold:{self.deviation_threshold}_Signal'
        if append:
            if ta_indicator_value:
                df[f'WMA_Period:{self.period}_TA_Indicator_Value'] = self.wma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'WMA_Period:{self.period}_TA_Indicator_Value'] = self.wma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_crossover_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_deviation_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


  
class ZeroLagExponentialMovingAverageStrategies:
    def __init__(self, period=14, deviation_threshold=0.01):
        self.period = period
        self.deviation_threshold = deviation_threshold

    def compute_values(self, df):
        lag = int((self.period - 1) / 2)
        adjusted = df['Close'] + (df['Close'] - df['Close'].shift(lag).fillna(method='bfill'))
        zlema = adjusted.ewm(alpha=2/(self.period+1), adjust=False).mean()
        return pd.Series(zlema, index=df.index)

    def calculate_scores_price_crossover_strategy(self, df):
        zlema = self.compute_values(df)
        price = df['Close']
        price_prev = price.shift(1)
        zlema_prev = zlema.shift(1)
        cond_bull = (price_prev <= zlema_prev) & (price > zlema)
        cond_bear = (price_prev >= zlema_prev) & (price < zlema)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        self.zlema = zlema
        return pd.Series(signals, index=df.index)

    def price_crossover_map(self, series):
        mapping_value = {1: 'Price_Cross_Above_ZLEMA', -1: 'Price_Cross_Below_ZLEMA', 0: 'No_Crossover'}
        mapping_explanation = {
            1: "Price crossed above the Zero Lag EMA, indicating bullish momentum.",
            -1: "Price crossed below the Zero Lag EMA, indicating bearish momentum.",
            0: "No price crossover relative to the Zero Lag EMA detected."
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_crossover_strategy(df)
        value, explanation = self.price_crossover_map(score)
        column_prefix = f'ZLEMA_Period:{self.period}_PriceCrossover_Signal'
        if append:
            if ta_indicator_value:
                df[f'ZLEMA_Period:{self.period}_TA_Indicator_Value'] = self.zlema
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ZLEMA_Period:{self.period}_TA_Indicator_Value'] = self.zlema
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        zlema = self.compute_values(df)
        diff = zlema.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        self.zlema = zlema
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'ZLEMA_Rising', -1: 'ZLEMA_Falling', 0: 'ZLEMA_Unchanged'}
        mapping_explanation = {
            1: "Zero Lag EMA is rising, suggesting bullish trend momentum.",
            -1: "Zero Lag EMA is falling, suggesting bearish trend momentum.",
            0: "Zero Lag EMA remains unchanged, indicating neutral momentum."
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'ZLEMA_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'ZLEMA_Period:{self.period}_TA_Indicator_Value'] = self.zlema
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ZLEMA_Period:{self.period}_TA_Indicator_Value'] = self.zlema
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_deviation_strategy(self, df):
        zlema = self.compute_values(df)
        price = df['Close']
        deviation = (price - zlema) / zlema
        cond_bull = deviation > self.deviation_threshold
        cond_bear = deviation < -self.deviation_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        self.zlema = zlema
        return pd.Series(signals, index=df.index)

    def deviation_map(self, series):
        mapping_value = {1: 'Price_Above_ZLEMA', -1: 'Price_Below_ZLEMA', 0: 'Price_Near_ZLEMA'}
        mapping_explanation = {
            1: f"Price is above the Zero Lag EMA by more than {self.deviation_threshold*100:.2f}%, indicating bullish strength.",
            -1: f"Price is below the Zero Lag EMA by more than {self.deviation_threshold*100:.2f}%, indicating bearish weakness.",
            0: "Price is within the acceptable deviation range of the Zero Lag EMA, indicating neutral conditions."
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_deviation_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_deviation_strategy(df)
        value, explanation = self.deviation_map(score)
        column_prefix = f'ZLEMA_Period:{self.period}_DeviationThreshold:{self.deviation_threshold}_Signal'
        if append:
            if ta_indicator_value:
                df[f'ZLEMA_Period:{self.period}_TA_Indicator_Value'] = self.zlema
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ZLEMA_Period:{self.period}_TA_Indicator_Value'] = self.zlema
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_crossover_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_deviation_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


  
class ZeroLagSimpleMovingAverageStrategies:
    def __init__(self, period=14, deviation_threshold=0.01):
        self.period = period
        self.deviation_threshold = deviation_threshold

    def compute_values(self, df):
        sma = df['Close'].rolling(window=self.period, min_periods=1).mean()
        adjusted = 2 * df['Close'] - sma
        zlsma = adjusted.rolling(window=self.period, min_periods=1).mean()
        return pd.Series(zlsma, index=df.index)

    def calculate_scores_price_crossover_strategy(self, df):
        zlsma = self.compute_values(df)
        price = df['Close']
        price_prev = price.shift(1)
        zlsma_prev = zlsma.shift(1)
        cond_bull = (price_prev <= zlsma_prev) & (price > zlsma)
        cond_bear = (price_prev >= zlsma_prev) & (price < zlsma)
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        self.zlsma = zlsma
        return pd.Series(signals, index=df.index)

    def price_crossover_map(self, series):
        mapping_value = {1: 'Price_Cross_Above_ZLSMA', -1: 'Price_Cross_Below_ZLSMA', 0: 'No_Crossover'}
        mapping_explanation = {
            1: "Price crossed above the Zero Lag SMA, indicating bullish momentum.",
            -1: "Price crossed below the Zero Lag SMA, indicating bearish momentum.",
            0: "No price crossover relative to the Zero Lag SMA detected."
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_price_crossover_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_price_crossover_strategy(df)
        value, explanation = self.price_crossover_map(score)
        column_prefix = f'ZLSMA_Period:{self.period}_PriceCrossover_Signal'
        if append:
            if ta_indicator_value:
                df[f'ZLSMA_Period:{self.period}_TA_Indicator_Value'] = self.zlsma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ZLSMA_Period:{self.period}_TA_Indicator_Value'] = self.zlsma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_slope_strategy(self, df):
        zlsma = self.compute_values(df)
        diff = zlsma.diff()
        signals = np.where(diff > 0, 1, np.where(diff < 0, -1, 0))
        self.zlsma = zlsma
        return pd.Series(signals, index=df.index)

    def slope_map(self, series):
        mapping_value = {1: 'ZLSMA_Rising', -1: 'ZLSMA_Falling', 0: 'ZLSMA_Unchanged'}
        mapping_explanation = {
            1: "Zero Lag SMA is rising, suggesting bullish momentum.",
            -1: "Zero Lag SMA is falling, suggesting bearish momentum.",
            0: "Zero Lag SMA remains unchanged, indicating neutral trend."
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_slope_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_slope_strategy(df)
        value, explanation = self.slope_map(score)
        column_prefix = f'ZLSMA_Period:{self.period}_Slope_Signal'
        if append:
            if ta_indicator_value:
                df[f'ZLSMA_Period:{self.period}_TA_Indicator_Value'] = self.zlsma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ZLSMA_Period:{self.period}_TA_Indicator_Value'] = self.zlsma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def calculate_scores_deviation_strategy(self, df):
        zlsma = self.compute_values(df)
        price = df['Close']
        deviation = (price - zlsma) / zlsma
        cond_bull = deviation > self.deviation_threshold
        cond_bear = deviation < -self.deviation_threshold
        signals = np.select([cond_bull, cond_bear], [1, -1], default=0)
        self.zlsma = zlsma
        return pd.Series(signals, index=df.index)

    def deviation_map(self, series):
        mapping_value = {1: 'Price_Above_ZLSMA', -1: 'Price_Below_ZLSMA', 0: 'Price_Near_ZLSMA'}
        mapping_explanation = {
            1: f"Price is above the Zero Lag SMA by more than {self.deviation_threshold*100:.2f}%, indicating bullish conditions.",
            -1: f"Price is below the Zero Lag SMA by more than {self.deviation_threshold*100:.2f}%, indicating bearish conditions.",
            0: "Price is within the acceptable deviation range of the Zero Lag SMA, indicating neutral conditions."
        }
        return series.map(mapping_value), series.map(mapping_explanation)

    def calculate_deviation_values(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        score = self.calculate_scores_deviation_strategy(df)
        value, explanation = self.deviation_map(score)
        column_prefix = f'ZLSMA_Period:{self.period}_DeviationThreshold:{self.deviation_threshold}_Signal'
        if append:
            if ta_indicator_value:
                df[f'ZLSMA_Period:{self.period}_TA_Indicator_Value'] = self.zlsma
            if signal_score:
                df[f'{column_prefix}_Score'] = score
            if signal_value:
                df[f'{column_prefix}_Value'] = value
            if signal_explanation:
                df[f'{column_prefix}_Explanation'] = explanation
        df_copy = pd.DataFrame()
        if ta_indicator_value:
            df_copy[f'ZLSMA_Period:{self.period}_TA_Indicator_Value'] = self.zlsma
        if signal_score:
            df_copy[f'{column_prefix}_Score'] = score
        if signal_value:
            df_copy[f'{column_prefix}_Value'] = value
        if signal_explanation:
            df_copy[f'{column_prefix}_Explanation'] = explanation
        return df_copy

    def run_all_strategies(self, df, append=True, ta_indicator_value=False, signal_score=True, signal_value=False, signal_explanation=False):
        df_copy_1 = self.calculate_price_crossover_values(df, append=append, ta_indicator_value=ta_indicator_value, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_2 = self.calculate_slope_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        df_copy_3 = self.calculate_deviation_values(df, append=append, ta_indicator_value=False, signal_score=signal_score, signal_value=signal_value, signal_explanation=signal_explanation)
        return pd.concat([df_copy_1, df_copy_2, df_copy_3], axis=1)


  
